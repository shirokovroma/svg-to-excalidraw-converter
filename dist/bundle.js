/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var svg_to_excalidraw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svg-to-excalidraw */ \"./node_modules/svg-to-excalidraw/dist/bundle.js\");\n/* harmony import */ var svg_to_excalidraw__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(svg_to_excalidraw__WEBPACK_IMPORTED_MODULE_0__);\n\n\nconst fileSelector = document.getElementById(\"source\");\nconst textContainer = document.getElementById(\"text\");\nfileSelector.addEventListener(\"change\", (event) => {\n  textContainer.innerText = \"Processing...\";\n  const fileList = event.target.files;\n  for (let i = 0; i < fileList.length; i++) {\n    const name = fileList[i].name.replace(\".svg\", \".excalidraw\");\n    const contents = readFile(fileList[i]);\n    downloadFile(name, contents);\n  }\n  // clear the input\n  event.target.value = \"\";\n  textContainer.innerHTML = \"Drag and drop your svg file here <br>or click to select file\";\n});\n\nfunction readFile(file) {\n  if (file.type && file.type !== \"image/svg+xml\") {\n    console.log(\"File is not SVG.\");\n\n    return;\n  }\n\n  const reader = new FileReader();\n\n  reader.readAsText(file);\n  reader.addEventListener(\"load\", (event) => {\n   const { hasErrors, errors, content } = svg_to_excalidraw__WEBPACK_IMPORTED_MODULE_0___default().convert(event.target.result);\n   if (hasErrors) {\n     console.log(errors);\n   }\n   console.log(content);\n   return JSON.stringify(content, null, 2)\n  });\n}\n\nfunction downloadFile(filename, contents){\n  const link = document.createElement('a');\n  link.download = filename;\n  link.href = 'data:text/plain;charset=utf-8,' + encodeURIComponent(contents);\n  document.body.appendChild(link);\n  link.click();\n\n  document.body.removeChild(link);\n  return link;\n}\n\n//# sourceURL=webpack://svg-excalidraw/./index.js?");

/***/ }),

/***/ "./node_modules/svg-to-excalidraw/dist/bundle.js":
/*!*******************************************************!*\
  !*** ./node_modules/svg-to-excalidraw/dist/bundle.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("!function(g,I){ true?module.exports=I():0}(self,(function(){return(()=>{var __webpack_modules__={773:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{\"use strict\";eval('// ESM COMPAT FLAG\\n__webpack_require__.r(__webpack_exports__);\\n\\n// EXPORTS\\n__webpack_require__.d(__webpack_exports__, {\\n  \"default\": () => (/* binding */ src)\\n});\\n\\n// NAMESPACE OBJECT: ./src/parser.ts\\nvar src_parser_namespaceObject = {};\\n__webpack_require__.r(src_parser_namespaceObject);\\n__webpack_require__.d(src_parser_namespaceObject, {\\n  \"convert\": () => (convert)\\n});\\n\\n;// CONCATENATED MODULE: ./src/elements/ExcalidrawScene.ts\\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\\n\\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\\n\\nvar ExcalidrawScene = /*#__PURE__*/function () {\\n  function ExcalidrawScene() {\\n    var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n    _classCallCheck(this, ExcalidrawScene);\\n\\n    _defineProperty(this, \"type\", \"excalidraw\");\\n\\n    _defineProperty(this, \"version\", 2);\\n\\n    _defineProperty(this, \"source\", \"https://excalidraw.com\");\\n\\n    _defineProperty(this, \"elements\", []);\\n\\n    this.elements = elements;\\n  }\\n\\n  _createClass(ExcalidrawScene, [{\\n    key: \"toExJSON\",\\n    value: function toExJSON() {\\n      return _objectSpread(_objectSpread({}, this), {}, {\\n        elements: this.elements.map(function (el) {\\n          return _objectSpread({}, el);\\n        })\\n      });\\n    }\\n  }]);\\n\\n  return ExcalidrawScene;\\n}();\\n\\n/* harmony default export */ const elements_ExcalidrawScene = (ExcalidrawScene);\\n;// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/common.js\\n/**\\r\\n * Common utilities\\r\\n * @module glMatrix\\r\\n */\\n// Configuration Constants\\nvar EPSILON = 0.000001;\\nvar ARRAY_TYPE = typeof Float32Array !== \\'undefined\\' ? Float32Array : Array;\\nvar RANDOM = Math.random;\\n/**\\r\\n * Sets the type of array used when creating new vectors and matrices\\r\\n *\\r\\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\\r\\n */\\n\\nfunction setMatrixArrayType(type) {\\n  ARRAY_TYPE = type;\\n}\\nvar degree = Math.PI / 180;\\n/**\\r\\n * Convert Degree To Radian\\r\\n *\\r\\n * @param {Number} a Angle in Degrees\\r\\n */\\n\\nfunction toRadian(a) {\\n  return a * degree;\\n}\\n/**\\r\\n * Tests whether or not the arguments have approximately the same value, within an absolute\\r\\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\\r\\n * than or equal to 1.0, and a relative tolerance is used for larger values)\\r\\n *\\r\\n * @param {Number} a The first number to test.\\r\\n * @param {Number} b The second number to test.\\r\\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\\r\\n */\\n\\nfunction equals(a, b) {\\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\\n}\\nif (!Math.hypot) Math.hypot = function () {\\n  var y = 0,\\n      i = arguments.length;\\n\\n  while (i--) {\\n    y += arguments[i] * arguments[i];\\n  }\\n\\n  return Math.sqrt(y);\\n};\\n;// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/mat4.js\\n\\n/**\\r\\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\\r\\n * @module mat4\\r\\n */\\n\\n/**\\r\\n * Creates a new identity mat4\\r\\n *\\r\\n * @returns {mat4} a new 4x4 matrix\\r\\n */\\n\\nfunction create() {\\n  var out = new ARRAY_TYPE(16);\\n\\n  if (ARRAY_TYPE != Float32Array) {\\n    out[1] = 0;\\n    out[2] = 0;\\n    out[3] = 0;\\n    out[4] = 0;\\n    out[6] = 0;\\n    out[7] = 0;\\n    out[8] = 0;\\n    out[9] = 0;\\n    out[11] = 0;\\n    out[12] = 0;\\n    out[13] = 0;\\n    out[14] = 0;\\n  }\\n\\n  out[0] = 1;\\n  out[5] = 1;\\n  out[10] = 1;\\n  out[15] = 1;\\n  return out;\\n}\\n/**\\r\\n * Creates a new mat4 initialized with values from an existing matrix\\r\\n *\\r\\n * @param {ReadonlyMat4} a matrix to clone\\r\\n * @returns {mat4} a new 4x4 matrix\\r\\n */\\n\\nfunction clone(a) {\\n  var out = new ARRAY_TYPE(16);\\n  out[0] = a[0];\\n  out[1] = a[1];\\n  out[2] = a[2];\\n  out[3] = a[3];\\n  out[4] = a[4];\\n  out[5] = a[5];\\n  out[6] = a[6];\\n  out[7] = a[7];\\n  out[8] = a[8];\\n  out[9] = a[9];\\n  out[10] = a[10];\\n  out[11] = a[11];\\n  out[12] = a[12];\\n  out[13] = a[13];\\n  out[14] = a[14];\\n  out[15] = a[15];\\n  return out;\\n}\\n/**\\r\\n * Copy the values from one mat4 to another\\r\\n *\\r\\n * @param {mat4} out the receiving matrix\\r\\n * @param {ReadonlyMat4} a the source matrix\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction copy(out, a) {\\n  out[0] = a[0];\\n  out[1] = a[1];\\n  out[2] = a[2];\\n  out[3] = a[3];\\n  out[4] = a[4];\\n  out[5] = a[5];\\n  out[6] = a[6];\\n  out[7] = a[7];\\n  out[8] = a[8];\\n  out[9] = a[9];\\n  out[10] = a[10];\\n  out[11] = a[11];\\n  out[12] = a[12];\\n  out[13] = a[13];\\n  out[14] = a[14];\\n  out[15] = a[15];\\n  return out;\\n}\\n/**\\r\\n * Create a new mat4 with the given values\\r\\n *\\r\\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\\r\\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\\r\\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\\r\\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\\r\\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\\r\\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\\r\\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\\r\\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\\r\\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\\r\\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\\r\\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\\r\\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\\r\\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\\r\\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\\r\\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\\r\\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\\r\\n * @returns {mat4} A new mat4\\r\\n */\\n\\nfunction fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\\n  var out = new ARRAY_TYPE(16);\\n  out[0] = m00;\\n  out[1] = m01;\\n  out[2] = m02;\\n  out[3] = m03;\\n  out[4] = m10;\\n  out[5] = m11;\\n  out[6] = m12;\\n  out[7] = m13;\\n  out[8] = m20;\\n  out[9] = m21;\\n  out[10] = m22;\\n  out[11] = m23;\\n  out[12] = m30;\\n  out[13] = m31;\\n  out[14] = m32;\\n  out[15] = m33;\\n  return out;\\n}\\n/**\\r\\n * Set the components of a mat4 to the given values\\r\\n *\\r\\n * @param {mat4} out the receiving matrix\\r\\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\\r\\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\\r\\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\\r\\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\\r\\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\\r\\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\\r\\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\\r\\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\\r\\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\\r\\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\\r\\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\\r\\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\\r\\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\\r\\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\\r\\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\\r\\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\\n  out[0] = m00;\\n  out[1] = m01;\\n  out[2] = m02;\\n  out[3] = m03;\\n  out[4] = m10;\\n  out[5] = m11;\\n  out[6] = m12;\\n  out[7] = m13;\\n  out[8] = m20;\\n  out[9] = m21;\\n  out[10] = m22;\\n  out[11] = m23;\\n  out[12] = m30;\\n  out[13] = m31;\\n  out[14] = m32;\\n  out[15] = m33;\\n  return out;\\n}\\n/**\\r\\n * Set a mat4 to the identity matrix\\r\\n *\\r\\n * @param {mat4} out the receiving matrix\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction identity(out) {\\n  out[0] = 1;\\n  out[1] = 0;\\n  out[2] = 0;\\n  out[3] = 0;\\n  out[4] = 0;\\n  out[5] = 1;\\n  out[6] = 0;\\n  out[7] = 0;\\n  out[8] = 0;\\n  out[9] = 0;\\n  out[10] = 1;\\n  out[11] = 0;\\n  out[12] = 0;\\n  out[13] = 0;\\n  out[14] = 0;\\n  out[15] = 1;\\n  return out;\\n}\\n/**\\r\\n * Transpose the values of a mat4\\r\\n *\\r\\n * @param {mat4} out the receiving matrix\\r\\n * @param {ReadonlyMat4} a the source matrix\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction transpose(out, a) {\\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\\n  if (out === a) {\\n    var a01 = a[1],\\n        a02 = a[2],\\n        a03 = a[3];\\n    var a12 = a[6],\\n        a13 = a[7];\\n    var a23 = a[11];\\n    out[1] = a[4];\\n    out[2] = a[8];\\n    out[3] = a[12];\\n    out[4] = a01;\\n    out[6] = a[9];\\n    out[7] = a[13];\\n    out[8] = a02;\\n    out[9] = a12;\\n    out[11] = a[14];\\n    out[12] = a03;\\n    out[13] = a13;\\n    out[14] = a23;\\n  } else {\\n    out[0] = a[0];\\n    out[1] = a[4];\\n    out[2] = a[8];\\n    out[3] = a[12];\\n    out[4] = a[1];\\n    out[5] = a[5];\\n    out[6] = a[9];\\n    out[7] = a[13];\\n    out[8] = a[2];\\n    out[9] = a[6];\\n    out[10] = a[10];\\n    out[11] = a[14];\\n    out[12] = a[3];\\n    out[13] = a[7];\\n    out[14] = a[11];\\n    out[15] = a[15];\\n  }\\n\\n  return out;\\n}\\n/**\\r\\n * Inverts a mat4\\r\\n *\\r\\n * @param {mat4} out the receiving matrix\\r\\n * @param {ReadonlyMat4} a the source matrix\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction invert(out, a) {\\n  var a00 = a[0],\\n      a01 = a[1],\\n      a02 = a[2],\\n      a03 = a[3];\\n  var a10 = a[4],\\n      a11 = a[5],\\n      a12 = a[6],\\n      a13 = a[7];\\n  var a20 = a[8],\\n      a21 = a[9],\\n      a22 = a[10],\\n      a23 = a[11];\\n  var a30 = a[12],\\n      a31 = a[13],\\n      a32 = a[14],\\n      a33 = a[15];\\n  var b00 = a00 * a11 - a01 * a10;\\n  var b01 = a00 * a12 - a02 * a10;\\n  var b02 = a00 * a13 - a03 * a10;\\n  var b03 = a01 * a12 - a02 * a11;\\n  var b04 = a01 * a13 - a03 * a11;\\n  var b05 = a02 * a13 - a03 * a12;\\n  var b06 = a20 * a31 - a21 * a30;\\n  var b07 = a20 * a32 - a22 * a30;\\n  var b08 = a20 * a33 - a23 * a30;\\n  var b09 = a21 * a32 - a22 * a31;\\n  var b10 = a21 * a33 - a23 * a31;\\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\\n\\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\\n\\n  if (!det) {\\n    return null;\\n  }\\n\\n  det = 1.0 / det;\\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\\n  return out;\\n}\\n/**\\r\\n * Calculates the adjugate of a mat4\\r\\n *\\r\\n * @param {mat4} out the receiving matrix\\r\\n * @param {ReadonlyMat4} a the source matrix\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction adjoint(out, a) {\\n  var a00 = a[0],\\n      a01 = a[1],\\n      a02 = a[2],\\n      a03 = a[3];\\n  var a10 = a[4],\\n      a11 = a[5],\\n      a12 = a[6],\\n      a13 = a[7];\\n  var a20 = a[8],\\n      a21 = a[9],\\n      a22 = a[10],\\n      a23 = a[11];\\n  var a30 = a[12],\\n      a31 = a[13],\\n      a32 = a[14],\\n      a33 = a[15];\\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\\n  return out;\\n}\\n/**\\r\\n * Calculates the determinant of a mat4\\r\\n *\\r\\n * @param {ReadonlyMat4} a the source matrix\\r\\n * @returns {Number} determinant of a\\r\\n */\\n\\nfunction determinant(a) {\\n  var a00 = a[0],\\n      a01 = a[1],\\n      a02 = a[2],\\n      a03 = a[3];\\n  var a10 = a[4],\\n      a11 = a[5],\\n      a12 = a[6],\\n      a13 = a[7];\\n  var a20 = a[8],\\n      a21 = a[9],\\n      a22 = a[10],\\n      a23 = a[11];\\n  var a30 = a[12],\\n      a31 = a[13],\\n      a32 = a[14],\\n      a33 = a[15];\\n  var b00 = a00 * a11 - a01 * a10;\\n  var b01 = a00 * a12 - a02 * a10;\\n  var b02 = a00 * a13 - a03 * a10;\\n  var b03 = a01 * a12 - a02 * a11;\\n  var b04 = a01 * a13 - a03 * a11;\\n  var b05 = a02 * a13 - a03 * a12;\\n  var b06 = a20 * a31 - a21 * a30;\\n  var b07 = a20 * a32 - a22 * a30;\\n  var b08 = a20 * a33 - a23 * a30;\\n  var b09 = a21 * a32 - a22 * a31;\\n  var b10 = a21 * a33 - a23 * a31;\\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\\n\\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\\n}\\n/**\\r\\n * Multiplies two mat4s\\r\\n *\\r\\n * @param {mat4} out the receiving matrix\\r\\n * @param {ReadonlyMat4} a the first operand\\r\\n * @param {ReadonlyMat4} b the second operand\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction multiply(out, a, b) {\\n  var a00 = a[0],\\n      a01 = a[1],\\n      a02 = a[2],\\n      a03 = a[3];\\n  var a10 = a[4],\\n      a11 = a[5],\\n      a12 = a[6],\\n      a13 = a[7];\\n  var a20 = a[8],\\n      a21 = a[9],\\n      a22 = a[10],\\n      a23 = a[11];\\n  var a30 = a[12],\\n      a31 = a[13],\\n      a32 = a[14],\\n      a33 = a[15]; // Cache only the current line of the second matrix\\n\\n  var b0 = b[0],\\n      b1 = b[1],\\n      b2 = b[2],\\n      b3 = b[3];\\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\\n  b0 = b[4];\\n  b1 = b[5];\\n  b2 = b[6];\\n  b3 = b[7];\\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\\n  b0 = b[8];\\n  b1 = b[9];\\n  b2 = b[10];\\n  b3 = b[11];\\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\\n  b0 = b[12];\\n  b1 = b[13];\\n  b2 = b[14];\\n  b3 = b[15];\\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\\n  return out;\\n}\\n/**\\r\\n * Translate a mat4 by the given vector\\r\\n *\\r\\n * @param {mat4} out the receiving matrix\\r\\n * @param {ReadonlyMat4} a the matrix to translate\\r\\n * @param {ReadonlyVec3} v vector to translate by\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction translate(out, a, v) {\\n  var x = v[0],\\n      y = v[1],\\n      z = v[2];\\n  var a00, a01, a02, a03;\\n  var a10, a11, a12, a13;\\n  var a20, a21, a22, a23;\\n\\n  if (a === out) {\\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\\n  } else {\\n    a00 = a[0];\\n    a01 = a[1];\\n    a02 = a[2];\\n    a03 = a[3];\\n    a10 = a[4];\\n    a11 = a[5];\\n    a12 = a[6];\\n    a13 = a[7];\\n    a20 = a[8];\\n    a21 = a[9];\\n    a22 = a[10];\\n    a23 = a[11];\\n    out[0] = a00;\\n    out[1] = a01;\\n    out[2] = a02;\\n    out[3] = a03;\\n    out[4] = a10;\\n    out[5] = a11;\\n    out[6] = a12;\\n    out[7] = a13;\\n    out[8] = a20;\\n    out[9] = a21;\\n    out[10] = a22;\\n    out[11] = a23;\\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\\n  }\\n\\n  return out;\\n}\\n/**\\r\\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\\r\\n *\\r\\n * @param {mat4} out the receiving matrix\\r\\n * @param {ReadonlyMat4} a the matrix to scale\\r\\n * @param {ReadonlyVec3} v the vec3 to scale the matrix by\\r\\n * @returns {mat4} out\\r\\n **/\\n\\nfunction scale(out, a, v) {\\n  var x = v[0],\\n      y = v[1],\\n      z = v[2];\\n  out[0] = a[0] * x;\\n  out[1] = a[1] * x;\\n  out[2] = a[2] * x;\\n  out[3] = a[3] * x;\\n  out[4] = a[4] * y;\\n  out[5] = a[5] * y;\\n  out[6] = a[6] * y;\\n  out[7] = a[7] * y;\\n  out[8] = a[8] * z;\\n  out[9] = a[9] * z;\\n  out[10] = a[10] * z;\\n  out[11] = a[11] * z;\\n  out[12] = a[12];\\n  out[13] = a[13];\\n  out[14] = a[14];\\n  out[15] = a[15];\\n  return out;\\n}\\n/**\\r\\n * Rotates a mat4 by the given angle around the given axis\\r\\n *\\r\\n * @param {mat4} out the receiving matrix\\r\\n * @param {ReadonlyMat4} a the matrix to rotate\\r\\n * @param {Number} rad the angle to rotate the matrix by\\r\\n * @param {ReadonlyVec3} axis the axis to rotate around\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction rotate(out, a, rad, axis) {\\n  var x = axis[0],\\n      y = axis[1],\\n      z = axis[2];\\n  var len = Math.hypot(x, y, z);\\n  var s, c, t;\\n  var a00, a01, a02, a03;\\n  var a10, a11, a12, a13;\\n  var a20, a21, a22, a23;\\n  var b00, b01, b02;\\n  var b10, b11, b12;\\n  var b20, b21, b22;\\n\\n  if (len < glMatrix.EPSILON) {\\n    return null;\\n  }\\n\\n  len = 1 / len;\\n  x *= len;\\n  y *= len;\\n  z *= len;\\n  s = Math.sin(rad);\\n  c = Math.cos(rad);\\n  t = 1 - c;\\n  a00 = a[0];\\n  a01 = a[1];\\n  a02 = a[2];\\n  a03 = a[3];\\n  a10 = a[4];\\n  a11 = a[5];\\n  a12 = a[6];\\n  a13 = a[7];\\n  a20 = a[8];\\n  a21 = a[9];\\n  a22 = a[10];\\n  a23 = a[11]; // Construct the elements of the rotation matrix\\n\\n  b00 = x * x * t + c;\\n  b01 = y * x * t + z * s;\\n  b02 = z * x * t - y * s;\\n  b10 = x * y * t - z * s;\\n  b11 = y * y * t + c;\\n  b12 = z * y * t + x * s;\\n  b20 = x * z * t + y * s;\\n  b21 = y * z * t - x * s;\\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\\n\\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\\n\\n  if (a !== out) {\\n    // If the source and destination differ, copy the unchanged last row\\n    out[12] = a[12];\\n    out[13] = a[13];\\n    out[14] = a[14];\\n    out[15] = a[15];\\n  }\\n\\n  return out;\\n}\\n/**\\r\\n * Rotates a matrix by the given angle around the X axis\\r\\n *\\r\\n * @param {mat4} out the receiving matrix\\r\\n * @param {ReadonlyMat4} a the matrix to rotate\\r\\n * @param {Number} rad the angle to rotate the matrix by\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction rotateX(out, a, rad) {\\n  var s = Math.sin(rad);\\n  var c = Math.cos(rad);\\n  var a10 = a[4];\\n  var a11 = a[5];\\n  var a12 = a[6];\\n  var a13 = a[7];\\n  var a20 = a[8];\\n  var a21 = a[9];\\n  var a22 = a[10];\\n  var a23 = a[11];\\n\\n  if (a !== out) {\\n    // If the source and destination differ, copy the unchanged rows\\n    out[0] = a[0];\\n    out[1] = a[1];\\n    out[2] = a[2];\\n    out[3] = a[3];\\n    out[12] = a[12];\\n    out[13] = a[13];\\n    out[14] = a[14];\\n    out[15] = a[15];\\n  } // Perform axis-specific matrix multiplication\\n\\n\\n  out[4] = a10 * c + a20 * s;\\n  out[5] = a11 * c + a21 * s;\\n  out[6] = a12 * c + a22 * s;\\n  out[7] = a13 * c + a23 * s;\\n  out[8] = a20 * c - a10 * s;\\n  out[9] = a21 * c - a11 * s;\\n  out[10] = a22 * c - a12 * s;\\n  out[11] = a23 * c - a13 * s;\\n  return out;\\n}\\n/**\\r\\n * Rotates a matrix by the given angle around the Y axis\\r\\n *\\r\\n * @param {mat4} out the receiving matrix\\r\\n * @param {ReadonlyMat4} a the matrix to rotate\\r\\n * @param {Number} rad the angle to rotate the matrix by\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction rotateY(out, a, rad) {\\n  var s = Math.sin(rad);\\n  var c = Math.cos(rad);\\n  var a00 = a[0];\\n  var a01 = a[1];\\n  var a02 = a[2];\\n  var a03 = a[3];\\n  var a20 = a[8];\\n  var a21 = a[9];\\n  var a22 = a[10];\\n  var a23 = a[11];\\n\\n  if (a !== out) {\\n    // If the source and destination differ, copy the unchanged rows\\n    out[4] = a[4];\\n    out[5] = a[5];\\n    out[6] = a[6];\\n    out[7] = a[7];\\n    out[12] = a[12];\\n    out[13] = a[13];\\n    out[14] = a[14];\\n    out[15] = a[15];\\n  } // Perform axis-specific matrix multiplication\\n\\n\\n  out[0] = a00 * c - a20 * s;\\n  out[1] = a01 * c - a21 * s;\\n  out[2] = a02 * c - a22 * s;\\n  out[3] = a03 * c - a23 * s;\\n  out[8] = a00 * s + a20 * c;\\n  out[9] = a01 * s + a21 * c;\\n  out[10] = a02 * s + a22 * c;\\n  out[11] = a03 * s + a23 * c;\\n  return out;\\n}\\n/**\\r\\n * Rotates a matrix by the given angle around the Z axis\\r\\n *\\r\\n * @param {mat4} out the receiving matrix\\r\\n * @param {ReadonlyMat4} a the matrix to rotate\\r\\n * @param {Number} rad the angle to rotate the matrix by\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction rotateZ(out, a, rad) {\\n  var s = Math.sin(rad);\\n  var c = Math.cos(rad);\\n  var a00 = a[0];\\n  var a01 = a[1];\\n  var a02 = a[2];\\n  var a03 = a[3];\\n  var a10 = a[4];\\n  var a11 = a[5];\\n  var a12 = a[6];\\n  var a13 = a[7];\\n\\n  if (a !== out) {\\n    // If the source and destination differ, copy the unchanged last row\\n    out[8] = a[8];\\n    out[9] = a[9];\\n    out[10] = a[10];\\n    out[11] = a[11];\\n    out[12] = a[12];\\n    out[13] = a[13];\\n    out[14] = a[14];\\n    out[15] = a[15];\\n  } // Perform axis-specific matrix multiplication\\n\\n\\n  out[0] = a00 * c + a10 * s;\\n  out[1] = a01 * c + a11 * s;\\n  out[2] = a02 * c + a12 * s;\\n  out[3] = a03 * c + a13 * s;\\n  out[4] = a10 * c - a00 * s;\\n  out[5] = a11 * c - a01 * s;\\n  out[6] = a12 * c - a02 * s;\\n  out[7] = a13 * c - a03 * s;\\n  return out;\\n}\\n/**\\r\\n * Creates a matrix from a vector translation\\r\\n * This is equivalent to (but much faster than):\\r\\n *\\r\\n *     mat4.identity(dest);\\r\\n *     mat4.translate(dest, dest, vec);\\r\\n *\\r\\n * @param {mat4} out mat4 receiving operation result\\r\\n * @param {ReadonlyVec3} v Translation vector\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction fromTranslation(out, v) {\\n  out[0] = 1;\\n  out[1] = 0;\\n  out[2] = 0;\\n  out[3] = 0;\\n  out[4] = 0;\\n  out[5] = 1;\\n  out[6] = 0;\\n  out[7] = 0;\\n  out[8] = 0;\\n  out[9] = 0;\\n  out[10] = 1;\\n  out[11] = 0;\\n  out[12] = v[0];\\n  out[13] = v[1];\\n  out[14] = v[2];\\n  out[15] = 1;\\n  return out;\\n}\\n/**\\r\\n * Creates a matrix from a vector scaling\\r\\n * This is equivalent to (but much faster than):\\r\\n *\\r\\n *     mat4.identity(dest);\\r\\n *     mat4.scale(dest, dest, vec);\\r\\n *\\r\\n * @param {mat4} out mat4 receiving operation result\\r\\n * @param {ReadonlyVec3} v Scaling vector\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction fromScaling(out, v) {\\n  out[0] = v[0];\\n  out[1] = 0;\\n  out[2] = 0;\\n  out[3] = 0;\\n  out[4] = 0;\\n  out[5] = v[1];\\n  out[6] = 0;\\n  out[7] = 0;\\n  out[8] = 0;\\n  out[9] = 0;\\n  out[10] = v[2];\\n  out[11] = 0;\\n  out[12] = 0;\\n  out[13] = 0;\\n  out[14] = 0;\\n  out[15] = 1;\\n  return out;\\n}\\n/**\\r\\n * Creates a matrix from a given angle around a given axis\\r\\n * This is equivalent to (but much faster than):\\r\\n *\\r\\n *     mat4.identity(dest);\\r\\n *     mat4.rotate(dest, dest, rad, axis);\\r\\n *\\r\\n * @param {mat4} out mat4 receiving operation result\\r\\n * @param {Number} rad the angle to rotate the matrix by\\r\\n * @param {ReadonlyVec3} axis the axis to rotate around\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction fromRotation(out, rad, axis) {\\n  var x = axis[0],\\n      y = axis[1],\\n      z = axis[2];\\n  var len = Math.hypot(x, y, z);\\n  var s, c, t;\\n\\n  if (len < glMatrix.EPSILON) {\\n    return null;\\n  }\\n\\n  len = 1 / len;\\n  x *= len;\\n  y *= len;\\n  z *= len;\\n  s = Math.sin(rad);\\n  c = Math.cos(rad);\\n  t = 1 - c; // Perform rotation-specific matrix multiplication\\n\\n  out[0] = x * x * t + c;\\n  out[1] = y * x * t + z * s;\\n  out[2] = z * x * t - y * s;\\n  out[3] = 0;\\n  out[4] = x * y * t - z * s;\\n  out[5] = y * y * t + c;\\n  out[6] = z * y * t + x * s;\\n  out[7] = 0;\\n  out[8] = x * z * t + y * s;\\n  out[9] = y * z * t - x * s;\\n  out[10] = z * z * t + c;\\n  out[11] = 0;\\n  out[12] = 0;\\n  out[13] = 0;\\n  out[14] = 0;\\n  out[15] = 1;\\n  return out;\\n}\\n/**\\r\\n * Creates a matrix from the given angle around the X axis\\r\\n * This is equivalent to (but much faster than):\\r\\n *\\r\\n *     mat4.identity(dest);\\r\\n *     mat4.rotateX(dest, dest, rad);\\r\\n *\\r\\n * @param {mat4} out mat4 receiving operation result\\r\\n * @param {Number} rad the angle to rotate the matrix by\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction fromXRotation(out, rad) {\\n  var s = Math.sin(rad);\\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\\n\\n  out[0] = 1;\\n  out[1] = 0;\\n  out[2] = 0;\\n  out[3] = 0;\\n  out[4] = 0;\\n  out[5] = c;\\n  out[6] = s;\\n  out[7] = 0;\\n  out[8] = 0;\\n  out[9] = -s;\\n  out[10] = c;\\n  out[11] = 0;\\n  out[12] = 0;\\n  out[13] = 0;\\n  out[14] = 0;\\n  out[15] = 1;\\n  return out;\\n}\\n/**\\r\\n * Creates a matrix from the given angle around the Y axis\\r\\n * This is equivalent to (but much faster than):\\r\\n *\\r\\n *     mat4.identity(dest);\\r\\n *     mat4.rotateY(dest, dest, rad);\\r\\n *\\r\\n * @param {mat4} out mat4 receiving operation result\\r\\n * @param {Number} rad the angle to rotate the matrix by\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction fromYRotation(out, rad) {\\n  var s = Math.sin(rad);\\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\\n\\n  out[0] = c;\\n  out[1] = 0;\\n  out[2] = -s;\\n  out[3] = 0;\\n  out[4] = 0;\\n  out[5] = 1;\\n  out[6] = 0;\\n  out[7] = 0;\\n  out[8] = s;\\n  out[9] = 0;\\n  out[10] = c;\\n  out[11] = 0;\\n  out[12] = 0;\\n  out[13] = 0;\\n  out[14] = 0;\\n  out[15] = 1;\\n  return out;\\n}\\n/**\\r\\n * Creates a matrix from the given angle around the Z axis\\r\\n * This is equivalent to (but much faster than):\\r\\n *\\r\\n *     mat4.identity(dest);\\r\\n *     mat4.rotateZ(dest, dest, rad);\\r\\n *\\r\\n * @param {mat4} out mat4 receiving operation result\\r\\n * @param {Number} rad the angle to rotate the matrix by\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction fromZRotation(out, rad) {\\n  var s = Math.sin(rad);\\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\\n\\n  out[0] = c;\\n  out[1] = s;\\n  out[2] = 0;\\n  out[3] = 0;\\n  out[4] = -s;\\n  out[5] = c;\\n  out[6] = 0;\\n  out[7] = 0;\\n  out[8] = 0;\\n  out[9] = 0;\\n  out[10] = 1;\\n  out[11] = 0;\\n  out[12] = 0;\\n  out[13] = 0;\\n  out[14] = 0;\\n  out[15] = 1;\\n  return out;\\n}\\n/**\\r\\n * Creates a matrix from a quaternion rotation and vector translation\\r\\n * This is equivalent to (but much faster than):\\r\\n *\\r\\n *     mat4.identity(dest);\\r\\n *     mat4.translate(dest, vec);\\r\\n *     let quatMat = mat4.create();\\r\\n *     quat4.toMat4(quat, quatMat);\\r\\n *     mat4.multiply(dest, quatMat);\\r\\n *\\r\\n * @param {mat4} out mat4 receiving operation result\\r\\n * @param {quat4} q Rotation quaternion\\r\\n * @param {ReadonlyVec3} v Translation vector\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction fromRotationTranslation(out, q, v) {\\n  // Quaternion math\\n  var x = q[0],\\n      y = q[1],\\n      z = q[2],\\n      w = q[3];\\n  var x2 = x + x;\\n  var y2 = y + y;\\n  var z2 = z + z;\\n  var xx = x * x2;\\n  var xy = x * y2;\\n  var xz = x * z2;\\n  var yy = y * y2;\\n  var yz = y * z2;\\n  var zz = z * z2;\\n  var wx = w * x2;\\n  var wy = w * y2;\\n  var wz = w * z2;\\n  out[0] = 1 - (yy + zz);\\n  out[1] = xy + wz;\\n  out[2] = xz - wy;\\n  out[3] = 0;\\n  out[4] = xy - wz;\\n  out[5] = 1 - (xx + zz);\\n  out[6] = yz + wx;\\n  out[7] = 0;\\n  out[8] = xz + wy;\\n  out[9] = yz - wx;\\n  out[10] = 1 - (xx + yy);\\n  out[11] = 0;\\n  out[12] = v[0];\\n  out[13] = v[1];\\n  out[14] = v[2];\\n  out[15] = 1;\\n  return out;\\n}\\n/**\\r\\n * Creates a new mat4 from a dual quat.\\r\\n *\\r\\n * @param {mat4} out Matrix\\r\\n * @param {ReadonlyQuat2} a Dual Quaternion\\r\\n * @returns {mat4} mat4 receiving operation result\\r\\n */\\n\\nfunction fromQuat2(out, a) {\\n  var translation = new glMatrix.ARRAY_TYPE(3);\\n  var bx = -a[0],\\n      by = -a[1],\\n      bz = -a[2],\\n      bw = a[3],\\n      ax = a[4],\\n      ay = a[5],\\n      az = a[6],\\n      aw = a[7];\\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense\\n\\n  if (magnitude > 0) {\\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\\n  } else {\\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\\n  }\\n\\n  fromRotationTranslation(out, a, translation);\\n  return out;\\n}\\n/**\\r\\n * Returns the translation vector component of a transformation\\r\\n *  matrix. If a matrix is built with fromRotationTranslation,\\r\\n *  the returned vector will be the same as the translation vector\\r\\n *  originally supplied.\\r\\n * @param  {vec3} out Vector to receive translation component\\r\\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\\r\\n * @return {vec3} out\\r\\n */\\n\\nfunction getTranslation(out, mat) {\\n  out[0] = mat[12];\\n  out[1] = mat[13];\\n  out[2] = mat[14];\\n  return out;\\n}\\n/**\\r\\n * Returns the scaling factor component of a transformation\\r\\n *  matrix. If a matrix is built with fromRotationTranslationScale\\r\\n *  with a normalized Quaternion paramter, the returned vector will be\\r\\n *  the same as the scaling vector\\r\\n *  originally supplied.\\r\\n * @param  {vec3} out Vector to receive scaling factor component\\r\\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\\r\\n * @return {vec3} out\\r\\n */\\n\\nfunction getScaling(out, mat) {\\n  var m11 = mat[0];\\n  var m12 = mat[1];\\n  var m13 = mat[2];\\n  var m21 = mat[4];\\n  var m22 = mat[5];\\n  var m23 = mat[6];\\n  var m31 = mat[8];\\n  var m32 = mat[9];\\n  var m33 = mat[10];\\n  out[0] = Math.hypot(m11, m12, m13);\\n  out[1] = Math.hypot(m21, m22, m23);\\n  out[2] = Math.hypot(m31, m32, m33);\\n  return out;\\n}\\n/**\\r\\n * Returns a quaternion representing the rotational component\\r\\n *  of a transformation matrix. If a matrix is built with\\r\\n *  fromRotationTranslation, the returned quaternion will be the\\r\\n *  same as the quaternion originally supplied.\\r\\n * @param {quat} out Quaternion to receive the rotation component\\r\\n * @param {ReadonlyMat4} mat Matrix to be decomposed (input)\\r\\n * @return {quat} out\\r\\n */\\n\\nfunction getRotation(out, mat) {\\n  var scaling = new glMatrix.ARRAY_TYPE(3);\\n  getScaling(scaling, mat);\\n  var is1 = 1 / scaling[0];\\n  var is2 = 1 / scaling[1];\\n  var is3 = 1 / scaling[2];\\n  var sm11 = mat[0] * is1;\\n  var sm12 = mat[1] * is2;\\n  var sm13 = mat[2] * is3;\\n  var sm21 = mat[4] * is1;\\n  var sm22 = mat[5] * is2;\\n  var sm23 = mat[6] * is3;\\n  var sm31 = mat[8] * is1;\\n  var sm32 = mat[9] * is2;\\n  var sm33 = mat[10] * is3;\\n  var trace = sm11 + sm22 + sm33;\\n  var S = 0;\\n\\n  if (trace > 0) {\\n    S = Math.sqrt(trace + 1.0) * 2;\\n    out[3] = 0.25 * S;\\n    out[0] = (sm23 - sm32) / S;\\n    out[1] = (sm31 - sm13) / S;\\n    out[2] = (sm12 - sm21) / S;\\n  } else if (sm11 > sm22 && sm11 > sm33) {\\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\\n    out[3] = (sm23 - sm32) / S;\\n    out[0] = 0.25 * S;\\n    out[1] = (sm12 + sm21) / S;\\n    out[2] = (sm31 + sm13) / S;\\n  } else if (sm22 > sm33) {\\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\\n    out[3] = (sm31 - sm13) / S;\\n    out[0] = (sm12 + sm21) / S;\\n    out[1] = 0.25 * S;\\n    out[2] = (sm23 + sm32) / S;\\n  } else {\\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\\n    out[3] = (sm12 - sm21) / S;\\n    out[0] = (sm31 + sm13) / S;\\n    out[1] = (sm23 + sm32) / S;\\n    out[2] = 0.25 * S;\\n  }\\n\\n  return out;\\n}\\n/**\\r\\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\\r\\n * This is equivalent to (but much faster than):\\r\\n *\\r\\n *     mat4.identity(dest);\\r\\n *     mat4.translate(dest, vec);\\r\\n *     let quatMat = mat4.create();\\r\\n *     quat4.toMat4(quat, quatMat);\\r\\n *     mat4.multiply(dest, quatMat);\\r\\n *     mat4.scale(dest, scale)\\r\\n *\\r\\n * @param {mat4} out mat4 receiving operation result\\r\\n * @param {quat4} q Rotation quaternion\\r\\n * @param {ReadonlyVec3} v Translation vector\\r\\n * @param {ReadonlyVec3} s Scaling vector\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction fromRotationTranslationScale(out, q, v, s) {\\n  // Quaternion math\\n  var x = q[0],\\n      y = q[1],\\n      z = q[2],\\n      w = q[3];\\n  var x2 = x + x;\\n  var y2 = y + y;\\n  var z2 = z + z;\\n  var xx = x * x2;\\n  var xy = x * y2;\\n  var xz = x * z2;\\n  var yy = y * y2;\\n  var yz = y * z2;\\n  var zz = z * z2;\\n  var wx = w * x2;\\n  var wy = w * y2;\\n  var wz = w * z2;\\n  var sx = s[0];\\n  var sy = s[1];\\n  var sz = s[2];\\n  out[0] = (1 - (yy + zz)) * sx;\\n  out[1] = (xy + wz) * sx;\\n  out[2] = (xz - wy) * sx;\\n  out[3] = 0;\\n  out[4] = (xy - wz) * sy;\\n  out[5] = (1 - (xx + zz)) * sy;\\n  out[6] = (yz + wx) * sy;\\n  out[7] = 0;\\n  out[8] = (xz + wy) * sz;\\n  out[9] = (yz - wx) * sz;\\n  out[10] = (1 - (xx + yy)) * sz;\\n  out[11] = 0;\\n  out[12] = v[0];\\n  out[13] = v[1];\\n  out[14] = v[2];\\n  out[15] = 1;\\n  return out;\\n}\\n/**\\r\\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\\r\\n * This is equivalent to (but much faster than):\\r\\n *\\r\\n *     mat4.identity(dest);\\r\\n *     mat4.translate(dest, vec);\\r\\n *     mat4.translate(dest, origin);\\r\\n *     let quatMat = mat4.create();\\r\\n *     quat4.toMat4(quat, quatMat);\\r\\n *     mat4.multiply(dest, quatMat);\\r\\n *     mat4.scale(dest, scale)\\r\\n *     mat4.translate(dest, negativeOrigin);\\r\\n *\\r\\n * @param {mat4} out mat4 receiving operation result\\r\\n * @param {quat4} q Rotation quaternion\\r\\n * @param {ReadonlyVec3} v Translation vector\\r\\n * @param {ReadonlyVec3} s Scaling vector\\r\\n * @param {ReadonlyVec3} o The origin vector around which to scale and rotate\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction fromRotationTranslationScaleOrigin(out, q, v, s, o) {\\n  // Quaternion math\\n  var x = q[0],\\n      y = q[1],\\n      z = q[2],\\n      w = q[3];\\n  var x2 = x + x;\\n  var y2 = y + y;\\n  var z2 = z + z;\\n  var xx = x * x2;\\n  var xy = x * y2;\\n  var xz = x * z2;\\n  var yy = y * y2;\\n  var yz = y * z2;\\n  var zz = z * z2;\\n  var wx = w * x2;\\n  var wy = w * y2;\\n  var wz = w * z2;\\n  var sx = s[0];\\n  var sy = s[1];\\n  var sz = s[2];\\n  var ox = o[0];\\n  var oy = o[1];\\n  var oz = o[2];\\n  var out0 = (1 - (yy + zz)) * sx;\\n  var out1 = (xy + wz) * sx;\\n  var out2 = (xz - wy) * sx;\\n  var out4 = (xy - wz) * sy;\\n  var out5 = (1 - (xx + zz)) * sy;\\n  var out6 = (yz + wx) * sy;\\n  var out8 = (xz + wy) * sz;\\n  var out9 = (yz - wx) * sz;\\n  var out10 = (1 - (xx + yy)) * sz;\\n  out[0] = out0;\\n  out[1] = out1;\\n  out[2] = out2;\\n  out[3] = 0;\\n  out[4] = out4;\\n  out[5] = out5;\\n  out[6] = out6;\\n  out[7] = 0;\\n  out[8] = out8;\\n  out[9] = out9;\\n  out[10] = out10;\\n  out[11] = 0;\\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\\n  out[15] = 1;\\n  return out;\\n}\\n/**\\r\\n * Calculates a 4x4 matrix from the given quaternion\\r\\n *\\r\\n * @param {mat4} out mat4 receiving operation result\\r\\n * @param {ReadonlyQuat} q Quaternion to create matrix from\\r\\n *\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction fromQuat(out, q) {\\n  var x = q[0],\\n      y = q[1],\\n      z = q[2],\\n      w = q[3];\\n  var x2 = x + x;\\n  var y2 = y + y;\\n  var z2 = z + z;\\n  var xx = x * x2;\\n  var yx = y * x2;\\n  var yy = y * y2;\\n  var zx = z * x2;\\n  var zy = z * y2;\\n  var zz = z * z2;\\n  var wx = w * x2;\\n  var wy = w * y2;\\n  var wz = w * z2;\\n  out[0] = 1 - yy - zz;\\n  out[1] = yx + wz;\\n  out[2] = zx - wy;\\n  out[3] = 0;\\n  out[4] = yx - wz;\\n  out[5] = 1 - xx - zz;\\n  out[6] = zy + wx;\\n  out[7] = 0;\\n  out[8] = zx + wy;\\n  out[9] = zy - wx;\\n  out[10] = 1 - xx - yy;\\n  out[11] = 0;\\n  out[12] = 0;\\n  out[13] = 0;\\n  out[14] = 0;\\n  out[15] = 1;\\n  return out;\\n}\\n/**\\r\\n * Generates a frustum matrix with the given bounds\\r\\n *\\r\\n * @param {mat4} out mat4 frustum matrix will be written into\\r\\n * @param {Number} left Left bound of the frustum\\r\\n * @param {Number} right Right bound of the frustum\\r\\n * @param {Number} bottom Bottom bound of the frustum\\r\\n * @param {Number} top Top bound of the frustum\\r\\n * @param {Number} near Near bound of the frustum\\r\\n * @param {Number} far Far bound of the frustum\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction frustum(out, left, right, bottom, top, near, far) {\\n  var rl = 1 / (right - left);\\n  var tb = 1 / (top - bottom);\\n  var nf = 1 / (near - far);\\n  out[0] = near * 2 * rl;\\n  out[1] = 0;\\n  out[2] = 0;\\n  out[3] = 0;\\n  out[4] = 0;\\n  out[5] = near * 2 * tb;\\n  out[6] = 0;\\n  out[7] = 0;\\n  out[8] = (right + left) * rl;\\n  out[9] = (top + bottom) * tb;\\n  out[10] = (far + near) * nf;\\n  out[11] = -1;\\n  out[12] = 0;\\n  out[13] = 0;\\n  out[14] = far * near * 2 * nf;\\n  out[15] = 0;\\n  return out;\\n}\\n/**\\r\\n * Generates a perspective projection matrix with the given bounds.\\r\\n * Passing null/undefined/no value for far will generate infinite projection matrix.\\r\\n *\\r\\n * @param {mat4} out mat4 frustum matrix will be written into\\r\\n * @param {number} fovy Vertical field of view in radians\\r\\n * @param {number} aspect Aspect ratio. typically viewport width/height\\r\\n * @param {number} near Near bound of the frustum\\r\\n * @param {number} far Far bound of the frustum, can be null or Infinity\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction perspective(out, fovy, aspect, near, far) {\\n  var f = 1.0 / Math.tan(fovy / 2),\\n      nf;\\n  out[0] = f / aspect;\\n  out[1] = 0;\\n  out[2] = 0;\\n  out[3] = 0;\\n  out[4] = 0;\\n  out[5] = f;\\n  out[6] = 0;\\n  out[7] = 0;\\n  out[8] = 0;\\n  out[9] = 0;\\n  out[11] = -1;\\n  out[12] = 0;\\n  out[13] = 0;\\n  out[15] = 0;\\n\\n  if (far != null && far !== Infinity) {\\n    nf = 1 / (near - far);\\n    out[10] = (far + near) * nf;\\n    out[14] = 2 * far * near * nf;\\n  } else {\\n    out[10] = -1;\\n    out[14] = -2 * near;\\n  }\\n\\n  return out;\\n}\\n/**\\r\\n * Generates a perspective projection matrix with the given field of view.\\r\\n * This is primarily useful for generating projection matrices to be used\\r\\n * with the still experiemental WebVR API.\\r\\n *\\r\\n * @param {mat4} out mat4 frustum matrix will be written into\\r\\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\\r\\n * @param {number} near Near bound of the frustum\\r\\n * @param {number} far Far bound of the frustum\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction perspectiveFromFieldOfView(out, fov, near, far) {\\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\\n  var xScale = 2.0 / (leftTan + rightTan);\\n  var yScale = 2.0 / (upTan + downTan);\\n  out[0] = xScale;\\n  out[1] = 0.0;\\n  out[2] = 0.0;\\n  out[3] = 0.0;\\n  out[4] = 0.0;\\n  out[5] = yScale;\\n  out[6] = 0.0;\\n  out[7] = 0.0;\\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\\n  out[9] = (upTan - downTan) * yScale * 0.5;\\n  out[10] = far / (near - far);\\n  out[11] = -1.0;\\n  out[12] = 0.0;\\n  out[13] = 0.0;\\n  out[14] = far * near / (near - far);\\n  out[15] = 0.0;\\n  return out;\\n}\\n/**\\r\\n * Generates a orthogonal projection matrix with the given bounds\\r\\n *\\r\\n * @param {mat4} out mat4 frustum matrix will be written into\\r\\n * @param {number} left Left bound of the frustum\\r\\n * @param {number} right Right bound of the frustum\\r\\n * @param {number} bottom Bottom bound of the frustum\\r\\n * @param {number} top Top bound of the frustum\\r\\n * @param {number} near Near bound of the frustum\\r\\n * @param {number} far Far bound of the frustum\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction ortho(out, left, right, bottom, top, near, far) {\\n  var lr = 1 / (left - right);\\n  var bt = 1 / (bottom - top);\\n  var nf = 1 / (near - far);\\n  out[0] = -2 * lr;\\n  out[1] = 0;\\n  out[2] = 0;\\n  out[3] = 0;\\n  out[4] = 0;\\n  out[5] = -2 * bt;\\n  out[6] = 0;\\n  out[7] = 0;\\n  out[8] = 0;\\n  out[9] = 0;\\n  out[10] = 2 * nf;\\n  out[11] = 0;\\n  out[12] = (left + right) * lr;\\n  out[13] = (top + bottom) * bt;\\n  out[14] = (far + near) * nf;\\n  out[15] = 1;\\n  return out;\\n}\\n/**\\r\\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\\r\\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\\r\\n *\\r\\n * @param {mat4} out mat4 frustum matrix will be written into\\r\\n * @param {ReadonlyVec3} eye Position of the viewer\\r\\n * @param {ReadonlyVec3} center Point the viewer is looking at\\r\\n * @param {ReadonlyVec3} up vec3 pointing up\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction lookAt(out, eye, center, up) {\\n  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\\n  var eyex = eye[0];\\n  var eyey = eye[1];\\n  var eyez = eye[2];\\n  var upx = up[0];\\n  var upy = up[1];\\n  var upz = up[2];\\n  var centerx = center[0];\\n  var centery = center[1];\\n  var centerz = center[2];\\n\\n  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {\\n    return identity(out);\\n  }\\n\\n  z0 = eyex - centerx;\\n  z1 = eyey - centery;\\n  z2 = eyez - centerz;\\n  len = 1 / Math.hypot(z0, z1, z2);\\n  z0 *= len;\\n  z1 *= len;\\n  z2 *= len;\\n  x0 = upy * z2 - upz * z1;\\n  x1 = upz * z0 - upx * z2;\\n  x2 = upx * z1 - upy * z0;\\n  len = Math.hypot(x0, x1, x2);\\n\\n  if (!len) {\\n    x0 = 0;\\n    x1 = 0;\\n    x2 = 0;\\n  } else {\\n    len = 1 / len;\\n    x0 *= len;\\n    x1 *= len;\\n    x2 *= len;\\n  }\\n\\n  y0 = z1 * x2 - z2 * x1;\\n  y1 = z2 * x0 - z0 * x2;\\n  y2 = z0 * x1 - z1 * x0;\\n  len = Math.hypot(y0, y1, y2);\\n\\n  if (!len) {\\n    y0 = 0;\\n    y1 = 0;\\n    y2 = 0;\\n  } else {\\n    len = 1 / len;\\n    y0 *= len;\\n    y1 *= len;\\n    y2 *= len;\\n  }\\n\\n  out[0] = x0;\\n  out[1] = y0;\\n  out[2] = z0;\\n  out[3] = 0;\\n  out[4] = x1;\\n  out[5] = y1;\\n  out[6] = z1;\\n  out[7] = 0;\\n  out[8] = x2;\\n  out[9] = y2;\\n  out[10] = z2;\\n  out[11] = 0;\\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\\n  out[15] = 1;\\n  return out;\\n}\\n/**\\r\\n * Generates a matrix that makes something look at something else.\\r\\n *\\r\\n * @param {mat4} out mat4 frustum matrix will be written into\\r\\n * @param {ReadonlyVec3} eye Position of the viewer\\r\\n * @param {ReadonlyVec3} center Point the viewer is looking at\\r\\n * @param {ReadonlyVec3} up vec3 pointing up\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction targetTo(out, eye, target, up) {\\n  var eyex = eye[0],\\n      eyey = eye[1],\\n      eyez = eye[2],\\n      upx = up[0],\\n      upy = up[1],\\n      upz = up[2];\\n  var z0 = eyex - target[0],\\n      z1 = eyey - target[1],\\n      z2 = eyez - target[2];\\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\\n\\n  if (len > 0) {\\n    len = 1 / Math.sqrt(len);\\n    z0 *= len;\\n    z1 *= len;\\n    z2 *= len;\\n  }\\n\\n  var x0 = upy * z2 - upz * z1,\\n      x1 = upz * z0 - upx * z2,\\n      x2 = upx * z1 - upy * z0;\\n  len = x0 * x0 + x1 * x1 + x2 * x2;\\n\\n  if (len > 0) {\\n    len = 1 / Math.sqrt(len);\\n    x0 *= len;\\n    x1 *= len;\\n    x2 *= len;\\n  }\\n\\n  out[0] = x0;\\n  out[1] = x1;\\n  out[2] = x2;\\n  out[3] = 0;\\n  out[4] = z1 * x2 - z2 * x1;\\n  out[5] = z2 * x0 - z0 * x2;\\n  out[6] = z0 * x1 - z1 * x0;\\n  out[7] = 0;\\n  out[8] = z0;\\n  out[9] = z1;\\n  out[10] = z2;\\n  out[11] = 0;\\n  out[12] = eyex;\\n  out[13] = eyey;\\n  out[14] = eyez;\\n  out[15] = 1;\\n  return out;\\n}\\n/**\\r\\n * Returns a string representation of a mat4\\r\\n *\\r\\n * @param {ReadonlyMat4} a matrix to represent as a string\\r\\n * @returns {String} string representation of the matrix\\r\\n */\\n\\nfunction str(a) {\\n  return \"mat4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \", \" + a[9] + \", \" + a[10] + \", \" + a[11] + \", \" + a[12] + \", \" + a[13] + \", \" + a[14] + \", \" + a[15] + \")\";\\n}\\n/**\\r\\n * Returns Frobenius norm of a mat4\\r\\n *\\r\\n * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of\\r\\n * @returns {Number} Frobenius norm\\r\\n */\\n\\nfunction frob(a) {\\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\\n}\\n/**\\r\\n * Adds two mat4\\'s\\r\\n *\\r\\n * @param {mat4} out the receiving matrix\\r\\n * @param {ReadonlyMat4} a the first operand\\r\\n * @param {ReadonlyMat4} b the second operand\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction add(out, a, b) {\\n  out[0] = a[0] + b[0];\\n  out[1] = a[1] + b[1];\\n  out[2] = a[2] + b[2];\\n  out[3] = a[3] + b[3];\\n  out[4] = a[4] + b[4];\\n  out[5] = a[5] + b[5];\\n  out[6] = a[6] + b[6];\\n  out[7] = a[7] + b[7];\\n  out[8] = a[8] + b[8];\\n  out[9] = a[9] + b[9];\\n  out[10] = a[10] + b[10];\\n  out[11] = a[11] + b[11];\\n  out[12] = a[12] + b[12];\\n  out[13] = a[13] + b[13];\\n  out[14] = a[14] + b[14];\\n  out[15] = a[15] + b[15];\\n  return out;\\n}\\n/**\\r\\n * Subtracts matrix b from matrix a\\r\\n *\\r\\n * @param {mat4} out the receiving matrix\\r\\n * @param {ReadonlyMat4} a the first operand\\r\\n * @param {ReadonlyMat4} b the second operand\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction subtract(out, a, b) {\\n  out[0] = a[0] - b[0];\\n  out[1] = a[1] - b[1];\\n  out[2] = a[2] - b[2];\\n  out[3] = a[3] - b[3];\\n  out[4] = a[4] - b[4];\\n  out[5] = a[5] - b[5];\\n  out[6] = a[6] - b[6];\\n  out[7] = a[7] - b[7];\\n  out[8] = a[8] - b[8];\\n  out[9] = a[9] - b[9];\\n  out[10] = a[10] - b[10];\\n  out[11] = a[11] - b[11];\\n  out[12] = a[12] - b[12];\\n  out[13] = a[13] - b[13];\\n  out[14] = a[14] - b[14];\\n  out[15] = a[15] - b[15];\\n  return out;\\n}\\n/**\\r\\n * Multiply each element of the matrix by a scalar.\\r\\n *\\r\\n * @param {mat4} out the receiving matrix\\r\\n * @param {ReadonlyMat4} a the matrix to scale\\r\\n * @param {Number} b amount to scale the matrix\\'s elements by\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction multiplyScalar(out, a, b) {\\n  out[0] = a[0] * b;\\n  out[1] = a[1] * b;\\n  out[2] = a[2] * b;\\n  out[3] = a[3] * b;\\n  out[4] = a[4] * b;\\n  out[5] = a[5] * b;\\n  out[6] = a[6] * b;\\n  out[7] = a[7] * b;\\n  out[8] = a[8] * b;\\n  out[9] = a[9] * b;\\n  out[10] = a[10] * b;\\n  out[11] = a[11] * b;\\n  out[12] = a[12] * b;\\n  out[13] = a[13] * b;\\n  out[14] = a[14] * b;\\n  out[15] = a[15] * b;\\n  return out;\\n}\\n/**\\r\\n * Adds two mat4\\'s after multiplying each element of the second operand by a scalar value.\\r\\n *\\r\\n * @param {mat4} out the receiving vector\\r\\n * @param {ReadonlyMat4} a the first operand\\r\\n * @param {ReadonlyMat4} b the second operand\\r\\n * @param {Number} scale the amount to scale b\\'s elements by before adding\\r\\n * @returns {mat4} out\\r\\n */\\n\\nfunction multiplyScalarAndAdd(out, a, b, scale) {\\n  out[0] = a[0] + b[0] * scale;\\n  out[1] = a[1] + b[1] * scale;\\n  out[2] = a[2] + b[2] * scale;\\n  out[3] = a[3] + b[3] * scale;\\n  out[4] = a[4] + b[4] * scale;\\n  out[5] = a[5] + b[5] * scale;\\n  out[6] = a[6] + b[6] * scale;\\n  out[7] = a[7] + b[7] * scale;\\n  out[8] = a[8] + b[8] * scale;\\n  out[9] = a[9] + b[9] * scale;\\n  out[10] = a[10] + b[10] * scale;\\n  out[11] = a[11] + b[11] * scale;\\n  out[12] = a[12] + b[12] * scale;\\n  out[13] = a[13] + b[13] * scale;\\n  out[14] = a[14] + b[14] * scale;\\n  out[15] = a[15] + b[15] * scale;\\n  return out;\\n}\\n/**\\r\\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\\r\\n *\\r\\n * @param {ReadonlyMat4} a The first matrix.\\r\\n * @param {ReadonlyMat4} b The second matrix.\\r\\n * @returns {Boolean} True if the matrices are equal, false otherwise.\\r\\n */\\n\\nfunction exactEquals(a, b) {\\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\\n}\\n/**\\r\\n * Returns whether or not the matrices have approximately the same elements in the same position.\\r\\n *\\r\\n * @param {ReadonlyMat4} a The first matrix.\\r\\n * @param {ReadonlyMat4} b The second matrix.\\r\\n * @returns {Boolean} True if the matrices are equal, false otherwise.\\r\\n */\\n\\nfunction mat4_equals(a, b) {\\n  var a0 = a[0],\\n      a1 = a[1],\\n      a2 = a[2],\\n      a3 = a[3];\\n  var a4 = a[4],\\n      a5 = a[5],\\n      a6 = a[6],\\n      a7 = a[7];\\n  var a8 = a[8],\\n      a9 = a[9],\\n      a10 = a[10],\\n      a11 = a[11];\\n  var a12 = a[12],\\n      a13 = a[13],\\n      a14 = a[14],\\n      a15 = a[15];\\n  var b0 = b[0],\\n      b1 = b[1],\\n      b2 = b[2],\\n      b3 = b[3];\\n  var b4 = b[4],\\n      b5 = b[5],\\n      b6 = b[6],\\n      b7 = b[7];\\n  var b8 = b[8],\\n      b9 = b[9],\\n      b10 = b[10],\\n      b11 = b[11];\\n  var b12 = b[12],\\n      b13 = b[13],\\n      b14 = b[14],\\n      b15 = b[15];\\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\\n}\\n/**\\r\\n * Alias for {@link mat4.multiply}\\r\\n * @function\\r\\n */\\n\\nvar mul = (/* unused pure expression or super */ null && (multiply));\\n/**\\r\\n * Alias for {@link mat4.subtract}\\r\\n * @function\\r\\n */\\n\\nvar sub = (/* unused pure expression or super */ null && (subtract));\\n;// CONCATENATED MODULE: ./node_modules/roughjs/bin/math.js\\nfunction randomSeed() {\\n    return Math.floor(Math.random() * 2 ** 31);\\n}\\nclass Random {\\n    constructor(seed) {\\n        this.seed = seed;\\n    }\\n    next() {\\n        if (this.seed) {\\n            return ((2 ** 31 - 1) & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31;\\n        }\\n        else {\\n            return Math.random();\\n        }\\n    }\\n}\\n\\n;// CONCATENATED MODULE: ./node_modules/nanoid/index.prod.js\\n// This file replaces `index.js` in bundlers like webpack or Rollup,\\n// according to `browser` config in `package.json`.\\n\\n\\n\\nif (false) {}\\n\\nlet random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\\n\\nlet customRandom = (alphabet, size, getRandom) => {\\n  // First, a bitmask is necessary to generate the ID. The bitmask makes bytes\\n  // values closer to the alphabet size. The bitmask calculates the closest\\n  // `2^31 - 1` number, which exceeds the alphabet size.\\n  // For example, the bitmask for the alphabet size 30 is 31 (00011111).\\n  // `Math.clz32` is not used, because it is not available in browsers.\\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\\n  // Though, the bitmask solution is not perfect since the bytes exceeding\\n  // the alphabet size are refused. Therefore, to reliably generate the ID,\\n  // the random bytes redundancy has to be satisfied.\\n\\n  // Note: every hardware random generator call is performance expensive,\\n  // because the system call for entropy collection takes a lot of time.\\n  // So, to avoid additional system calls, extra bytes are requested in advance.\\n\\n  // Next, a step determines how many random bytes to generate.\\n  // The number of random bytes gets decided upon the ID size, mask,\\n  // alphabet size, and magic number 1.6 (using 1.6 peaks at performance\\n  // according to benchmarks).\\n\\n  // `-~f => Math.ceil(f)` if f is a float\\n  // `-~i => i + 1` if i is an integer\\n  let step = -~((1.6 * mask * size) / alphabet.length)\\n\\n  return () => {\\n    let id = \\'\\'\\n    while (true) {\\n      let bytes = getRandom(step)\\n      // A compact alternative for `for (var i = 0; i < step; i++)`.\\n      let j = step\\n      while (j--) {\\n        // Adding `|| \\'\\'` refuses a random byte that exceeds the alphabet size.\\n        id += alphabet[bytes[j] & mask] || \\'\\'\\n        if (id.length === size) return id\\n      }\\n    }\\n  }\\n}\\n\\nlet customAlphabet = (alphabet, size) => customRandom(alphabet, size, random)\\n\\nlet nanoid = (size = 21) => {\\n  let id = \\'\\'\\n  let bytes = crypto.getRandomValues(new Uint8Array(size))\\n\\n  // A compact alternative for `for (var i = 0; i < step; i++)`.\\n  while (size--) {\\n    // It is incorrect to use bytes exceeding the alphabet size.\\n    // The following mask reduces the random byte in the 0-255 value\\n    // range to the 0-63 value range. Therefore, adding hacks, such\\n    // as empty string fallback or magic numbers, is unneccessary because\\n    // the bitmask trims bytes down to the alphabet size.\\n    let byte = bytes[size] & 63\\n    if (byte < 36) {\\n      // `0-9a-z`\\n      id += byte.toString(36)\\n    } else if (byte < 62) {\\n      // `A-Z`\\n      id += (byte - 26).toString(36).toUpperCase()\\n    } else if (byte < 63) {\\n      id += \\'_\\'\\n    } else {\\n      id += \\'-\\'\\n    }\\n  }\\n  return id\\n}\\n\\n\\n\\n;// CONCATENATED MODULE: ./src/utils.ts\\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\\n\\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\\n\\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\\n\\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\\n\\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\\n\\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\\n\\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\\n\\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\\n\\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\\n\\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\\n\\n\\n\\nvar utils_random = new Random(Date.now());\\nvar randomInteger = function randomInteger() {\\n  return Math.floor(utils_random.next() * Math.pow(2, 31));\\n};\\nvar randomId = function randomId() {\\n  return nanoid();\\n};\\nvar safeNumber = function safeNumber(number) {\\n  return Number(number.toFixed(2));\\n};\\nfunction dimensionsFromPoints(points) {\\n  var xCoords = points.map(function (_ref) {\\n    var _ref2 = _slicedToArray(_ref, 1),\\n        x = _ref2[0];\\n\\n    return x;\\n  });\\n  var yCoords = points.map(function (_ref3) {\\n    var _ref4 = _slicedToArray(_ref3, 2),\\n        y = _ref4[1];\\n\\n    return y;\\n  });\\n  var minX = Math.min.apply(Math, _toConsumableArray(xCoords));\\n  var minY = Math.min.apply(Math, _toConsumableArray(yCoords));\\n  var maxX = Math.max.apply(Math, _toConsumableArray(xCoords));\\n  var maxY = Math.max.apply(Math, _toConsumableArray(yCoords));\\n  return [maxX - minX, maxY - minY];\\n} // winding order is clockwise values is positive, counter clockwise if negative.\\n\\nfunction getWindingOrder(points) {\\n  var total = points.reduce(function (acc, _ref5, idx, arr) {\\n    var _ref6 = _slicedToArray(_ref5, 2),\\n        x1 = _ref6[0],\\n        y1 = _ref6[1];\\n\\n    var p2 = arr[idx + 1];\\n    var x2 = p2 ? p2[0] : 0;\\n    var y2 = p2 ? p2[1] : 0;\\n    var e = (x2 - x1) * (y2 + y1);\\n    return e + acc;\\n  }, 0);\\n  return total > 0 ? \"clockwise\" : \"counterclockwise\";\\n}\\n// EXTERNAL MODULE: ./node_modules/chroma-js/chroma.js\\nvar chroma = __webpack_require__(792);\\nvar chroma_default = /*#__PURE__*/__webpack_require__.n(chroma);\\n;// CONCATENATED MODULE: ./src/attributes.ts\\nfunction attributes_toConsumableArray(arr) { return attributes_arrayWithoutHoles(arr) || attributes_iterableToArray(arr) || attributes_unsupportedIterableToArray(arr) || attributes_nonIterableSpread(); }\\n\\nfunction attributes_nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\\n\\nfunction attributes_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return attributes_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return attributes_arrayLikeToArray(o, minLen); }\\n\\nfunction attributes_iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\\n\\nfunction attributes_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return attributes_arrayLikeToArray(arr); }\\n\\nfunction attributes_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\\n\\n\\nfunction hexWithAlpha(color, alpha) {\\n  return chroma_default()(color).alpha(alpha).css();\\n}\\nfunction has(el, attr) {\\n  return el.hasAttribute(attr);\\n}\\nfunction get(el, attr, backup) {\\n  return el.getAttribute(attr) || backup || \"\";\\n}\\nfunction getNum(el, attr, backup) {\\n  var numVal = Number(get(el, attr));\\n  return numVal === NaN ? backup || 0 : numVal;\\n}\\nvar presAttrs = {\\n  stroke: \"stroke\",\\n  \"stroke-opacity\": \"stroke-opacity\",\\n  \"stroke-width\": \"stroke-width\",\\n  fill: \"fill\",\\n  \"fill-opacity\": \"fill-opacity\",\\n  opacity: \"opacity\"\\n};\\nvar attrHandlers = {\\n  stroke: function stroke(_ref) {\\n    var el = _ref.el,\\n        exVals = _ref.exVals;\\n    var strokeColor = get(el, \"stroke\");\\n    exVals.strokeColor = has(el, \"stroke-opacity\") ? hexWithAlpha(strokeColor, getNum(el, \"stroke-opacity\")) : strokeColor;\\n  },\\n  \"stroke-opacity\": function strokeOpacity(_ref2) {\\n    var el = _ref2.el,\\n        exVals = _ref2.exVals;\\n    exVals.strokeColor = hexWithAlpha(get(el, \"stroke\", \"#000000\"), getNum(el, \"stroke-opacity\"));\\n  },\\n  \"stroke-width\": function strokeWidth(_ref3) {\\n    var el = _ref3.el,\\n        exVals = _ref3.exVals;\\n    exVals.strokeWidth = getNum(el, \"stroke-width\");\\n  },\\n  fill: function fill(_ref4) {\\n    var el = _ref4.el,\\n        exVals = _ref4.exVals;\\n    var fill = get(el, \"fill\");\\n    exVals.backgroundColor = fill === \"none\" ? \"#00000000\" : fill;\\n  },\\n  \"fill-opacity\": function fillOpacity(_ref5) {\\n    var el = _ref5.el,\\n        exVals = _ref5.exVals;\\n    exVals.backgroundColor = hexWithAlpha(get(el, \"fill\", \"#000000\"), getNum(el, \"fill-opacity\"));\\n  },\\n  opacity: function opacity(_ref6) {\\n    var el = _ref6.el,\\n        exVals = _ref6.exVals;\\n    exVals.opacity = getNum(el, \"opacity\", 100);\\n  }\\n}; // Presentation Attributes for SVG Elements:\\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/Presentation\\n\\nfunction presAttrsToElementValues(el) {\\n  var exVals = attributes_toConsumableArray(el.attributes).reduce(function (exVals, attr) {\\n    var name = attr.name;\\n\\n    if (Object.keys(attrHandlers).includes(name)) {\\n      attrHandlers[name]({\\n        el: el,\\n        exVals: exVals\\n      });\\n    }\\n\\n    return exVals;\\n  }, {});\\n\\n  return exVals;\\n}\\nfunction filterAttrsToElementValues(el) {\\n  var filterVals = {};\\n\\n  if (has(el, \"x\")) {\\n    filterVals.x = getNum(el, \"x\");\\n  }\\n\\n  if (has(el, \"y\")) {\\n    filterVals.y = getNum(el, \"y\");\\n  }\\n\\n  if (has(el, \"width\")) {\\n    filterVals.width = getNum(el, \"width\");\\n  }\\n\\n  if (has(el, \"height\")) {\\n    filterVals.height = getNum(el, \"height\");\\n  }\\n\\n  return filterVals;\\n}\\nfunction pointsAttrToPoints(el) {\\n  var points = [];\\n\\n  if (has(el, \"points\")) {\\n    points = get(el, \"points\").split(\" \").map(function (p) {\\n      return p.split(\",\").map(parseFloat);\\n    });\\n  }\\n\\n  return points;\\n}\\n;// CONCATENATED MODULE: ./src/elements/Group.ts\\nfunction Group_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\\n\\nfunction Group_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\\n\\nfunction Group_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Group_ownKeys(Object(source), true).forEach(function (key) { Group_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Group_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\\n\\nfunction Group_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\\n\\n\\n\\nfunction getGroupAttrs(groups) {\\n  return groups.reduce(function (acc, _ref) {\\n    var element = _ref.element;\\n    var elVals = presAttrsToElementValues(element);\\n    return Group_objectSpread(Group_objectSpread({}, acc), elVals);\\n  }, {});\\n}\\n\\nvar Group = function Group(element) {\\n  Group_classCallCheck(this, Group);\\n\\n  Group_defineProperty(this, \"id\", randomId());\\n\\n  Group_defineProperty(this, \"element\", void 0);\\n\\n  this.element = element;\\n};\\n\\n/* harmony default export */ const elements_Group = (Group);\\n;// CONCATENATED MODULE: ./src/elements/ExcalidrawElement.ts\\nfunction ExcalidrawElement_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\\n\\nfunction ExcalidrawElement_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ExcalidrawElement_ownKeys(Object(source), true).forEach(function (key) { ExcalidrawElement_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ExcalidrawElement_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\\n\\nfunction ExcalidrawElement_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\\n\\n\\nfunction createExElement() {\\n  return {\\n    id: randomId(),\\n    x: 0,\\n    y: 0,\\n    strokeColor: \"#000000\",\\n    backgroundColor: \"#000000\",\\n    fillStyle: \"solid\",\\n    strokeWidth: 1,\\n    strokeStyle: \"solid\",\\n    strokeSharpness: \"sharp\",\\n    roughness: 0,\\n    opacity: 100,\\n    width: 0,\\n    height: 0,\\n    angle: 0,\\n    seed: randomInteger(),\\n    version: 0,\\n    versionNonce: 0,\\n    isDeleted: false,\\n    groupIds: [],\\n    boundElementIds: null\\n  };\\n}\\nfunction createExRect() {\\n  return ExcalidrawElement_objectSpread(ExcalidrawElement_objectSpread({}, createExElement()), {}, {\\n    type: \"rectangle\"\\n  });\\n}\\nfunction createExLine() {\\n  return ExcalidrawElement_objectSpread(ExcalidrawElement_objectSpread({}, createExElement()), {}, {\\n    type: \"line\",\\n    points: []\\n  });\\n}\\nfunction createExEllipse() {\\n  return ExcalidrawElement_objectSpread(ExcalidrawElement_objectSpread({}, createExElement()), {}, {\\n    type: \"ellipse\"\\n  });\\n}\\nfunction createExDraw() {\\n  return ExcalidrawElement_objectSpread(ExcalidrawElement_objectSpread({}, createExElement()), {}, {\\n    type: \"draw\",\\n    points: []\\n  });\\n}\\n;// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/vec3.js\\n\\n/**\\r\\n * 3 Dimensional Vector\\r\\n * @module vec3\\r\\n */\\n\\n/**\\r\\n * Creates a new, empty vec3\\r\\n *\\r\\n * @returns {vec3} a new 3D vector\\r\\n */\\n\\nfunction vec3_create() {\\n  var out = new ARRAY_TYPE(3);\\n\\n  if (ARRAY_TYPE != Float32Array) {\\n    out[0] = 0;\\n    out[1] = 0;\\n    out[2] = 0;\\n  }\\n\\n  return out;\\n}\\n/**\\r\\n * Creates a new vec3 initialized with values from an existing vector\\r\\n *\\r\\n * @param {ReadonlyVec3} a vector to clone\\r\\n * @returns {vec3} a new 3D vector\\r\\n */\\n\\nfunction vec3_clone(a) {\\n  var out = new glMatrix.ARRAY_TYPE(3);\\n  out[0] = a[0];\\n  out[1] = a[1];\\n  out[2] = a[2];\\n  return out;\\n}\\n/**\\r\\n * Calculates the length of a vec3\\r\\n *\\r\\n * @param {ReadonlyVec3} a vector to calculate length of\\r\\n * @returns {Number} length of a\\r\\n */\\n\\nfunction vec3_length(a) {\\n  var x = a[0];\\n  var y = a[1];\\n  var z = a[2];\\n  return Math.hypot(x, y, z);\\n}\\n/**\\r\\n * Creates a new vec3 initialized with the given values\\r\\n *\\r\\n * @param {Number} x X component\\r\\n * @param {Number} y Y component\\r\\n * @param {Number} z Z component\\r\\n * @returns {vec3} a new 3D vector\\r\\n */\\n\\nfunction vec3_fromValues(x, y, z) {\\n  var out = new ARRAY_TYPE(3);\\n  out[0] = x;\\n  out[1] = y;\\n  out[2] = z;\\n  return out;\\n}\\n/**\\r\\n * Copy the values from one vec3 to another\\r\\n *\\r\\n * @param {vec3} out the receiving vector\\r\\n * @param {ReadonlyVec3} a the source vector\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction vec3_copy(out, a) {\\n  out[0] = a[0];\\n  out[1] = a[1];\\n  out[2] = a[2];\\n  return out;\\n}\\n/**\\r\\n * Set the components of a vec3 to the given values\\r\\n *\\r\\n * @param {vec3} out the receiving vector\\r\\n * @param {Number} x X component\\r\\n * @param {Number} y Y component\\r\\n * @param {Number} z Z component\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction vec3_set(out, x, y, z) {\\n  out[0] = x;\\n  out[1] = y;\\n  out[2] = z;\\n  return out;\\n}\\n/**\\r\\n * Adds two vec3\\'s\\r\\n *\\r\\n * @param {vec3} out the receiving vector\\r\\n * @param {ReadonlyVec3} a the first operand\\r\\n * @param {ReadonlyVec3} b the second operand\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction vec3_add(out, a, b) {\\n  out[0] = a[0] + b[0];\\n  out[1] = a[1] + b[1];\\n  out[2] = a[2] + b[2];\\n  return out;\\n}\\n/**\\r\\n * Subtracts vector b from vector a\\r\\n *\\r\\n * @param {vec3} out the receiving vector\\r\\n * @param {ReadonlyVec3} a the first operand\\r\\n * @param {ReadonlyVec3} b the second operand\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction vec3_subtract(out, a, b) {\\n  out[0] = a[0] - b[0];\\n  out[1] = a[1] - b[1];\\n  out[2] = a[2] - b[2];\\n  return out;\\n}\\n/**\\r\\n * Multiplies two vec3\\'s\\r\\n *\\r\\n * @param {vec3} out the receiving vector\\r\\n * @param {ReadonlyVec3} a the first operand\\r\\n * @param {ReadonlyVec3} b the second operand\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction vec3_multiply(out, a, b) {\\n  out[0] = a[0] * b[0];\\n  out[1] = a[1] * b[1];\\n  out[2] = a[2] * b[2];\\n  return out;\\n}\\n/**\\r\\n * Divides two vec3\\'s\\r\\n *\\r\\n * @param {vec3} out the receiving vector\\r\\n * @param {ReadonlyVec3} a the first operand\\r\\n * @param {ReadonlyVec3} b the second operand\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction divide(out, a, b) {\\n  out[0] = a[0] / b[0];\\n  out[1] = a[1] / b[1];\\n  out[2] = a[2] / b[2];\\n  return out;\\n}\\n/**\\r\\n * Math.ceil the components of a vec3\\r\\n *\\r\\n * @param {vec3} out the receiving vector\\r\\n * @param {ReadonlyVec3} a vector to ceil\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction ceil(out, a) {\\n  out[0] = Math.ceil(a[0]);\\n  out[1] = Math.ceil(a[1]);\\n  out[2] = Math.ceil(a[2]);\\n  return out;\\n}\\n/**\\r\\n * Math.floor the components of a vec3\\r\\n *\\r\\n * @param {vec3} out the receiving vector\\r\\n * @param {ReadonlyVec3} a vector to floor\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction floor(out, a) {\\n  out[0] = Math.floor(a[0]);\\n  out[1] = Math.floor(a[1]);\\n  out[2] = Math.floor(a[2]);\\n  return out;\\n}\\n/**\\r\\n * Returns the minimum of two vec3\\'s\\r\\n *\\r\\n * @param {vec3} out the receiving vector\\r\\n * @param {ReadonlyVec3} a the first operand\\r\\n * @param {ReadonlyVec3} b the second operand\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction min(out, a, b) {\\n  out[0] = Math.min(a[0], b[0]);\\n  out[1] = Math.min(a[1], b[1]);\\n  out[2] = Math.min(a[2], b[2]);\\n  return out;\\n}\\n/**\\r\\n * Returns the maximum of two vec3\\'s\\r\\n *\\r\\n * @param {vec3} out the receiving vector\\r\\n * @param {ReadonlyVec3} a the first operand\\r\\n * @param {ReadonlyVec3} b the second operand\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction max(out, a, b) {\\n  out[0] = Math.max(a[0], b[0]);\\n  out[1] = Math.max(a[1], b[1]);\\n  out[2] = Math.max(a[2], b[2]);\\n  return out;\\n}\\n/**\\r\\n * Math.round the components of a vec3\\r\\n *\\r\\n * @param {vec3} out the receiving vector\\r\\n * @param {ReadonlyVec3} a vector to round\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction round(out, a) {\\n  out[0] = Math.round(a[0]);\\n  out[1] = Math.round(a[1]);\\n  out[2] = Math.round(a[2]);\\n  return out;\\n}\\n/**\\r\\n * Scales a vec3 by a scalar number\\r\\n *\\r\\n * @param {vec3} out the receiving vector\\r\\n * @param {ReadonlyVec3} a the vector to scale\\r\\n * @param {Number} b amount to scale the vector by\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction vec3_scale(out, a, b) {\\n  out[0] = a[0] * b;\\n  out[1] = a[1] * b;\\n  out[2] = a[2] * b;\\n  return out;\\n}\\n/**\\r\\n * Adds two vec3\\'s after scaling the second operand by a scalar value\\r\\n *\\r\\n * @param {vec3} out the receiving vector\\r\\n * @param {ReadonlyVec3} a the first operand\\r\\n * @param {ReadonlyVec3} b the second operand\\r\\n * @param {Number} scale the amount to scale b by before adding\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction scaleAndAdd(out, a, b, scale) {\\n  out[0] = a[0] + b[0] * scale;\\n  out[1] = a[1] + b[1] * scale;\\n  out[2] = a[2] + b[2] * scale;\\n  return out;\\n}\\n/**\\r\\n * Calculates the euclidian distance between two vec3\\'s\\r\\n *\\r\\n * @param {ReadonlyVec3} a the first operand\\r\\n * @param {ReadonlyVec3} b the second operand\\r\\n * @returns {Number} distance between a and b\\r\\n */\\n\\nfunction distance(a, b) {\\n  var x = b[0] - a[0];\\n  var y = b[1] - a[1];\\n  var z = b[2] - a[2];\\n  return Math.hypot(x, y, z);\\n}\\n/**\\r\\n * Calculates the squared euclidian distance between two vec3\\'s\\r\\n *\\r\\n * @param {ReadonlyVec3} a the first operand\\r\\n * @param {ReadonlyVec3} b the second operand\\r\\n * @returns {Number} squared distance between a and b\\r\\n */\\n\\nfunction squaredDistance(a, b) {\\n  var x = b[0] - a[0];\\n  var y = b[1] - a[1];\\n  var z = b[2] - a[2];\\n  return x * x + y * y + z * z;\\n}\\n/**\\r\\n * Calculates the squared length of a vec3\\r\\n *\\r\\n * @param {ReadonlyVec3} a vector to calculate squared length of\\r\\n * @returns {Number} squared length of a\\r\\n */\\n\\nfunction squaredLength(a) {\\n  var x = a[0];\\n  var y = a[1];\\n  var z = a[2];\\n  return x * x + y * y + z * z;\\n}\\n/**\\r\\n * Negates the components of a vec3\\r\\n *\\r\\n * @param {vec3} out the receiving vector\\r\\n * @param {ReadonlyVec3} a vector to negate\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction negate(out, a) {\\n  out[0] = -a[0];\\n  out[1] = -a[1];\\n  out[2] = -a[2];\\n  return out;\\n}\\n/**\\r\\n * Returns the inverse of the components of a vec3\\r\\n *\\r\\n * @param {vec3} out the receiving vector\\r\\n * @param {ReadonlyVec3} a vector to invert\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction inverse(out, a) {\\n  out[0] = 1.0 / a[0];\\n  out[1] = 1.0 / a[1];\\n  out[2] = 1.0 / a[2];\\n  return out;\\n}\\n/**\\r\\n * Normalize a vec3\\r\\n *\\r\\n * @param {vec3} out the receiving vector\\r\\n * @param {ReadonlyVec3} a vector to normalize\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction normalize(out, a) {\\n  var x = a[0];\\n  var y = a[1];\\n  var z = a[2];\\n  var len = x * x + y * y + z * z;\\n\\n  if (len > 0) {\\n    //TODO: evaluate use of glm_invsqrt here?\\n    len = 1 / Math.sqrt(len);\\n  }\\n\\n  out[0] = a[0] * len;\\n  out[1] = a[1] * len;\\n  out[2] = a[2] * len;\\n  return out;\\n}\\n/**\\r\\n * Calculates the dot product of two vec3\\'s\\r\\n *\\r\\n * @param {ReadonlyVec3} a the first operand\\r\\n * @param {ReadonlyVec3} b the second operand\\r\\n * @returns {Number} dot product of a and b\\r\\n */\\n\\nfunction dot(a, b) {\\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\\n}\\n/**\\r\\n * Computes the cross product of two vec3\\'s\\r\\n *\\r\\n * @param {vec3} out the receiving vector\\r\\n * @param {ReadonlyVec3} a the first operand\\r\\n * @param {ReadonlyVec3} b the second operand\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction cross(out, a, b) {\\n  var ax = a[0],\\n      ay = a[1],\\n      az = a[2];\\n  var bx = b[0],\\n      by = b[1],\\n      bz = b[2];\\n  out[0] = ay * bz - az * by;\\n  out[1] = az * bx - ax * bz;\\n  out[2] = ax * by - ay * bx;\\n  return out;\\n}\\n/**\\r\\n * Performs a linear interpolation between two vec3\\'s\\r\\n *\\r\\n * @param {vec3} out the receiving vector\\r\\n * @param {ReadonlyVec3} a the first operand\\r\\n * @param {ReadonlyVec3} b the second operand\\r\\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction lerp(out, a, b, t) {\\n  var ax = a[0];\\n  var ay = a[1];\\n  var az = a[2];\\n  out[0] = ax + t * (b[0] - ax);\\n  out[1] = ay + t * (b[1] - ay);\\n  out[2] = az + t * (b[2] - az);\\n  return out;\\n}\\n/**\\r\\n * Performs a hermite interpolation with two control points\\r\\n *\\r\\n * @param {vec3} out the receiving vector\\r\\n * @param {ReadonlyVec3} a the first operand\\r\\n * @param {ReadonlyVec3} b the second operand\\r\\n * @param {ReadonlyVec3} c the third operand\\r\\n * @param {ReadonlyVec3} d the fourth operand\\r\\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction hermite(out, a, b, c, d, t) {\\n  var factorTimes2 = t * t;\\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\\n  var factor2 = factorTimes2 * (t - 2) + t;\\n  var factor3 = factorTimes2 * (t - 1);\\n  var factor4 = factorTimes2 * (3 - 2 * t);\\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\\n  return out;\\n}\\n/**\\r\\n * Performs a bezier interpolation with two control points\\r\\n *\\r\\n * @param {vec3} out the receiving vector\\r\\n * @param {ReadonlyVec3} a the first operand\\r\\n * @param {ReadonlyVec3} b the second operand\\r\\n * @param {ReadonlyVec3} c the third operand\\r\\n * @param {ReadonlyVec3} d the fourth operand\\r\\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction bezier(out, a, b, c, d, t) {\\n  var inverseFactor = 1 - t;\\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\\n  var factorTimes2 = t * t;\\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\\n  var factor2 = 3 * t * inverseFactorTimesTwo;\\n  var factor3 = 3 * factorTimes2 * inverseFactor;\\n  var factor4 = factorTimes2 * t;\\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\\n  return out;\\n}\\n/**\\r\\n * Generates a random vector with the given scale\\r\\n *\\r\\n * @param {vec3} out the receiving vector\\r\\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction vec3_random(out, scale) {\\n  scale = scale || 1.0;\\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\\n  out[0] = Math.cos(r) * zScale;\\n  out[1] = Math.sin(r) * zScale;\\n  out[2] = z * scale;\\n  return out;\\n}\\n/**\\r\\n * Transforms the vec3 with a mat4.\\r\\n * 4th vector component is implicitly \\'1\\'\\r\\n *\\r\\n * @param {vec3} out the receiving vector\\r\\n * @param {ReadonlyVec3} a the vector to transform\\r\\n * @param {ReadonlyMat4} m matrix to transform with\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction transformMat4(out, a, m) {\\n  var x = a[0],\\n      y = a[1],\\n      z = a[2];\\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\\n  w = w || 1.0;\\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\\n  return out;\\n}\\n/**\\r\\n * Transforms the vec3 with a mat3.\\r\\n *\\r\\n * @param {vec3} out the receiving vector\\r\\n * @param {ReadonlyVec3} a the vector to transform\\r\\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction transformMat3(out, a, m) {\\n  var x = a[0],\\n      y = a[1],\\n      z = a[2];\\n  out[0] = x * m[0] + y * m[3] + z * m[6];\\n  out[1] = x * m[1] + y * m[4] + z * m[7];\\n  out[2] = x * m[2] + y * m[5] + z * m[8];\\n  return out;\\n}\\n/**\\r\\n * Transforms the vec3 with a quat\\r\\n * Can also be used for dual quaternions. (Multiply it with the real part)\\r\\n *\\r\\n * @param {vec3} out the receiving vector\\r\\n * @param {ReadonlyVec3} a the vector to transform\\r\\n * @param {ReadonlyQuat} q quaternion to transform with\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction transformQuat(out, a, q) {\\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\\n  var qx = q[0],\\n      qy = q[1],\\n      qz = q[2],\\n      qw = q[3];\\n  var x = a[0],\\n      y = a[1],\\n      z = a[2]; // var qvec = [qx, qy, qz];\\n  // var uv = vec3.cross([], qvec, a);\\n\\n  var uvx = qy * z - qz * y,\\n      uvy = qz * x - qx * z,\\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\\n\\n  var uuvx = qy * uvz - qz * uvy,\\n      uuvy = qz * uvx - qx * uvz,\\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\\n\\n  var w2 = qw * 2;\\n  uvx *= w2;\\n  uvy *= w2;\\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\\n\\n  uuvx *= 2;\\n  uuvy *= 2;\\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\\n\\n  out[0] = x + uvx + uuvx;\\n  out[1] = y + uvy + uuvy;\\n  out[2] = z + uvz + uuvz;\\n  return out;\\n}\\n/**\\r\\n * Rotate a 3D vector around the x-axis\\r\\n * @param {vec3} out The receiving vec3\\r\\n * @param {ReadonlyVec3} a The vec3 point to rotate\\r\\n * @param {ReadonlyVec3} b The origin of the rotation\\r\\n * @param {Number} rad The angle of rotation in radians\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction vec3_rotateX(out, a, b, rad) {\\n  var p = [],\\n      r = []; //Translate point to the origin\\n\\n  p[0] = a[0] - b[0];\\n  p[1] = a[1] - b[1];\\n  p[2] = a[2] - b[2]; //perform rotation\\n\\n  r[0] = p[0];\\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\\n\\n  out[0] = r[0] + b[0];\\n  out[1] = r[1] + b[1];\\n  out[2] = r[2] + b[2];\\n  return out;\\n}\\n/**\\r\\n * Rotate a 3D vector around the y-axis\\r\\n * @param {vec3} out The receiving vec3\\r\\n * @param {ReadonlyVec3} a The vec3 point to rotate\\r\\n * @param {ReadonlyVec3} b The origin of the rotation\\r\\n * @param {Number} rad The angle of rotation in radians\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction vec3_rotateY(out, a, b, rad) {\\n  var p = [],\\n      r = []; //Translate point to the origin\\n\\n  p[0] = a[0] - b[0];\\n  p[1] = a[1] - b[1];\\n  p[2] = a[2] - b[2]; //perform rotation\\n\\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\\n  r[1] = p[1];\\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\\n\\n  out[0] = r[0] + b[0];\\n  out[1] = r[1] + b[1];\\n  out[2] = r[2] + b[2];\\n  return out;\\n}\\n/**\\r\\n * Rotate a 3D vector around the z-axis\\r\\n * @param {vec3} out The receiving vec3\\r\\n * @param {ReadonlyVec3} a The vec3 point to rotate\\r\\n * @param {ReadonlyVec3} b The origin of the rotation\\r\\n * @param {Number} rad The angle of rotation in radians\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction vec3_rotateZ(out, a, b, rad) {\\n  var p = [],\\n      r = []; //Translate point to the origin\\n\\n  p[0] = a[0] - b[0];\\n  p[1] = a[1] - b[1];\\n  p[2] = a[2] - b[2]; //perform rotation\\n\\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\\n  r[2] = p[2]; //translate to correct position\\n\\n  out[0] = r[0] + b[0];\\n  out[1] = r[1] + b[1];\\n  out[2] = r[2] + b[2];\\n  return out;\\n}\\n/**\\r\\n * Get the angle between two 3D vectors\\r\\n * @param {ReadonlyVec3} a The first operand\\r\\n * @param {ReadonlyVec3} b The second operand\\r\\n * @returns {Number} The angle in radians\\r\\n */\\n\\nfunction angle(a, b) {\\n  var ax = a[0],\\n      ay = a[1],\\n      az = a[2],\\n      bx = b[0],\\n      by = b[1],\\n      bz = b[2],\\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\\n      mag = mag1 * mag2,\\n      cosine = mag && dot(a, b) / mag;\\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\\n}\\n/**\\r\\n * Set the components of a vec3 to zero\\r\\n *\\r\\n * @param {vec3} out the receiving vector\\r\\n * @returns {vec3} out\\r\\n */\\n\\nfunction zero(out) {\\n  out[0] = 0.0;\\n  out[1] = 0.0;\\n  out[2] = 0.0;\\n  return out;\\n}\\n/**\\r\\n * Returns a string representation of a vector\\r\\n *\\r\\n * @param {ReadonlyVec3} a vector to represent as a string\\r\\n * @returns {String} string representation of the vector\\r\\n */\\n\\nfunction vec3_str(a) {\\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\\n}\\n/**\\r\\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\\r\\n *\\r\\n * @param {ReadonlyVec3} a The first vector.\\r\\n * @param {ReadonlyVec3} b The second vector.\\r\\n * @returns {Boolean} True if the vectors are equal, false otherwise.\\r\\n */\\n\\nfunction vec3_exactEquals(a, b) {\\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\\n}\\n/**\\r\\n * Returns whether or not the vectors have approximately the same elements in the same position.\\r\\n *\\r\\n * @param {ReadonlyVec3} a The first vector.\\r\\n * @param {ReadonlyVec3} b The second vector.\\r\\n * @returns {Boolean} True if the vectors are equal, false otherwise.\\r\\n */\\n\\nfunction vec3_equals(a, b) {\\n  var a0 = a[0],\\n      a1 = a[1],\\n      a2 = a[2];\\n  var b0 = b[0],\\n      b1 = b[1],\\n      b2 = b[2];\\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\\n}\\n/**\\r\\n * Alias for {@link vec3.subtract}\\r\\n * @function\\r\\n */\\n\\nvar vec3_sub = (/* unused pure expression or super */ null && (vec3_subtract));\\n/**\\r\\n * Alias for {@link vec3.multiply}\\r\\n * @function\\r\\n */\\n\\nvar vec3_mul = (/* unused pure expression or super */ null && (vec3_multiply));\\n/**\\r\\n * Alias for {@link vec3.divide}\\r\\n * @function\\r\\n */\\n\\nvar div = (/* unused pure expression or super */ null && (divide));\\n/**\\r\\n * Alias for {@link vec3.distance}\\r\\n * @function\\r\\n */\\n\\nvar dist = (/* unused pure expression or super */ null && (distance));\\n/**\\r\\n * Alias for {@link vec3.squaredDistance}\\r\\n * @function\\r\\n */\\n\\nvar sqrDist = (/* unused pure expression or super */ null && (squaredDistance));\\n/**\\r\\n * Alias for {@link vec3.length}\\r\\n * @function\\r\\n */\\n\\nvar len = (/* unused pure expression or super */ null && (vec3_length));\\n/**\\r\\n * Alias for {@link vec3.squaredLength}\\r\\n * @function\\r\\n */\\n\\nvar sqrLen = (/* unused pure expression or super */ null && (squaredLength));\\n/**\\r\\n * Perform some operation over an array of vec3s.\\r\\n *\\r\\n * @param {Array} a the array of vectors to iterate over\\r\\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\\r\\n * @param {Number} offset Number of elements to skip at the beginning of the array\\r\\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\\r\\n * @param {Function} fn Function to call for each vector in the array\\r\\n * @param {Object} [arg] additional argument to pass to fn\\r\\n * @returns {Array} a\\r\\n * @function\\r\\n */\\n\\nvar forEach = function () {\\n  var vec = vec3_create();\\n  return function (a, stride, offset, count, fn, arg) {\\n    var i, l;\\n\\n    if (!stride) {\\n      stride = 3;\\n    }\\n\\n    if (!offset) {\\n      offset = 0;\\n    }\\n\\n    if (count) {\\n      l = Math.min(count * stride + offset, a.length);\\n    } else {\\n      l = a.length;\\n    }\\n\\n    for (i = offset; i < l; i += stride) {\\n      vec[0] = a[i];\\n      vec[1] = a[i + 1];\\n      vec[2] = a[i + 2];\\n      fn(vec, vec, arg);\\n      a[i] = vec[0];\\n      a[i + 1] = vec[1];\\n      a[i + 2] = vec[2];\\n    }\\n\\n    return a;\\n  };\\n}();\\n;// CONCATENATED MODULE: ./src/transform.ts\\nfunction transform_slicedToArray(arr, i) { return transform_arrayWithHoles(arr) || transform_iterableToArrayLimit(arr, i) || transform_unsupportedIterableToArray(arr, i) || transform_nonIterableRest(); }\\n\\nfunction transform_nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\\n\\nfunction transform_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return transform_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return transform_arrayLikeToArray(o, minLen); }\\n\\nfunction transform_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\\n\\nfunction transform_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\\n\\nfunction transform_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\\n\\n\\n/*\\nSVG transform attr is a bit strange in that it can accept traditional\\ncss transform string (at least per spec) as well as a it\\'s own \"unitless\"\\nversion of transform functions.\\n\\nhttps://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform\\n*/\\n\\nvar transformFunctions = {\\n  matrix: \"matrix\",\\n  matrix3d: \"matrix3d\",\\n  perspective: \"perspective\",\\n  rotate: \"rotate\",\\n  rotate3d: \"rotate3d\",\\n  rotateX: \"rotateX\",\\n  rotateY: \"rotateY\",\\n  rotateZ: \"rotateZ\",\\n  scale: \"scale\",\\n  scale3d: \"scale3d\",\\n  scaleX: \"scaleX\",\\n  scaleY: \"scaleY\",\\n  scaleZ: \"scaleZ\",\\n  skew: \"skew\",\\n  skewX: \"skewX\",\\n  skewY: \"skewY\",\\n  translate: \"translate\",\\n  translate3d: \"translate3d\",\\n  translateX: \"translateX\",\\n  translateY: \"translateY\",\\n  translateZ: \"translateZ\"\\n};\\nvar transformFunctionsArr = Object.keys(transformFunctions); // type Transform\\n\\nvar defaultUnits = {\\n  matrix: \"\",\\n  matrix3d: \"\",\\n  perspective: \"perspective\",\\n  rotate: \"deg\",\\n  rotate3d: \"deg\",\\n  rotateX: \"deg\",\\n  rotateY: \"deg\",\\n  rotateZ: \"deg\",\\n  scale: \"\",\\n  scale3d: \"\",\\n  scaleX: \"\",\\n  scaleY: \"\",\\n  scaleZ: \"\",\\n  skew: \"skew\",\\n  skewX: \"deg\",\\n  skewY: \"deg\",\\n  translate: \"px\",\\n  translate3d: \"px\",\\n  translateX: \"px\",\\n  translateY: \"px\",\\n  translateZ: \"px\"\\n}; // Convert between possible svg transform attribute values to css transform attribute values.\\n\\nvar svgTransformToCSSTransform = function svgTransformToCSSTransform(svgTransformStr) {\\n  // Create transform function string \"chunks\", e.g \"rotate(90deg)\"\\n  var tFuncs = svgTransformStr.match(/(\\\\w+)\\\\(([^)]*)\\\\)/g);\\n\\n  if (!tFuncs) {\\n    return \"\";\\n  }\\n\\n  var tFuncValues = tFuncs.map(function (tFuncStr) {\\n    var _values;\\n\\n    var type = tFuncStr.split(\"(\")[0];\\n\\n    if (!type) {\\n      throw new Error(\"Unable to find transform name\");\\n    }\\n\\n    if (!transformFunctionsArr.includes(type)) {\\n      throw new Error(\"transform function name \\\\\"\".concat(type, \"\\\\\" is not valid\"));\\n    } // get the arg/props of the transform function, e.g \"90deg\".\\n\\n\\n    var tFuncParts = tFuncStr.match(/([-+]?[0-9]*\\\\.?[0-9]+)([a-z])*/g);\\n\\n    if (!tFuncParts) {\\n      return {\\n        type: type,\\n        values: []\\n      };\\n    }\\n\\n    var values = tFuncParts.map(function (a) {\\n      // Separate the arg value and unit. e.g [\"90\", \"deg\"]\\n      var _a$matchAll = a.matchAll(/([-+]?[0-9]*\\\\.?[0-9]+)|([a-z])*/g),\\n          _a$matchAll2 = transform_slicedToArray(_a$matchAll, 2),\\n          value = _a$matchAll2[0],\\n          unit = _a$matchAll2[1];\\n\\n      return {\\n        unit: unit[0] || defaultUnits[type],\\n        value: value[0]\\n      };\\n    }); // Not supporting x, y args of svg rotate transform yet...\\n\\n    if (values && type === \"rotate\" && ((_values = values) === null || _values === void 0 ? void 0 : _values.length) > 1) {\\n      values = [values[0]];\\n    }\\n\\n    return {\\n      type: type,\\n      values: values\\n    };\\n  }); // Generate a string of transform functions that can be set as a CSS Transform.\\n\\n  var csstransformStr = tFuncValues.map(function (_ref) {\\n    var type = _ref.type,\\n        values = _ref.values;\\n    var valStr = values.map(function (_ref2) {\\n      var unit = _ref2.unit,\\n          value = _ref2.value;\\n      return \"\".concat(value).concat(unit);\\n    }).join(\", \");\\n    return \"\".concat(type, \"(\").concat(valStr, \")\");\\n  }).join(\" \");\\n  return csstransformStr;\\n};\\n\\nvar createDOMMatrixFromSVGStr = function createDOMMatrixFromSVGStr(svgTransformStr) {\\n  var cssTransformStr = svgTransformToCSSTransform(svgTransformStr);\\n  return new DOMMatrix(cssTransformStr);\\n};\\nfunction getElementMatrix(el) {\\n  if (el.hasAttribute(\"transform\")) {\\n    var elMat = new DOMMatrix(svgTransformToCSSTransform(el.getAttribute(\"transform\") || \"\"));\\n    return multiply(create(), create(), elMat.toFloat32Array());\\n  }\\n\\n  return create();\\n}\\nfunction getTransformMatrix(el, groups) {\\n  var accumMat = groups.map(function (_ref3) {\\n    var element = _ref3.element;\\n    return getElementMatrix(element);\\n  }).concat([getElementMatrix(el)]).reduce(function (acc, mat) {\\n    return multiply(acc, acc, mat);\\n  }, create());\\n  return accumMat;\\n}\\nfunction transformPoints(points, transform) {\\n  return points.map(function (_ref4) {\\n    var _ref5 = transform_slicedToArray(_ref4, 2),\\n        x = _ref5[0],\\n        y = _ref5[1];\\n\\n    var _vec3$transformMat = transformMat4(vec3_create(), vec3_fromValues(x, y, 1), transform),\\n        _vec3$transformMat2 = transform_slicedToArray(_vec3$transformMat, 2),\\n        newX = _vec3$transformMat2[0],\\n        newY = _vec3$transformMat2[1];\\n\\n    return [newX, newY];\\n  });\\n}\\n;// CONCATENATED MODULE: ./node_modules/points-on-curve/lib/index.js\\n// distance between 2 points\\nfunction lib_distance(p1, p2) {\\n    return Math.sqrt(distanceSq(p1, p2));\\n}\\n// distance between 2 points squared\\nfunction distanceSq(p1, p2) {\\n    return Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2);\\n}\\n// Sistance squared from a point p to the line segment vw\\nfunction distanceToSegmentSq(p, v, w) {\\n    const l2 = distanceSq(v, w);\\n    if (l2 === 0) {\\n        return distanceSq(p, v);\\n    }\\n    let t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\\n    t = Math.max(0, Math.min(1, t));\\n    return distanceSq(p, lib_lerp(v, w, t));\\n}\\nfunction lib_lerp(a, b, t) {\\n    return [\\n        a[0] + (b[0] - a[0]) * t,\\n        a[1] + (b[1] - a[1]) * t,\\n    ];\\n}\\n// Adapted from https://seant23.wordpress.com/2010/11/12/offset-bezier-curves/\\nfunction flatness(points, offset) {\\n    const p1 = points[offset + 0];\\n    const p2 = points[offset + 1];\\n    const p3 = points[offset + 2];\\n    const p4 = points[offset + 3];\\n    let ux = 3 * p2[0] - 2 * p1[0] - p4[0];\\n    ux *= ux;\\n    let uy = 3 * p2[1] - 2 * p1[1] - p4[1];\\n    uy *= uy;\\n    let vx = 3 * p3[0] - 2 * p4[0] - p1[0];\\n    vx *= vx;\\n    let vy = 3 * p3[1] - 2 * p4[1] - p1[1];\\n    vy *= vy;\\n    if (ux < vx) {\\n        ux = vx;\\n    }\\n    if (uy < vy) {\\n        uy = vy;\\n    }\\n    return ux + uy;\\n}\\nfunction getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints) {\\n    const outPoints = newPoints || [];\\n    if (flatness(points, offset) < tolerance) {\\n        const p0 = points[offset + 0];\\n        if (outPoints.length) {\\n            const d = lib_distance(outPoints[outPoints.length - 1], p0);\\n            if (d > 1) {\\n                outPoints.push(p0);\\n            }\\n        }\\n        else {\\n            outPoints.push(p0);\\n        }\\n        outPoints.push(points[offset + 3]);\\n    }\\n    else {\\n        // subdivide\\n        const t = .5;\\n        const p1 = points[offset + 0];\\n        const p2 = points[offset + 1];\\n        const p3 = points[offset + 2];\\n        const p4 = points[offset + 3];\\n        const q1 = lib_lerp(p1, p2, t);\\n        const q2 = lib_lerp(p2, p3, t);\\n        const q3 = lib_lerp(p3, p4, t);\\n        const r1 = lib_lerp(q1, q2, t);\\n        const r2 = lib_lerp(q2, q3, t);\\n        const red = lib_lerp(r1, r2, t);\\n        getPointsOnBezierCurveWithSplitting([p1, q1, r1, red], 0, tolerance, outPoints);\\n        getPointsOnBezierCurveWithSplitting([red, r2, q3, p4], 0, tolerance, outPoints);\\n    }\\n    return outPoints;\\n}\\nfunction simplify(points, distance) {\\n    return simplifyPoints(points, 0, points.length, distance);\\n}\\n// Ramer–Douglas–Peucker algorithm\\n// https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm\\nfunction simplifyPoints(points, start, end, epsilon, newPoints) {\\n    const outPoints = newPoints || [];\\n    // find the most distance point from the endpoints\\n    const s = points[start];\\n    const e = points[end - 1];\\n    let maxDistSq = 0;\\n    let maxNdx = 1;\\n    for (let i = start + 1; i < end - 1; ++i) {\\n        const distSq = distanceToSegmentSq(points[i], s, e);\\n        if (distSq > maxDistSq) {\\n            maxDistSq = distSq;\\n            maxNdx = i;\\n        }\\n    }\\n    // if that point is too far, split\\n    if (Math.sqrt(maxDistSq) > epsilon) {\\n        simplifyPoints(points, start, maxNdx + 1, epsilon, outPoints);\\n        simplifyPoints(points, maxNdx, end, epsilon, outPoints);\\n    }\\n    else {\\n        if (!outPoints.length) {\\n            outPoints.push(s);\\n        }\\n        outPoints.push(e);\\n    }\\n    return outPoints;\\n}\\nfunction pointsOnBezierCurves(points, tolerance = 0.15, distance) {\\n    const newPoints = [];\\n    const numSegments = (points.length - 1) / 3;\\n    for (let i = 0; i < numSegments; i++) {\\n        const offset = i * 3;\\n        getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints);\\n    }\\n    if (distance && distance > 0) {\\n        return simplifyPoints(newPoints, 0, newPoints.length, distance);\\n    }\\n    return newPoints;\\n}\\n\\n;// CONCATENATED MODULE: ./node_modules/path-data-parser/lib/parser.js\\nconst COMMAND = 0;\\nconst NUMBER = 1;\\nconst EOD = 2;\\nconst PARAMS = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 };\\nfunction tokenize(d) {\\n    const tokens = new Array();\\n    while (d !== \\'\\') {\\n        if (d.match(/^([ \\\\t\\\\r\\\\n,]+)/)) {\\n            d = d.substr(RegExp.$1.length);\\n        }\\n        else if (d.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {\\n            tokens[tokens.length] = { type: COMMAND, text: RegExp.$1 };\\n            d = d.substr(RegExp.$1.length);\\n        }\\n        else if (d.match(/^(([-+]?[0-9]+(\\\\.[0-9]*)?|[-+]?\\\\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {\\n            tokens[tokens.length] = { type: NUMBER, text: `${parseFloat(RegExp.$1)}` };\\n            d = d.substr(RegExp.$1.length);\\n        }\\n        else {\\n            return [];\\n        }\\n    }\\n    tokens[tokens.length] = { type: EOD, text: \\'\\' };\\n    return tokens;\\n}\\nfunction isType(token, type) {\\n    return token.type === type;\\n}\\nfunction parsePath(d) {\\n    const segments = [];\\n    const tokens = tokenize(d);\\n    let mode = \\'BOD\\';\\n    let index = 0;\\n    let token = tokens[index];\\n    while (!isType(token, EOD)) {\\n        let paramsCount = 0;\\n        const params = [];\\n        if (mode === \\'BOD\\') {\\n            if (token.text === \\'M\\' || token.text === \\'m\\') {\\n                index++;\\n                paramsCount = PARAMS[token.text];\\n                mode = token.text;\\n            }\\n            else {\\n                return parsePath(\\'M0,0\\' + d);\\n            }\\n        }\\n        else if (isType(token, NUMBER)) {\\n            paramsCount = PARAMS[mode];\\n        }\\n        else {\\n            index++;\\n            paramsCount = PARAMS[token.text];\\n            mode = token.text;\\n        }\\n        if ((index + paramsCount) < tokens.length) {\\n            for (let i = index; i < index + paramsCount; i++) {\\n                const numbeToken = tokens[i];\\n                if (isType(numbeToken, NUMBER)) {\\n                    params[params.length] = +numbeToken.text;\\n                }\\n                else {\\n                    throw new Error(\\'Param not a number: \\' + mode + \\',\\' + numbeToken.text);\\n                }\\n            }\\n            if (typeof PARAMS[mode] === \\'number\\') {\\n                const segment = { key: mode, data: params };\\n                segments.push(segment);\\n                index += paramsCount;\\n                token = tokens[index];\\n                if (mode === \\'M\\')\\n                    mode = \\'L\\';\\n                if (mode === \\'m\\')\\n                    mode = \\'l\\';\\n            }\\n            else {\\n                throw new Error(\\'Bad segment: \\' + mode);\\n            }\\n        }\\n        else {\\n            throw new Error(\\'Path data ended short\\');\\n        }\\n    }\\n    return segments;\\n}\\nfunction serialize(segments) {\\n    const tokens = [];\\n    for (const { key, data } of segments) {\\n        tokens.push(key);\\n        switch (key) {\\n            case \\'C\\':\\n            case \\'c\\':\\n                tokens.push(data[0], `${data[1]},`, data[2], `${data[3]},`, data[4], data[5]);\\n                break;\\n            case \\'S\\':\\n            case \\'s\\':\\n            case \\'Q\\':\\n            case \\'q\\':\\n                tokens.push(data[0], `${data[1]},`, data[2], data[3]);\\n                break;\\n            default:\\n                tokens.push(...data);\\n                break;\\n        }\\n    }\\n    return tokens.join(\\' \\');\\n}\\n\\n;// CONCATENATED MODULE: ./node_modules/path-data-parser/lib/absolutize.js\\n// Translate relative commands to absolute commands\\nfunction absolutize(segments) {\\n    let cx = 0, cy = 0;\\n    let subx = 0, suby = 0;\\n    const out = [];\\n    for (const { key, data } of segments) {\\n        switch (key) {\\n            case \\'M\\':\\n                out.push({ key: \\'M\\', data: [...data] });\\n                [cx, cy] = data;\\n                [subx, suby] = data;\\n                break;\\n            case \\'m\\':\\n                cx += data[0];\\n                cy += data[1];\\n                out.push({ key: \\'M\\', data: [cx, cy] });\\n                subx = cx;\\n                suby = cy;\\n                break;\\n            case \\'L\\':\\n                out.push({ key: \\'L\\', data: [...data] });\\n                [cx, cy] = data;\\n                break;\\n            case \\'l\\':\\n                cx += data[0];\\n                cy += data[1];\\n                out.push({ key: \\'L\\', data: [cx, cy] });\\n                break;\\n            case \\'C\\':\\n                out.push({ key: \\'C\\', data: [...data] });\\n                cx = data[4];\\n                cy = data[5];\\n                break;\\n            case \\'c\\': {\\n                const newdata = data.map((d, i) => (i % 2) ? (d + cy) : (d + cx));\\n                out.push({ key: \\'C\\', data: newdata });\\n                cx = newdata[4];\\n                cy = newdata[5];\\n                break;\\n            }\\n            case \\'Q\\':\\n                out.push({ key: \\'Q\\', data: [...data] });\\n                cx = data[2];\\n                cy = data[3];\\n                break;\\n            case \\'q\\': {\\n                const newdata = data.map((d, i) => (i % 2) ? (d + cy) : (d + cx));\\n                out.push({ key: \\'Q\\', data: newdata });\\n                cx = newdata[2];\\n                cy = newdata[3];\\n                break;\\n            }\\n            case \\'A\\':\\n                out.push({ key: \\'A\\', data: [...data] });\\n                cx = data[5];\\n                cy = data[6];\\n                break;\\n            case \\'a\\':\\n                cx += data[5];\\n                cy += data[6];\\n                out.push({ key: \\'A\\', data: [data[0], data[1], data[2], data[3], data[4], cx, cy] });\\n                break;\\n            case \\'H\\':\\n                out.push({ key: \\'H\\', data: [...data] });\\n                cx = data[0];\\n                break;\\n            case \\'h\\':\\n                cx += data[0];\\n                out.push({ key: \\'H\\', data: [cx] });\\n                break;\\n            case \\'V\\':\\n                out.push({ key: \\'V\\', data: [...data] });\\n                cy = data[0];\\n                break;\\n            case \\'v\\':\\n                cy += data[0];\\n                out.push({ key: \\'V\\', data: [cy] });\\n                break;\\n            case \\'S\\':\\n                out.push({ key: \\'S\\', data: [...data] });\\n                cx = data[2];\\n                cy = data[3];\\n                break;\\n            case \\'s\\': {\\n                const newdata = data.map((d, i) => (i % 2) ? (d + cy) : (d + cx));\\n                out.push({ key: \\'S\\', data: newdata });\\n                cx = newdata[2];\\n                cy = newdata[3];\\n                break;\\n            }\\n            case \\'T\\':\\n                out.push({ key: \\'T\\', data: [...data] });\\n                cx = data[0];\\n                cy = data[1];\\n                break;\\n            case \\'t\\':\\n                cx += data[0];\\n                cy += data[1];\\n                out.push({ key: \\'T\\', data: [cx, cy] });\\n                break;\\n            case \\'Z\\':\\n            case \\'z\\':\\n                out.push({ key: \\'Z\\', data: [] });\\n                cx = subx;\\n                cy = suby;\\n                break;\\n        }\\n    }\\n    return out;\\n}\\n\\n;// CONCATENATED MODULE: ./node_modules/path-data-parser/lib/normalize.js\\n// Normalize path to include only M, L, C, and Z commands\\nfunction normalize_normalize(segments) {\\n    const out = [];\\n    let lastType = \\'\\';\\n    let cx = 0, cy = 0;\\n    let subx = 0, suby = 0;\\n    let lcx = 0, lcy = 0;\\n    for (const { key, data } of segments) {\\n        switch (key) {\\n            case \\'M\\':\\n                out.push({ key: \\'M\\', data: [...data] });\\n                [cx, cy] = data;\\n                [subx, suby] = data;\\n                break;\\n            case \\'C\\':\\n                out.push({ key: \\'C\\', data: [...data] });\\n                cx = data[4];\\n                cy = data[5];\\n                lcx = data[2];\\n                lcy = data[3];\\n                break;\\n            case \\'L\\':\\n                out.push({ key: \\'L\\', data: [...data] });\\n                [cx, cy] = data;\\n                break;\\n            case \\'H\\':\\n                cx = data[0];\\n                out.push({ key: \\'L\\', data: [cx, cy] });\\n                break;\\n            case \\'V\\':\\n                cy = data[0];\\n                out.push({ key: \\'L\\', data: [cx, cy] });\\n                break;\\n            case \\'S\\': {\\n                let cx1 = 0, cy1 = 0;\\n                if (lastType === \\'C\\' || lastType === \\'S\\') {\\n                    cx1 = cx + (cx - lcx);\\n                    cy1 = cy + (cy - lcy);\\n                }\\n                else {\\n                    cx1 = cx;\\n                    cy1 = cy;\\n                }\\n                out.push({ key: \\'C\\', data: [cx1, cy1, ...data] });\\n                lcx = data[0];\\n                lcy = data[1];\\n                cx = data[2];\\n                cy = data[3];\\n                break;\\n            }\\n            case \\'T\\': {\\n                const [x, y] = data;\\n                let x1 = 0, y1 = 0;\\n                if (lastType === \\'Q\\' || lastType === \\'T\\') {\\n                    x1 = cx + (cx - lcx);\\n                    y1 = cy + (cy - lcy);\\n                }\\n                else {\\n                    x1 = cx;\\n                    y1 = cy;\\n                }\\n                const cx1 = cx + 2 * (x1 - cx) / 3;\\n                const cy1 = cy + 2 * (y1 - cy) / 3;\\n                const cx2 = x + 2 * (x1 - x) / 3;\\n                const cy2 = y + 2 * (y1 - y) / 3;\\n                out.push({ key: \\'C\\', data: [cx1, cy1, cx2, cy2, x, y] });\\n                lcx = x1;\\n                lcy = y1;\\n                cx = x;\\n                cy = y;\\n                break;\\n            }\\n            case \\'Q\\': {\\n                const [x1, y1, x, y] = data;\\n                const cx1 = cx + 2 * (x1 - cx) / 3;\\n                const cy1 = cy + 2 * (y1 - cy) / 3;\\n                const cx2 = x + 2 * (x1 - x) / 3;\\n                const cy2 = y + 2 * (y1 - y) / 3;\\n                out.push({ key: \\'C\\', data: [cx1, cy1, cx2, cy2, x, y] });\\n                lcx = x1;\\n                lcy = y1;\\n                cx = x;\\n                cy = y;\\n                break;\\n            }\\n            case \\'A\\': {\\n                const r1 = Math.abs(data[0]);\\n                const r2 = Math.abs(data[1]);\\n                const angle = data[2];\\n                const largeArcFlag = data[3];\\n                const sweepFlag = data[4];\\n                const x = data[5];\\n                const y = data[6];\\n                if (r1 === 0 || r2 === 0) {\\n                    out.push({ key: \\'C\\', data: [cx, cy, x, y, x, y] });\\n                    cx = x;\\n                    cy = y;\\n                }\\n                else {\\n                    if (cx !== x || cy !== y) {\\n                        const curves = arcToCubicCurves(cx, cy, x, y, r1, r2, angle, largeArcFlag, sweepFlag);\\n                        curves.forEach(function (curve) {\\n                            out.push({ key: \\'C\\', data: curve });\\n                        });\\n                        cx = x;\\n                        cy = y;\\n                    }\\n                }\\n                break;\\n            }\\n            case \\'Z\\':\\n                out.push({ key: \\'Z\\', data: [] });\\n                cx = subx;\\n                cy = suby;\\n                break;\\n        }\\n        lastType = key;\\n    }\\n    return out;\\n}\\nfunction degToRad(degrees) {\\n    return (Math.PI * degrees) / 180;\\n}\\nfunction normalize_rotate(x, y, angleRad) {\\n    const X = x * Math.cos(angleRad) - y * Math.sin(angleRad);\\n    const Y = x * Math.sin(angleRad) + y * Math.cos(angleRad);\\n    return [X, Y];\\n}\\nfunction arcToCubicCurves(x1, y1, x2, y2, r1, r2, angle, largeArcFlag, sweepFlag, recursive) {\\n    const angleRad = degToRad(angle);\\n    let params = [];\\n    let f1 = 0, f2 = 0, cx = 0, cy = 0;\\n    if (recursive) {\\n        [f1, f2, cx, cy] = recursive;\\n    }\\n    else {\\n        [x1, y1] = normalize_rotate(x1, y1, -angleRad);\\n        [x2, y2] = normalize_rotate(x2, y2, -angleRad);\\n        const x = (x1 - x2) / 2;\\n        const y = (y1 - y2) / 2;\\n        let h = (x * x) / (r1 * r1) + (y * y) / (r2 * r2);\\n        if (h > 1) {\\n            h = Math.sqrt(h);\\n            r1 = h * r1;\\n            r2 = h * r2;\\n        }\\n        const sign = (largeArcFlag === sweepFlag) ? -1 : 1;\\n        const r1Pow = r1 * r1;\\n        const r2Pow = r2 * r2;\\n        const left = r1Pow * r2Pow - r1Pow * y * y - r2Pow * x * x;\\n        const right = r1Pow * y * y + r2Pow * x * x;\\n        const k = sign * Math.sqrt(Math.abs(left / right));\\n        cx = k * r1 * y / r2 + (x1 + x2) / 2;\\n        cy = k * -r2 * x / r1 + (y1 + y2) / 2;\\n        f1 = Math.asin(parseFloat(((y1 - cy) / r2).toFixed(9)));\\n        f2 = Math.asin(parseFloat(((y2 - cy) / r2).toFixed(9)));\\n        if (x1 < cx) {\\n            f1 = Math.PI - f1;\\n        }\\n        if (x2 < cx) {\\n            f2 = Math.PI - f2;\\n        }\\n        if (f1 < 0) {\\n            f1 = Math.PI * 2 + f1;\\n        }\\n        if (f2 < 0) {\\n            f2 = Math.PI * 2 + f2;\\n        }\\n        if (sweepFlag && f1 > f2) {\\n            f1 = f1 - Math.PI * 2;\\n        }\\n        if (!sweepFlag && f2 > f1) {\\n            f2 = f2 - Math.PI * 2;\\n        }\\n    }\\n    let df = f2 - f1;\\n    if (Math.abs(df) > (Math.PI * 120 / 180)) {\\n        const f2old = f2;\\n        const x2old = x2;\\n        const y2old = y2;\\n        if (sweepFlag && f2 > f1) {\\n            f2 = f1 + (Math.PI * 120 / 180) * (1);\\n        }\\n        else {\\n            f2 = f1 + (Math.PI * 120 / 180) * (-1);\\n        }\\n        x2 = cx + r1 * Math.cos(f2);\\n        y2 = cy + r2 * Math.sin(f2);\\n        params = arcToCubicCurves(x2, y2, x2old, y2old, r1, r2, angle, 0, sweepFlag, [f2, f2old, cx, cy]);\\n    }\\n    df = f2 - f1;\\n    const c1 = Math.cos(f1);\\n    const s1 = Math.sin(f1);\\n    const c2 = Math.cos(f2);\\n    const s2 = Math.sin(f2);\\n    const t = Math.tan(df / 4);\\n    const hx = 4 / 3 * r1 * t;\\n    const hy = 4 / 3 * r2 * t;\\n    const m1 = [x1, y1];\\n    const m2 = [x1 + hx * s1, y1 - hy * c1];\\n    const m3 = [x2 + hx * s2, y2 - hy * c2];\\n    const m4 = [x2, y2];\\n    m2[0] = 2 * m1[0] - m2[0];\\n    m2[1] = 2 * m1[1] - m2[1];\\n    if (recursive) {\\n        return [m2, m3, m4].concat(params);\\n    }\\n    else {\\n        params = [m2, m3, m4].concat(params);\\n        const curves = [];\\n        for (let i = 0; i < params.length; i += 3) {\\n            const r1 = normalize_rotate(params[i][0], params[i][1], angleRad);\\n            const r2 = normalize_rotate(params[i + 1][0], params[i + 1][1], angleRad);\\n            const r3 = normalize_rotate(params[i + 2][0], params[i + 2][1], angleRad);\\n            curves.push([r1[0], r1[1], r2[0], r2[1], r3[0], r3[1]]);\\n        }\\n        return curves;\\n    }\\n}\\n\\n;// CONCATENATED MODULE: ./node_modules/path-data-parser/lib/index.js\\n\\n\\n\\n\\n;// CONCATENATED MODULE: ./node_modules/points-on-path/lib/index.js\\n\\n\\nfunction pointsOnPath(path, tolerance, distance) {\\n    const segments = parsePath(path);\\n    const normalized = normalize_normalize(absolutize(segments));\\n    const sets = [];\\n    let currentPoints = [];\\n    let start = [0, 0];\\n    let pendingCurve = [];\\n    const appendPendingCurve = () => {\\n        if (pendingCurve.length >= 4) {\\n            currentPoints.push(...pointsOnBezierCurves(pendingCurve, tolerance));\\n        }\\n        pendingCurve = [];\\n    };\\n    const appendPendingPoints = () => {\\n        appendPendingCurve();\\n        if (currentPoints.length) {\\n            sets.push(currentPoints);\\n            currentPoints = [];\\n        }\\n    };\\n    for (const { key, data } of normalized) {\\n        switch (key) {\\n            case \\'M\\':\\n                appendPendingPoints();\\n                start = [data[0], data[1]];\\n                currentPoints.push(start);\\n                break;\\n            case \\'L\\':\\n                appendPendingCurve();\\n                currentPoints.push([data[0], data[1]]);\\n                break;\\n            case \\'C\\':\\n                if (!pendingCurve.length) {\\n                    const lastPoint = currentPoints.length ? currentPoints[currentPoints.length - 1] : start;\\n                    pendingCurve.push([lastPoint[0], lastPoint[1]]);\\n                }\\n                pendingCurve.push([data[0], data[1]]);\\n                pendingCurve.push([data[2], data[3]]);\\n                pendingCurve.push([data[4], data[5]]);\\n                break;\\n            case \\'Z\\':\\n                appendPendingCurve();\\n                currentPoints.push([start[0], start[1]]);\\n                break;\\n        }\\n    }\\n    appendPendingPoints();\\n    if (!distance) {\\n        return sets;\\n    }\\n    const out = [];\\n    for (const set of sets) {\\n        const simplifiedSet = simplify(set, distance);\\n        if (simplifiedSet.length) {\\n            out.push(simplifiedSet);\\n        }\\n    }\\n    return out;\\n}\\n\\n;// CONCATENATED MODULE: ./src/walker.ts\\nfunction walker_slicedToArray(arr, i) { return walker_arrayWithHoles(arr) || walker_iterableToArrayLimit(arr, i) || walker_unsupportedIterableToArray(arr, i) || walker_nonIterableRest(); }\\n\\nfunction walker_nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\\n\\nfunction walker_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\\n\\nfunction walker_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\\n\\nfunction walker_toConsumableArray(arr) { return walker_arrayWithoutHoles(arr) || walker_iterableToArray(arr) || walker_unsupportedIterableToArray(arr) || walker_nonIterableSpread(); }\\n\\nfunction walker_nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\\n\\nfunction walker_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return walker_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return walker_arrayLikeToArray(o, minLen); }\\n\\nfunction walker_iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\\n\\nfunction walker_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return walker_arrayLikeToArray(arr); }\\n\\nfunction walker_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\\n\\nfunction walker_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\\n\\nfunction walker_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { walker_ownKeys(Object(source), true).forEach(function (key) { walker_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { walker_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\\n\\nfunction walker_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar SUPPORTED_TAGS = [\"svg\", \"path\", \"g\", \"use\", \"circle\", \"ellipse\", \"rect\", \"polyline\", \"polygon\"];\\n\\nvar nodeValidator = function nodeValidator(node) {\\n  if (SUPPORTED_TAGS.includes(node.tagName)) {\\n    return NodeFilter.FILTER_ACCEPT;\\n  }\\n\\n  return NodeFilter.FILTER_REJECT;\\n};\\n\\nfunction createTreeWalker(dom) {\\n  return document.createTreeWalker(dom, NodeFilter.SHOW_ALL, {\\n    acceptNode: nodeValidator\\n  });\\n}\\n\\nvar walker_presAttrs = function presAttrs(el, groups) {\\n  return walker_objectSpread(walker_objectSpread(walker_objectSpread({}, getGroupAttrs(groups)), presAttrsToElementValues(el)), filterAttrsToElementValues(el));\\n};\\n\\nvar skippedUseAttrs = [\"id\"];\\nvar allwaysPassedUseAttrs = [\"x\", \"y\", \"width\", \"height\", \"href\", \"xlink:href\"];\\n/*\\n  \"Most attributes on use do not override those already on the element\\n  referenced by use. (This differs from how CSS style attributes override\\n  those set \\'earlier\\' in the cascade). Only the attributes x, y, width,\\n  height and href on the use element will override those set on the\\n  referenced element. However, any other attributes not set on the referenced\\n  element will be applied to the use element.\"\\n\\n  Situation 1: Attr is set on defEl, NOT on useEl\\n    - result: use defEl attr\\n  Situation 2: Attr is on useEl, NOT on defEl\\n    - result: use the useEl attr\\n  Situation 3: Attr is on both useEl and defEl\\n    - result: use the defEl attr (Unless x, y, width, height, href, xlink:href)\\n*/\\n\\nvar getDefElWithCorrectAttrs = function getDefElWithCorrectAttrs(defEl, useEl) {\\n  var finalEl = walker_toConsumableArray(useEl.attributes).reduce(function (el, attr) {\\n    if (skippedUseAttrs.includes(attr.value)) {\\n      return el;\\n    } // Does defEl have the attr? If so, use it, else use the useEl attr\\n\\n\\n    if (!defEl.hasAttribute(attr.name) || allwaysPassedUseAttrs.includes(attr.name)) {\\n      el.setAttribute(attr.name, useEl.getAttribute(attr.name) || \"\");\\n    }\\n\\n    return el;\\n  }, defEl.cloneNode());\\n\\n  return finalEl;\\n};\\n\\nvar walkers = {\\n  svg: function svg(args) {\\n    walk(args, args.tw.nextNode());\\n  },\\n  g: function g(args) {\\n    var nextArgs = walker_objectSpread(walker_objectSpread({}, args), {}, {\\n      tw: createTreeWalker(args.tw.currentNode),\\n      groups: [].concat(walker_toConsumableArray(args.groups), [new elements_Group(args.tw.currentNode)])\\n    });\\n\\n    walk(nextArgs, nextArgs.tw.nextNode());\\n    walk(args, args.tw.nextSibling());\\n  },\\n  use: function use(args) {\\n    var root = args.root,\\n        tw = args.tw,\\n        scene = args.scene;\\n    var useEl = tw.currentNode;\\n    var id = useEl.getAttribute(\"href\") || useEl.getAttribute(\"xlink:href\");\\n\\n    if (!id) {\\n      throw new Error(\"unable to get id of use element\");\\n    }\\n\\n    var defEl = root.querySelector(id);\\n\\n    if (!defEl) {\\n      throw new Error(\"unable to find def element with id: \".concat(id));\\n    }\\n\\n    var tempScene = new elements_ExcalidrawScene();\\n    var finalEl = getDefElWithCorrectAttrs(defEl, useEl);\\n    walk(walker_objectSpread(walker_objectSpread({}, args), {}, {\\n      scene: tempScene,\\n      tw: createTreeWalker(finalEl)\\n    }), finalEl);\\n    var exEl = tempScene.elements.pop();\\n\\n    if (!exEl) {\\n      throw new Error(\"Unable to create ex element\");\\n    }\\n\\n    scene.elements.push(exEl);\\n    walk(args, args.tw.nextNode());\\n  },\\n  circle: function circle(args) {\\n    var tw = args.tw,\\n        scene = args.scene,\\n        groups = args.groups;\\n    var el = tw.currentNode;\\n    var r = getNum(el, \"r\", 0);\\n    var d = r * 2;\\n    var x = getNum(el, \"x\", 0) + getNum(el, \"cx\", 0) - r;\\n    var y = getNum(el, \"y\", 0) + getNum(el, \"cy\", 0) - r;\\n    var mat = getTransformMatrix(el, groups); // @ts-ignore\\n\\n    var m = fromValues(d, 0, 0, 0, 0, d, 0, 0, 0, 0, 1, 0, x, y, 0, 1);\\n    var result = multiply(create(), mat, m);\\n\\n    var circle = walker_objectSpread(walker_objectSpread(walker_objectSpread({}, createExEllipse()), walker_presAttrs(el, groups)), {}, {\\n      x: result[12],\\n      y: result[13],\\n      width: result[0],\\n      height: result[5],\\n      groupIds: groups.map(function (g) {\\n        return g.id;\\n      })\\n    });\\n\\n    scene.elements.push(circle);\\n    walk(args, tw.nextNode());\\n  },\\n  ellipse: function ellipse(args) {\\n    var tw = args.tw,\\n        scene = args.scene,\\n        groups = args.groups;\\n    var el = tw.currentNode;\\n    var rx = getNum(el, \"rx\", 0);\\n    var ry = getNum(el, \"ry\", 0);\\n    var cx = getNum(el, \"cx\", 0);\\n    var cy = getNum(el, \"cy\", 0);\\n    var x = getNum(el, \"x\", 0) + cx - rx;\\n    var y = getNum(el, \"y\", 0) + cy - ry;\\n    var w = rx * 2;\\n    var h = ry * 2;\\n    var mat = getTransformMatrix(el, groups);\\n    var m = fromValues(w, 0, 0, 0, 0, h, 0, 0, 0, 0, 1, 0, x, y, 0, 1);\\n    var result = multiply(create(), mat, m);\\n\\n    var ellipse = walker_objectSpread(walker_objectSpread(walker_objectSpread({}, createExEllipse()), walker_presAttrs(el, groups)), {}, {\\n      x: result[12],\\n      y: result[13],\\n      width: result[0],\\n      height: result[5],\\n      groupIds: groups.map(function (g) {\\n        return g.id;\\n      })\\n    });\\n\\n    scene.elements.push(ellipse);\\n    walk(args, tw.nextNode());\\n  },\\n  line: function line(args) {\\n    // unimplemented\\n    walk(args, args.tw.nextNode());\\n  },\\n  polygon: function polygon(args) {\\n    var tw = args.tw,\\n        scene = args.scene,\\n        groups = args.groups;\\n    var el = tw.currentNode;\\n    var points = pointsAttrToPoints(el);\\n    var mat = getTransformMatrix(el, groups);\\n    var transformedPoints = transformPoints(points, mat); // The first point needs to be 0, 0, and all following points\\n    // are relative to the first point.\\n\\n    var x = transformedPoints[0][0];\\n    var y = transformedPoints[0][1];\\n    var relativePoints = transformedPoints.map(function (_ref) {\\n      var _ref2 = walker_slicedToArray(_ref, 2),\\n          _x = _ref2[0],\\n          _y = _ref2[1];\\n\\n      return [_x - x, _y - y];\\n    });\\n\\n    var _dimensionsFromPoints = dimensionsFromPoints(relativePoints),\\n        _dimensionsFromPoints2 = walker_slicedToArray(_dimensionsFromPoints, 2),\\n        width = _dimensionsFromPoints2[0],\\n        height = _dimensionsFromPoints2[1];\\n\\n    var line = walker_objectSpread(walker_objectSpread(walker_objectSpread(walker_objectSpread({}, createExLine()), getGroupAttrs(groups)), presAttrsToElementValues(el)), {}, {\\n      points: relativePoints.concat([[0, 0]]),\\n      x: x,\\n      y: y,\\n      width: width,\\n      height: height\\n    });\\n\\n    scene.elements.push(line);\\n    walk(args, args.tw.nextNode());\\n  },\\n  polyline: function polyline(args) {\\n    var tw = args.tw,\\n        scene = args.scene,\\n        groups = args.groups;\\n    var el = tw.currentNode;\\n    var mat = getTransformMatrix(el, groups);\\n    var points = pointsAttrToPoints(el);\\n    var transformedPoints = transformPoints(points, mat); // The first point needs to be 0, 0, and all following points\\n    // are relative to the first point.\\n\\n    var x = transformedPoints[0][0];\\n    var y = transformedPoints[0][1];\\n    var relativePoints = transformedPoints.map(function (_ref3) {\\n      var _ref4 = walker_slicedToArray(_ref3, 2),\\n          _x = _ref4[0],\\n          _y = _ref4[1];\\n\\n      return [_x - x, _y - y];\\n    });\\n\\n    var _dimensionsFromPoints3 = dimensionsFromPoints(relativePoints),\\n        _dimensionsFromPoints4 = walker_slicedToArray(_dimensionsFromPoints3, 2),\\n        width = _dimensionsFromPoints4[0],\\n        height = _dimensionsFromPoints4[1];\\n\\n    var hasFill = has(el, \"fill\");\\n    var fill = get(el, \"fill\");\\n    var shouldFill = !hasFill || hasFill && fill !== \"none\";\\n\\n    var line = walker_objectSpread(walker_objectSpread(walker_objectSpread(walker_objectSpread({}, createExLine()), getGroupAttrs(groups)), presAttrsToElementValues(el)), {}, {\\n      points: relativePoints.concat(shouldFill ? [[0, 0]] : []),\\n      x: x,\\n      y: y,\\n      width: width,\\n      height: height\\n    });\\n\\n    scene.elements.push(line);\\n    walk(args, args.tw.nextNode());\\n  },\\n  rect: function rect(args) {\\n    var tw = args.tw,\\n        scene = args.scene,\\n        groups = args.groups;\\n    var el = tw.currentNode;\\n    var x = getNum(el, \"x\", 0);\\n    var y = getNum(el, \"y\", 0);\\n    var w = getNum(el, \"width\", 0);\\n    var h = getNum(el, \"height\", 0);\\n    var mat = getTransformMatrix(el, groups); // @ts-ignore\\n\\n    var m = fromValues(w, 0, 0, 0, 0, h, 0, 0, 0, 0, 1, 0, x, y, 0, 1);\\n    var result = multiply(create(), mat, m);\\n    /*\\n    NOTE: Currently there doesn\\'t seem to be a way to specify the border\\n          radius of a rect within Excalidraw. This means that attributes\\n          rx and ry can\\'t be used.\\n    */\\n\\n    var isRound = el.hasAttribute(\"rx\") || el.hasAttribute(\"ry\");\\n\\n    var rect = walker_objectSpread(walker_objectSpread(walker_objectSpread({}, createExRect()), walker_presAttrs(el, groups)), {}, {\\n      x: result[12],\\n      y: result[13],\\n      width: result[0],\\n      height: result[5],\\n      strokeSharpness: isRound ? \"round\" : \"sharp\"\\n    });\\n\\n    scene.elements.push(rect);\\n    walk(args, args.tw.nextNode());\\n  },\\n  path: function path(args) {\\n    var tw = args.tw,\\n        scene = args.scene,\\n        groups = args.groups;\\n    var el = tw.currentNode;\\n    var mat = getTransformMatrix(el, groups);\\n    var points = pointsOnPath(get(el, \"d\"));\\n    var fillColor = get(el, \"fill\", \"black\");\\n    var fillRule = get(el, \"fill-rule\", \"nonzero\");\\n    var elements = [];\\n    var localGroup = randomId();\\n\\n    switch (fillRule) {\\n      case \"nonzero\":\\n        var initialWindingOrder = \"clockwise\";\\n        elements = points.map(function (pointArr, idx) {\\n          var tPoints = transformPoints(pointArr, clone(mat));\\n          var x = tPoints[0][0];\\n          var y = tPoints[0][1];\\n\\n          var _dimensionsFromPoints5 = dimensionsFromPoints(tPoints),\\n              _dimensionsFromPoints6 = walker_slicedToArray(_dimensionsFromPoints5, 2),\\n              width = _dimensionsFromPoints6[0],\\n              height = _dimensionsFromPoints6[1];\\n\\n          var relativePoints = tPoints.map(function (_ref5) {\\n            var _ref6 = walker_slicedToArray(_ref5, 2),\\n                _x = _ref6[0],\\n                _y = _ref6[1];\\n\\n            return [_x - x, _y - y];\\n          });\\n          var windingOrder = getWindingOrder(relativePoints);\\n\\n          if (idx === 0) {\\n            initialWindingOrder = windingOrder;\\n            localGroup = randomId();\\n          }\\n\\n          var backgroundColor = fillColor;\\n\\n          if (initialWindingOrder !== windingOrder) {\\n            backgroundColor = \"#FFFFFF\";\\n          }\\n\\n          return walker_objectSpread(walker_objectSpread(walker_objectSpread({}, createExDraw()), {}, {\\n            strokeWidth: 0,\\n            strokeColor: \"#00000000\"\\n          }, walker_presAttrs(el, groups)), {}, {\\n            points: relativePoints,\\n            backgroundColor: backgroundColor,\\n            width: width,\\n            height: height,\\n            x: x + getNum(el, \"x\", 0),\\n            y: y + getNum(el, \"y\", 0),\\n            groupIds: [localGroup]\\n          });\\n        });\\n        break;\\n\\n      case \"evenodd\":\\n        elements = points.map(function (pointArr, idx) {\\n          var tPoints = transformPoints(pointArr, clone(mat));\\n          var x = tPoints[0][0];\\n          var y = tPoints[0][1];\\n\\n          var _dimensionsFromPoints7 = dimensionsFromPoints(tPoints),\\n              _dimensionsFromPoints8 = walker_slicedToArray(_dimensionsFromPoints7, 2),\\n              width = _dimensionsFromPoints8[0],\\n              height = _dimensionsFromPoints8[1];\\n\\n          var relativePoints = tPoints.map(function (_ref7) {\\n            var _ref8 = walker_slicedToArray(_ref7, 2),\\n                _x = _ref8[0],\\n                _y = _ref8[1];\\n\\n            return [_x - x, _y - y];\\n          });\\n\\n          if (idx === 0) {\\n            localGroup = randomId();\\n          }\\n\\n          return walker_objectSpread(walker_objectSpread(walker_objectSpread({}, createExDraw()), walker_presAttrs(el, groups)), {}, {\\n            points: relativePoints,\\n            width: width,\\n            height: height,\\n            x: x + getNum(el, \"x\", 0),\\n            y: y + getNum(el, \"y\", 0)\\n          });\\n        });\\n        break;\\n\\n      default:\\n    }\\n\\n    scene.elements = scene.elements.concat(elements);\\n    walk(args, tw.nextNode());\\n  }\\n};\\nfunction walk(args, nextNode) {\\n  if (!nextNode) {\\n    return;\\n  }\\n\\n  var nodeName = nextNode.nodeName;\\n\\n  if (walkers[nodeName]) {\\n    walkers[nodeName](args);\\n  }\\n}\\n;// CONCATENATED MODULE: ./src/parser.ts\\nfunction parser_toConsumableArray(arr) { return parser_arrayWithoutHoles(arr) || parser_iterableToArray(arr) || parser_unsupportedIterableToArray(arr) || parser_nonIterableSpread(); }\\n\\nfunction parser_nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\\n\\nfunction parser_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return parser_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return parser_arrayLikeToArray(o, minLen); }\\n\\nfunction parser_iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\\n\\nfunction parser_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return parser_arrayLikeToArray(arr); }\\n\\nfunction parser_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\\n\\n\\n\\nvar convert = function convert(svgString) {\\n  var parser = new DOMParser();\\n  var svgDOM = parser.parseFromString(svgString, \"image/svg+xml\"); // was there a parsing error?\\n\\n  var errorsElements = svgDOM.querySelectorAll(\"parsererror\");\\n  var hasErrors = errorsElements.length > 0;\\n  var content = null;\\n\\n  if (hasErrors) {\\n    console.error(\"There were errors while parsing the given SVG: \", parser_toConsumableArray(errorsElements).map(function (el) {\\n      return el.innerHTML;\\n    }));\\n  } else {\\n    var tw = createTreeWalker(svgDOM);\\n    var scene = new elements_ExcalidrawScene();\\n    var groups = [];\\n    walk({\\n      tw: tw,\\n      scene: scene,\\n      groups: groups,\\n      root: svgDOM\\n    }, tw.nextNode());\\n    content = scene.toExJSON();\\n  }\\n\\n  return {\\n    hasErrors: hasErrors,\\n    errors: hasErrors ? errorsElements : null,\\n    content: content\\n  };\\n};\\n;// CONCATENATED MODULE: ./src/index.ts\\n\\n/* harmony default export */ const src = (src_parser_namespaceObject);//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQXdCLFVBQUNDLEVBQUQ7QUFBQSxhQUFRQSxFQUFFLENBQUNvUCxTQUFYO0FBQUEsS0FBeEIsQ0FGRjtBQUlELEdBTEQsTUFLTztBQUNMLFFBQU0zRCxFQUFFLEdBQUdqQixnQkFBZ0IsQ0FBQ29FLE1BQUQsQ0FBM0I7QUFDQSxRQUFNM0MsS0FBSyxHQUFHLElBQUlwTSx3QkFBSixFQUFkO0FBQ0EsUUFBTWdGLE1BQWUsR0FBRyxFQUF4QjtBQUVBMkcsSUFBQUEsSUFBSSxDQUFDO0FBQUVDLE1BQUFBLEVBQUUsRUFBRkEsRUFBRjtBQUFNUSxNQUFBQSxLQUFLLEVBQUxBLEtBQU47QUFBYXBILE1BQUFBLE1BQU0sRUFBTkEsTUFBYjtBQUFxQm1ILE1BQUFBLElBQUksRUFBRTRDO0FBQTNCLEtBQUQsRUFBc0NuRCxFQUFFLENBQUNDLFFBQUgsRUFBdEMsQ0FBSjtBQUVBdUQsSUFBQUEsT0FBTyxHQUFHaEQsS0FBSyxDQUFDb0QsUUFBTixFQUFWO0FBQ0Q7O0FBRUQsU0FBTztBQUNMTCxJQUFBQSxTQUFTLEVBQVRBLFNBREs7QUFFTE0sSUFBQUEsTUFBTSxFQUFFTixTQUFTLEdBQUdGLGNBQUgsR0FBb0IsSUFGaEM7QUFHTEcsSUFBQUEsT0FBTyxFQUFQQTtBQUhLLEdBQVA7QUFLRCxDQTdCTSxDOztBQ1ZQO0FBRUEsMENBQWVQLDBCQUFmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3ZnLXRvLWV4Y2FsaWRyYXcvLi9zcmMvZWxlbWVudHMvRXhjYWxpZHJhd1NjZW5lLnRzPzFjNDQiLCJ3ZWJwYWNrOi8vc3ZnLXRvLWV4Y2FsaWRyYXcvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9jb21tb24uanM/Yzk0ZCIsIndlYnBhY2s6Ly9zdmctdG8tZXhjYWxpZHJhdy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL21hdDQuanM/NjVhMSIsIndlYnBhY2s6Ly9zdmctdG8tZXhjYWxpZHJhdy8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9tYXRoLmpzPzIxMmIiLCJ3ZWJwYWNrOi8vc3ZnLXRvLWV4Y2FsaWRyYXcvLi9ub2RlX21vZHVsZXMvbmFub2lkL2luZGV4LnByb2QuanM/NmQ3NyIsIndlYnBhY2s6Ly9zdmctdG8tZXhjYWxpZHJhdy8uL3NyYy91dGlscy50cz83ZGRhIiwid2VicGFjazovL3N2Zy10by1leGNhbGlkcmF3Ly4vc3JjL2F0dHJpYnV0ZXMudHM/M2Q5NCIsIndlYnBhY2s6Ly9zdmctdG8tZXhjYWxpZHJhdy8uL3NyYy9lbGVtZW50cy9Hcm91cC50cz9hNzI3Iiwid2VicGFjazovL3N2Zy10by1leGNhbGlkcmF3Ly4vc3JjL2VsZW1lbnRzL0V4Y2FsaWRyYXdFbGVtZW50LnRzP2QzNWEiLCJ3ZWJwYWNrOi8vc3ZnLXRvLWV4Y2FsaWRyYXcvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS92ZWMzLmpzPzlmZTciLCJ3ZWJwYWNrOi8vc3ZnLXRvLWV4Y2FsaWRyYXcvLi9zcmMvdHJhbnNmb3JtLnRzPzVjZmEiLCJ3ZWJwYWNrOi8vc3ZnLXRvLWV4Y2FsaWRyYXcvLi9ub2RlX21vZHVsZXMvcG9pbnRzLW9uLWN1cnZlL2xpYi9pbmRleC5qcz9mNDQ4Iiwid2VicGFjazovL3N2Zy10by1leGNhbGlkcmF3Ly4vbm9kZV9tb2R1bGVzL3BhdGgtZGF0YS1wYXJzZXIvbGliL3BhcnNlci5qcz8xOWQ5Iiwid2VicGFjazovL3N2Zy10by1leGNhbGlkcmF3Ly4vbm9kZV9tb2R1bGVzL3BhdGgtZGF0YS1wYXJzZXIvbGliL2Fic29sdXRpemUuanM/YzMwNiIsIndlYnBhY2s6Ly9zdmctdG8tZXhjYWxpZHJhdy8uL25vZGVfbW9kdWxlcy9wYXRoLWRhdGEtcGFyc2VyL2xpYi9ub3JtYWxpemUuanM/MzA4NCIsIndlYnBhY2s6Ly9zdmctdG8tZXhjYWxpZHJhdy8uL25vZGVfbW9kdWxlcy9wYXRoLWRhdGEtcGFyc2VyL2xpYi9pbmRleC5qcz85ZDg2Iiwid2VicGFjazovL3N2Zy10by1leGNhbGlkcmF3Ly4vbm9kZV9tb2R1bGVzL3BvaW50cy1vbi1wYXRoL2xpYi9pbmRleC5qcz9mMTkxIiwid2VicGFjazovL3N2Zy10by1leGNhbGlkcmF3Ly4vc3JjL3dhbGtlci50cz8wMWRjIiwid2VicGFjazovL3N2Zy10by1leGNhbGlkcmF3Ly4vc3JjL3BhcnNlci50cz9iOTcxIiwid2VicGFjazovL3N2Zy10by1leGNhbGlkcmF3Ly4vc3JjL2luZGV4LnRzP2ZmYjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXhjYWxpZHJhd0dlbmVyaWNFbGVtZW50IH0gZnJvbSBcIi4vRXhjYWxpZHJhd0VsZW1lbnRcIjtcblxuY2xhc3MgRXhjYWxpZHJhd1NjZW5lIHtcbiAgdHlwZSA9IFwiZXhjYWxpZHJhd1wiO1xuICB2ZXJzaW9uID0gMjtcbiAgc291cmNlID0gXCJodHRwczovL2V4Y2FsaWRyYXcuY29tXCI7XG4gIGVsZW1lbnRzOiBFeGNhbGlkcmF3R2VuZXJpY0VsZW1lbnRbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnRzID0gW10pIHtcbiAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gIH1cblxuICB0b0V4SlNPTigpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLFxuICAgICAgZWxlbWVudHM6IHRoaXMuZWxlbWVudHMubWFwKChlbCkgPT4gKHsgLi4uZWwgfSkpLFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRXhjYWxpZHJhd1NjZW5lO1xuIiwiLyoqXHJcbiAqIENvbW1vbiB1dGlsaXRpZXNcclxuICogQG1vZHVsZSBnbE1hdHJpeFxyXG4gKi9cbi8vIENvbmZpZ3VyYXRpb24gQ29uc3RhbnRzXG5leHBvcnQgdmFyIEVQU0lMT04gPSAwLjAwMDAwMTtcbmV4cG9ydCB2YXIgQVJSQVlfVFlQRSA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnID8gRmxvYXQzMkFycmF5IDogQXJyYXk7XG5leHBvcnQgdmFyIFJBTkRPTSA9IE1hdGgucmFuZG9tO1xuLyoqXHJcbiAqIFNldHMgdGhlIHR5cGUgb2YgYXJyYXkgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyB2ZWN0b3JzIGFuZCBtYXRyaWNlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheUNvbnN0cnVjdG9yIHwgQXJyYXlDb25zdHJ1Y3Rvcn0gdHlwZSBBcnJheSB0eXBlLCBzdWNoIGFzIEZsb2F0MzJBcnJheSBvciBBcnJheVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldE1hdHJpeEFycmF5VHlwZSh0eXBlKSB7XG4gIEFSUkFZX1RZUEUgPSB0eXBlO1xufVxudmFyIGRlZ3JlZSA9IE1hdGguUEkgLyAxODA7XG4vKipcclxuICogQ29udmVydCBEZWdyZWUgVG8gUmFkaWFuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIEFuZ2xlIGluIERlZ3JlZXNcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0b1JhZGlhbihhKSB7XG4gIHJldHVybiBhICogZGVncmVlO1xufVxuLyoqXHJcbiAqIFRlc3RzIHdoZXRoZXIgb3Igbm90IHRoZSBhcmd1bWVudHMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIHZhbHVlLCB3aXRoaW4gYW4gYWJzb2x1dGVcclxuICogb3IgcmVsYXRpdmUgdG9sZXJhbmNlIG9mIGdsTWF0cml4LkVQU0lMT04gKGFuIGFic29sdXRlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciB2YWx1ZXMgbGVzc1xyXG4gKiB0aGFuIG9yIGVxdWFsIHRvIDEuMCwgYW5kIGEgcmVsYXRpdmUgdG9sZXJhbmNlIGlzIHVzZWQgZm9yIGxhcmdlciB2YWx1ZXMpXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCBudW1iZXIgdG8gdGVzdC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHNlY29uZCBudW1iZXIgdG8gdGVzdC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG51bWJlcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDw9IEVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEpLCBNYXRoLmFicyhiKSk7XG59XG5pZiAoIU1hdGguaHlwb3QpIE1hdGguaHlwb3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB5ID0gMCxcbiAgICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICB5ICs9IGFyZ3VtZW50c1tpXSAqIGFyZ3VtZW50c1tpXTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLnNxcnQoeSk7XG59OyIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuLyoqXHJcbiAqIDR4NCBNYXRyaXg8YnI+Rm9ybWF0OiBjb2x1bW4tbWFqb3IsIHdoZW4gdHlwZWQgb3V0IGl0IGxvb2tzIGxpa2Ugcm93LW1ham9yPGJyPlRoZSBtYXRyaWNlcyBhcmUgYmVpbmcgcG9zdCBtdWx0aXBsaWVkLlxyXG4gKiBAbW9kdWxlIG1hdDRcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDRcclxuICpcclxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICB9XG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgbWF0NCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSBtYXRyaXggdG8gY2xvbmVcclxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIG91dFs5XSA9IGFbOV07XG4gIG91dFsxMF0gPSBhWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdO1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDQgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgb3V0WzldID0gYVs5XTtcbiAgb3V0WzEwXSA9IGFbMTBdO1xuICBvdXRbMTFdID0gYVsxMV07XG4gIG91dFsxMl0gPSBhWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdO1xuICBvdXRbMTRdID0gYVsxNF07XG4gIG91dFsxNV0gPSBhWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgbWF0NCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMyBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA2KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEzIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDMgcG9zaXRpb24gKGluZGV4IDcpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggOClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA5KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDEwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIzIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDMgcG9zaXRpb24gKGluZGV4IDExKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMwIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDAgcG9zaXRpb24gKGluZGV4IDEyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMxIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDEgcG9zaXRpb24gKGluZGV4IDEzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDIgcG9zaXRpb24gKGluZGV4IDE0KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMzIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDMgcG9zaXRpb24gKGluZGV4IDE1KVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gQSBuZXcgbWF0NFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMobTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0wMztcbiAgb3V0WzRdID0gbTEwO1xuICBvdXRbNV0gPSBtMTE7XG4gIG91dFs2XSA9IG0xMjtcbiAgb3V0WzddID0gbTEzO1xuICBvdXRbOF0gPSBtMjA7XG4gIG91dFs5XSA9IG0yMTtcbiAgb3V0WzEwXSA9IG0yMjtcbiAgb3V0WzExXSA9IG0yMztcbiAgb3V0WzEyXSA9IG0zMDtcbiAgb3V0WzEzXSA9IG0zMTtcbiAgb3V0WzE0XSA9IG0zMjtcbiAgb3V0WzE1XSA9IG0zMztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQ0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMyBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA2KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEzIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDMgcG9zaXRpb24gKGluZGV4IDcpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggOClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA5KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDEwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIzIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDMgcG9zaXRpb24gKGluZGV4IDExKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMwIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDAgcG9zaXRpb24gKGluZGV4IDEyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMxIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDEgcG9zaXRpb24gKGluZGV4IDEzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDIgcG9zaXRpb24gKGluZGV4IDE0KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMzIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDMgcG9zaXRpb24gKGluZGV4IDE1KVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKSB7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0wMztcbiAgb3V0WzRdID0gbTEwO1xuICBvdXRbNV0gPSBtMTE7XG4gIG91dFs2XSA9IG0xMjtcbiAgb3V0WzddID0gbTEzO1xuICBvdXRbOF0gPSBtMjA7XG4gIG91dFs5XSA9IG0yMTtcbiAgb3V0WzEwXSA9IG0yMjtcbiAgb3V0WzExXSA9IG0yMztcbiAgb3V0WzEyXSA9IG0zMDtcbiAgb3V0WzEzXSA9IG0zMTtcbiAgb3V0WzE0XSA9IG0zMjtcbiAgb3V0WzE1XSA9IG0zMztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgYSBtYXQ0IHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0NFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICB2YXIgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXTtcbiAgICB2YXIgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XTtcbiAgICB2YXIgYTIzID0gYVsxMV07XG4gICAgb3V0WzFdID0gYVs0XTtcbiAgICBvdXRbMl0gPSBhWzhdO1xuICAgIG91dFszXSA9IGFbMTJdO1xuICAgIG91dFs0XSA9IGEwMTtcbiAgICBvdXRbNl0gPSBhWzldO1xuICAgIG91dFs3XSA9IGFbMTNdO1xuICAgIG91dFs4XSA9IGEwMjtcbiAgICBvdXRbOV0gPSBhMTI7XG4gICAgb3V0WzExXSA9IGFbMTRdO1xuICAgIG91dFsxMl0gPSBhMDM7XG4gICAgb3V0WzEzXSA9IGExMztcbiAgICBvdXRbMTRdID0gYTIzO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVs0XTtcbiAgICBvdXRbMl0gPSBhWzhdO1xuICAgIG91dFszXSA9IGFbMTJdO1xuICAgIG91dFs0XSA9IGFbMV07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzldO1xuICAgIG91dFs3XSA9IGFbMTNdO1xuICAgIG91dFs4XSA9IGFbMl07XG4gICAgb3V0WzldID0gYVs2XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTRdO1xuICAgIG91dFsxMl0gPSBhWzNdO1xuICAgIG91dFsxM10gPSBhWzddO1xuICAgIG91dFsxNF0gPSBhWzExXTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEludmVydHMgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICB2YXIgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICB2YXIgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICB2YXIgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICB2YXIgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICB2YXIgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICB2YXIgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICB2YXIgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICB2YXIgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICB2YXIgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICB2YXIgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICB2YXIgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICB2YXIgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgdmFyIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgb3V0WzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgb3V0WzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgb3V0WzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgb3V0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgb3V0WzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICBvdXRbMF0gPSBhMTEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMik7XG4gIG91dFsxXSA9IC0oYTAxICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgb3V0WzJdID0gYTAxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpO1xuICBvdXRbM10gPSAtKGEwMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTExICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gIG91dFs0XSA9IC0oYTEwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgb3V0WzVdID0gYTAwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpO1xuICBvdXRbNl0gPSAtKGEwMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTEwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gIG91dFs3XSA9IGEwMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTEwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKTtcbiAgb3V0WzhdID0gYTEwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpO1xuICBvdXRbOV0gPSAtKGEwMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSk7XG4gIG91dFsxMF0gPSBhMDAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSk7XG4gIG91dFsxMV0gPSAtKGEwMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gIG91dFsxMl0gPSAtKGExMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSk7XG4gIG91dFsxM10gPSBhMDAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSk7XG4gIG91dFsxNF0gPSAtKGEwMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XG4gIG91dFsxNV0gPSBhMDAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICB2YXIgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICB2YXIgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICB2YXIgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICB2YXIgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICB2YXIgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICB2YXIgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICB2YXIgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICB2YXIgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICB2YXIgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICB2YXIgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICB2YXIgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICB2YXIgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgcmV0dXJuIGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQ0c1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF0sXG4gICAgICBhMTEgPSBhWzVdLFxuICAgICAgYTEyID0gYVs2XSxcbiAgICAgIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdLFxuICAgICAgYTIxID0gYVs5XSxcbiAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgYTIzID0gYVsxMV07XG4gIHZhciBhMzAgPSBhWzEyXSxcbiAgICAgIGEzMSA9IGFbMTNdLFxuICAgICAgYTMyID0gYVsxNF0sXG4gICAgICBhMzMgPSBhWzE1XTsgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4XG5cbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgb3V0WzBdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFsxXSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbMl0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzNdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIGIwID0gYls0XTtcbiAgYjEgPSBiWzVdO1xuICBiMiA9IGJbNl07XG4gIGIzID0gYls3XTtcbiAgb3V0WzRdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFs1XSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbNl0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzddID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIGIwID0gYls4XTtcbiAgYjEgPSBiWzldO1xuICBiMiA9IGJbMTBdO1xuICBiMyA9IGJbMTFdO1xuICBvdXRbOF0gPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDtcbiAgb3V0WzldID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gIG91dFsxMF0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzExXSA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzO1xuICBiMCA9IGJbMTJdO1xuICBiMSA9IGJbMTNdO1xuICBiMiA9IGJbMTRdO1xuICBiMyA9IGJbMTVdO1xuICBvdXRbMTJdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFsxM10gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcbiAgb3V0WzE0XSA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyO1xuICBvdXRbMTVdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNsYXRlIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgdmFyIHggPSB2WzBdLFxuICAgICAgeSA9IHZbMV0sXG4gICAgICB6ID0gdlsyXTtcbiAgdmFyIGEwMCwgYTAxLCBhMDIsIGEwMztcbiAgdmFyIGExMCwgYTExLCBhMTIsIGExMztcbiAgdmFyIGEyMCwgYTIxLCBhMjIsIGEyMztcblxuICBpZiAoYSA9PT0gb3V0KSB7XG4gICAgb3V0WzEyXSA9IGFbMF0gKiB4ICsgYVs0XSAqIHkgKyBhWzhdICogeiArIGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzNdICogeCArIGFbN10gKiB5ICsgYVsxMV0gKiB6ICsgYVsxNV07XG4gIH0gZWxzZSB7XG4gICAgYTAwID0gYVswXTtcbiAgICBhMDEgPSBhWzFdO1xuICAgIGEwMiA9IGFbMl07XG4gICAgYTAzID0gYVszXTtcbiAgICBhMTAgPSBhWzRdO1xuICAgIGExMSA9IGFbNV07XG4gICAgYTEyID0gYVs2XTtcbiAgICBhMTMgPSBhWzddO1xuICAgIGEyMCA9IGFbOF07XG4gICAgYTIxID0gYVs5XTtcbiAgICBhMjIgPSBhWzEwXTtcbiAgICBhMjMgPSBhWzExXTtcbiAgICBvdXRbMF0gPSBhMDA7XG4gICAgb3V0WzFdID0gYTAxO1xuICAgIG91dFsyXSA9IGEwMjtcbiAgICBvdXRbM10gPSBhMDM7XG4gICAgb3V0WzRdID0gYTEwO1xuICAgIG91dFs1XSA9IGExMTtcbiAgICBvdXRbNl0gPSBhMTI7XG4gICAgb3V0WzddID0gYTEzO1xuICAgIG91dFs4XSA9IGEyMDtcbiAgICBvdXRbOV0gPSBhMjE7XG4gICAgb3V0WzEwXSA9IGEyMjtcbiAgICBvdXRbMTFdID0gYTIzO1xuICAgIG91dFsxMl0gPSBhMDAgKiB4ICsgYTEwICogeSArIGEyMCAqIHogKyBhWzEyXTtcbiAgICBvdXRbMTNdID0gYTAxICogeCArIGExMSAqIHkgKyBhMjEgKiB6ICsgYVsxM107XG4gICAgb3V0WzE0XSA9IGEwMiAqIHggKyBhMTIgKiB5ICsgYTIyICogeiArIGFbMTRdO1xuICAgIG91dFsxNV0gPSBhMDMgKiB4ICsgYTEzICogeSArIGEyMyAqIHogKyBhWzE1XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIHRoZSBtYXQ0IGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMzIG5vdCB1c2luZyB2ZWN0b3JpemF0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgdGhlIHZlYzMgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgeCA9IHZbMF0sXG4gICAgICB5ID0gdlsxXSxcbiAgICAgIHogPSB2WzJdO1xuICBvdXRbMF0gPSBhWzBdICogeDtcbiAgb3V0WzFdID0gYVsxXSAqIHg7XG4gIG91dFsyXSA9IGFbMl0gKiB4O1xuICBvdXRbM10gPSBhWzNdICogeDtcbiAgb3V0WzRdID0gYVs0XSAqIHk7XG4gIG91dFs1XSA9IGFbNV0gKiB5O1xuICBvdXRbNl0gPSBhWzZdICogeTtcbiAgb3V0WzddID0gYVs3XSAqIHk7XG4gIG91dFs4XSA9IGFbOF0gKiB6O1xuICBvdXRbOV0gPSBhWzldICogejtcbiAgb3V0WzEwXSA9IGFbMTBdICogejtcbiAgb3V0WzExXSA9IGFbMTFdICogejtcbiAgb3V0WzEyXSA9IGFbMTJdO1xuICBvdXRbMTNdID0gYVsxM107XG4gIG91dFsxNF0gPSBhWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBtYXQ0IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIGdpdmVuIGF4aXNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkLCBheGlzKSB7XG4gIHZhciB4ID0gYXhpc1swXSxcbiAgICAgIHkgPSBheGlzWzFdLFxuICAgICAgeiA9IGF4aXNbMl07XG4gIHZhciBsZW4gPSBNYXRoLmh5cG90KHgsIHksIHopO1xuICB2YXIgcywgYywgdDtcbiAgdmFyIGEwMCwgYTAxLCBhMDIsIGEwMztcbiAgdmFyIGExMCwgYTExLCBhMTIsIGExMztcbiAgdmFyIGEyMCwgYTIxLCBhMjIsIGEyMztcbiAgdmFyIGIwMCwgYjAxLCBiMDI7XG4gIHZhciBiMTAsIGIxMSwgYjEyO1xuICB2YXIgYjIwLCBiMjEsIGIyMjtcblxuICBpZiAobGVuIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGVuID0gMSAvIGxlbjtcbiAgeCAqPSBsZW47XG4gIHkgKj0gbGVuO1xuICB6ICo9IGxlbjtcbiAgcyA9IE1hdGguc2luKHJhZCk7XG4gIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB0ID0gMSAtIGM7XG4gIGEwMCA9IGFbMF07XG4gIGEwMSA9IGFbMV07XG4gIGEwMiA9IGFbMl07XG4gIGEwMyA9IGFbM107XG4gIGExMCA9IGFbNF07XG4gIGExMSA9IGFbNV07XG4gIGExMiA9IGFbNl07XG4gIGExMyA9IGFbN107XG4gIGEyMCA9IGFbOF07XG4gIGEyMSA9IGFbOV07XG4gIGEyMiA9IGFbMTBdO1xuICBhMjMgPSBhWzExXTsgLy8gQ29uc3RydWN0IHRoZSBlbGVtZW50cyBvZiB0aGUgcm90YXRpb24gbWF0cml4XG5cbiAgYjAwID0geCAqIHggKiB0ICsgYztcbiAgYjAxID0geSAqIHggKiB0ICsgeiAqIHM7XG4gIGIwMiA9IHogKiB4ICogdCAtIHkgKiBzO1xuICBiMTAgPSB4ICogeSAqIHQgLSB6ICogcztcbiAgYjExID0geSAqIHkgKiB0ICsgYztcbiAgYjEyID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gIGIyMCA9IHggKiB6ICogdCArIHkgKiBzO1xuICBiMjEgPSB5ICogeiAqIHQgLSB4ICogcztcbiAgYjIyID0geiAqIHogKiB0ICsgYzsgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSBhMDAgKiBiMDAgKyBhMTAgKiBiMDEgKyBhMjAgKiBiMDI7XG4gIG91dFsxXSA9IGEwMSAqIGIwMCArIGExMSAqIGIwMSArIGEyMSAqIGIwMjtcbiAgb3V0WzJdID0gYTAyICogYjAwICsgYTEyICogYjAxICsgYTIyICogYjAyO1xuICBvdXRbM10gPSBhMDMgKiBiMDAgKyBhMTMgKiBiMDEgKyBhMjMgKiBiMDI7XG4gIG91dFs0XSA9IGEwMCAqIGIxMCArIGExMCAqIGIxMSArIGEyMCAqIGIxMjtcbiAgb3V0WzVdID0gYTAxICogYjEwICsgYTExICogYjExICsgYTIxICogYjEyO1xuICBvdXRbNl0gPSBhMDIgKiBiMTAgKyBhMTIgKiBiMTEgKyBhMjIgKiBiMTI7XG4gIG91dFs3XSA9IGEwMyAqIGIxMCArIGExMyAqIGIxMSArIGEyMyAqIGIxMjtcbiAgb3V0WzhdID0gYTAwICogYjIwICsgYTEwICogYjIxICsgYTIwICogYjIyO1xuICBvdXRbOV0gPSBhMDEgKiBiMjAgKyBhMTEgKiBiMjEgKyBhMjEgKiBiMjI7XG4gIG91dFsxMF0gPSBhMDIgKiBiMjAgKyBhMTIgKiBiMjEgKyBhMjIgKiBiMjI7XG4gIG91dFsxMV0gPSBhMDMgKiBiMjAgKyBhMTMgKiBiMjEgKyBhMjMgKiBiMjI7XG5cbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgdmFyIGExMCA9IGFbNF07XG4gIHZhciBhMTEgPSBhWzVdO1xuICB2YXIgYTEyID0gYVs2XTtcbiAgdmFyIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdO1xuICB2YXIgYTIxID0gYVs5XTtcbiAgdmFyIGEyMiA9IGFbMTBdO1xuICB2YXIgYTIzID0gYVsxMV07XG5cbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfSAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cblxuICBvdXRbNF0gPSBhMTAgKiBjICsgYTIwICogcztcbiAgb3V0WzVdID0gYTExICogYyArIGEyMSAqIHM7XG4gIG91dFs2XSA9IGExMiAqIGMgKyBhMjIgKiBzO1xuICBvdXRbN10gPSBhMTMgKiBjICsgYTIzICogcztcbiAgb3V0WzhdID0gYTIwICogYyAtIGExMCAqIHM7XG4gIG91dFs5XSA9IGEyMSAqIGMgLSBhMTEgKiBzO1xuICBvdXRbMTBdID0gYTIyICogYyAtIGExMiAqIHM7XG4gIG91dFsxMV0gPSBhMjMgKiBjIC0gYTEzICogcztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgdmFyIGEwMCA9IGFbMF07XG4gIHZhciBhMDEgPSBhWzFdO1xuICB2YXIgYTAyID0gYVsyXTtcbiAgdmFyIGEwMyA9IGFbM107XG4gIHZhciBhMjAgPSBhWzhdO1xuICB2YXIgYTIxID0gYVs5XTtcbiAgdmFyIGEyMiA9IGFbMTBdO1xuICB2YXIgYTIzID0gYVsxMV07XG5cbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfSAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cblxuICBvdXRbMF0gPSBhMDAgKiBjIC0gYTIwICogcztcbiAgb3V0WzFdID0gYTAxICogYyAtIGEyMSAqIHM7XG4gIG91dFsyXSA9IGEwMiAqIGMgLSBhMjIgKiBzO1xuICBvdXRbM10gPSBhMDMgKiBjIC0gYTIzICogcztcbiAgb3V0WzhdID0gYTAwICogcyArIGEyMCAqIGM7XG4gIG91dFs5XSA9IGEwMSAqIHMgKyBhMjEgKiBjO1xuICBvdXRbMTBdID0gYTAyICogcyArIGEyMiAqIGM7XG4gIG91dFsxMV0gPSBhMDMgKiBzICsgYTIzICogYztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgdmFyIGEwMCA9IGFbMF07XG4gIHZhciBhMDEgPSBhWzFdO1xuICB2YXIgYTAyID0gYVsyXTtcbiAgdmFyIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdO1xuICB2YXIgYTExID0gYVs1XTtcbiAgdmFyIGExMiA9IGFbNl07XG4gIHZhciBhMTMgPSBhWzddO1xuXG4gIGlmIChhICE9PSBvdXQpIHtcbiAgICAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfSAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cblxuICBvdXRbMF0gPSBhMDAgKiBjICsgYTEwICogcztcbiAgb3V0WzFdID0gYTAxICogYyArIGExMSAqIHM7XG4gIG91dFsyXSA9IGEwMiAqIGMgKyBhMTIgKiBzO1xuICBvdXRbM10gPSBhMDMgKiBjICsgYTEzICogcztcbiAgb3V0WzRdID0gYTEwICogYyAtIGEwMCAqIHM7XG4gIG91dFs1XSA9IGExMSAqIGMgLSBhMDEgKiBzO1xuICBvdXRbNl0gPSBhMTIgKiBjIC0gYTAyICogcztcbiAgb3V0WzddID0gYTEzICogYyAtIGEwMyAqIHM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHJhbnNsYXRpb24ob3V0LCB2KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDE7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAxO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF07XG4gIG91dFsxM10gPSB2WzFdO1xuICBvdXRbMTRdID0gdlsyXTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFNjYWxpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gdlsxXTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IHZbMl07XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZSBhcm91bmQgYSBnaXZlbiBheGlzXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQucm90YXRlKGRlc3QsIGRlc3QsIHJhZCwgYXhpcyk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcmFkLCBheGlzKSB7XG4gIHZhciB4ID0gYXhpc1swXSxcbiAgICAgIHkgPSBheGlzWzFdLFxuICAgICAgeiA9IGF4aXNbMl07XG4gIHZhciBsZW4gPSBNYXRoLmh5cG90KHgsIHksIHopO1xuICB2YXIgcywgYywgdDtcblxuICBpZiAobGVuIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGVuID0gMSAvIGxlbjtcbiAgeCAqPSBsZW47XG4gIHkgKj0gbGVuO1xuICB6ICo9IGxlbjtcbiAgcyA9IE1hdGguc2luKHJhZCk7XG4gIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB0ID0gMSAtIGM7IC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0geCAqIHggKiB0ICsgYztcbiAgb3V0WzFdID0geSAqIHggKiB0ICsgeiAqIHM7XG4gIG91dFsyXSA9IHogKiB4ICogdCAtIHkgKiBzO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4ICogeSAqIHQgLSB6ICogcztcbiAgb3V0WzVdID0geSAqIHkgKiB0ICsgYztcbiAgb3V0WzZdID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHggKiB6ICogdCArIHkgKiBzO1xuICBvdXRbOV0gPSB5ICogeiAqIHQgLSB4ICogcztcbiAgb3V0WzEwXSA9IHogKiB6ICogdCArIGM7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQucm90YXRlWChkZXN0LCBkZXN0LCByYWQpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tWFJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpOyAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gYztcbiAgb3V0WzZdID0gcztcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gLXM7XG4gIG91dFsxMF0gPSBjO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnJvdGF0ZVkoZGVzdCwgZGVzdCwgcmFkKTtcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVlSb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTsgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IC1zO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSBzO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gYztcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC5yb3RhdGVaKGRlc3QsIGRlc3QsIHJhZCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21aUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSBjO1xuICBvdXRbMV0gPSBzO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAtcztcbiAgb3V0WzVdID0gYztcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uIGFuZCB2ZWN0b3IgdHJhbnNsYXRpb25cclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcclxuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcclxuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBxLCB2KSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHh5ID0geCAqIHkyO1xuICB2YXIgeHogPSB4ICogejI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHl6ID0geSAqIHoyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIG91dFswXSA9IDEgLSAoeXkgKyB6eik7XG4gIG91dFsxXSA9IHh5ICsgd3o7XG4gIG91dFsyXSA9IHh6IC0gd3k7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHh5IC0gd3o7XG4gIG91dFs1XSA9IDEgLSAoeHggKyB6eik7XG4gIG91dFs2XSA9IHl6ICsgd3g7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHh6ICsgd3k7XG4gIG91dFs5XSA9IHl6IC0gd3g7XG4gIG91dFsxMF0gPSAxIC0gKHh4ICsgeXkpO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF07XG4gIG91dFsxM10gPSB2WzFdO1xuICBvdXRbMTRdID0gdlsyXTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBtYXQ0IGZyb20gYSBkdWFsIHF1YXQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IE1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgRHVhbCBRdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVF1YXQyKG91dCwgYSkge1xuICB2YXIgdHJhbnNsYXRpb24gPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgdmFyIGJ4ID0gLWFbMF0sXG4gICAgICBieSA9IC1hWzFdLFxuICAgICAgYnogPSAtYVsyXSxcbiAgICAgIGJ3ID0gYVszXSxcbiAgICAgIGF4ID0gYVs0XSxcbiAgICAgIGF5ID0gYVs1XSxcbiAgICAgIGF6ID0gYVs2XSxcbiAgICAgIGF3ID0gYVs3XTtcbiAgdmFyIG1hZ25pdHVkZSA9IGJ4ICogYnggKyBieSAqIGJ5ICsgYnogKiBieiArIGJ3ICogYnc7IC8vT25seSBzY2FsZSBpZiBpdCBtYWtlcyBzZW5zZVxuXG4gIGlmIChtYWduaXR1ZGUgPiAwKSB7XG4gICAgdHJhbnNsYXRpb25bMF0gPSAoYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSkgKiAyIC8gbWFnbml0dWRlO1xuICAgIHRyYW5zbGF0aW9uWzFdID0gKGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnopICogMiAvIG1hZ25pdHVkZTtcbiAgICB0cmFuc2xhdGlvblsyXSA9IChheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4KSAqIDIgLyBtYWduaXR1ZGU7XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNsYXRpb25bMF0gPSAoYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSkgKiAyO1xuICAgIHRyYW5zbGF0aW9uWzFdID0gKGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnopICogMjtcbiAgICB0cmFuc2xhdGlvblsyXSA9IChheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4KSAqIDI7XG4gIH1cblxuICBmcm9tUm90YXRpb25UcmFuc2xhdGlvbihvdXQsIGEsIHRyYW5zbGF0aW9uKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB0cmFuc2xhdGlvbiB2ZWN0b3IgY29tcG9uZW50IG9mIGEgdHJhbnNmb3JtYXRpb25cclxuICogIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aCBmcm9tUm90YXRpb25UcmFuc2xhdGlvbixcclxuICogIHRoZSByZXR1cm5lZCB2ZWN0b3Igd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgdHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqICBvcmlnaW5hbGx5IHN1cHBsaWVkLlxyXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgVmVjdG9yIHRvIHJlY2VpdmUgdHJhbnNsYXRpb24gY29tcG9uZW50XHJcbiAqIEBwYXJhbSAge1JlYWRvbmx5TWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcclxuICogQHJldHVybiB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24ob3V0LCBtYXQpIHtcbiAgb3V0WzBdID0gbWF0WzEyXTtcbiAgb3V0WzFdID0gbWF0WzEzXTtcbiAgb3V0WzJdID0gbWF0WzE0XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzY2FsaW5nIGZhY3RvciBjb21wb25lbnQgb2YgYSB0cmFuc2Zvcm1hdGlvblxyXG4gKiAgbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVcclxuICogIHdpdGggYSBub3JtYWxpemVkIFF1YXRlcm5pb24gcGFyYW10ZXIsIHRoZSByZXR1cm5lZCB2ZWN0b3Igd2lsbCBiZVxyXG4gKiAgdGhlIHNhbWUgYXMgdGhlIHNjYWxpbmcgdmVjdG9yXHJcbiAqICBvcmlnaW5hbGx5IHN1cHBsaWVkLlxyXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgVmVjdG9yIHRvIHJlY2VpdmUgc2NhbGluZyBmYWN0b3IgY29tcG9uZW50XHJcbiAqIEBwYXJhbSAge1JlYWRvbmx5TWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcclxuICogQHJldHVybiB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NhbGluZyhvdXQsIG1hdCkge1xuICB2YXIgbTExID0gbWF0WzBdO1xuICB2YXIgbTEyID0gbWF0WzFdO1xuICB2YXIgbTEzID0gbWF0WzJdO1xuICB2YXIgbTIxID0gbWF0WzRdO1xuICB2YXIgbTIyID0gbWF0WzVdO1xuICB2YXIgbTIzID0gbWF0WzZdO1xuICB2YXIgbTMxID0gbWF0WzhdO1xuICB2YXIgbTMyID0gbWF0WzldO1xuICB2YXIgbTMzID0gbWF0WzEwXTtcbiAgb3V0WzBdID0gTWF0aC5oeXBvdChtMTEsIG0xMiwgbTEzKTtcbiAgb3V0WzFdID0gTWF0aC5oeXBvdChtMjEsIG0yMiwgbTIzKTtcbiAgb3V0WzJdID0gTWF0aC5oeXBvdChtMzEsIG0zMiwgbTMzKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgcXVhdGVybmlvbiByZXByZXNlbnRpbmcgdGhlIHJvdGF0aW9uYWwgY29tcG9uZW50XHJcbiAqICBvZiBhIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aFxyXG4gKiAgZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24sIHRoZSByZXR1cm5lZCBxdWF0ZXJuaW9uIHdpbGwgYmUgdGhlXHJcbiAqICBzYW1lIGFzIHRoZSBxdWF0ZXJuaW9uIG9yaWdpbmFsbHkgc3VwcGxpZWQuXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IFF1YXRlcm5pb24gdG8gcmVjZWl2ZSB0aGUgcm90YXRpb24gY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtYXQgTWF0cml4IHRvIGJlIGRlY29tcG9zZWQgKGlucHV0KVxyXG4gKiBAcmV0dXJuIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3RhdGlvbihvdXQsIG1hdCkge1xuICB2YXIgc2NhbGluZyA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBnZXRTY2FsaW5nKHNjYWxpbmcsIG1hdCk7XG4gIHZhciBpczEgPSAxIC8gc2NhbGluZ1swXTtcbiAgdmFyIGlzMiA9IDEgLyBzY2FsaW5nWzFdO1xuICB2YXIgaXMzID0gMSAvIHNjYWxpbmdbMl07XG4gIHZhciBzbTExID0gbWF0WzBdICogaXMxO1xuICB2YXIgc20xMiA9IG1hdFsxXSAqIGlzMjtcbiAgdmFyIHNtMTMgPSBtYXRbMl0gKiBpczM7XG4gIHZhciBzbTIxID0gbWF0WzRdICogaXMxO1xuICB2YXIgc20yMiA9IG1hdFs1XSAqIGlzMjtcbiAgdmFyIHNtMjMgPSBtYXRbNl0gKiBpczM7XG4gIHZhciBzbTMxID0gbWF0WzhdICogaXMxO1xuICB2YXIgc20zMiA9IG1hdFs5XSAqIGlzMjtcbiAgdmFyIHNtMzMgPSBtYXRbMTBdICogaXMzO1xuICB2YXIgdHJhY2UgPSBzbTExICsgc20yMiArIHNtMzM7XG4gIHZhciBTID0gMDtcblxuICBpZiAodHJhY2UgPiAwKSB7XG4gICAgUyA9IE1hdGguc3FydCh0cmFjZSArIDEuMCkgKiAyO1xuICAgIG91dFszXSA9IDAuMjUgKiBTO1xuICAgIG91dFswXSA9IChzbTIzIC0gc20zMikgLyBTO1xuICAgIG91dFsxXSA9IChzbTMxIC0gc20xMykgLyBTO1xuICAgIG91dFsyXSA9IChzbTEyIC0gc20yMSkgLyBTO1xuICB9IGVsc2UgaWYgKHNtMTEgPiBzbTIyICYmIHNtMTEgPiBzbTMzKSB7XG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBzbTExIC0gc20yMiAtIHNtMzMpICogMjtcbiAgICBvdXRbM10gPSAoc20yMyAtIHNtMzIpIC8gUztcbiAgICBvdXRbMF0gPSAwLjI1ICogUztcbiAgICBvdXRbMV0gPSAoc20xMiArIHNtMjEpIC8gUztcbiAgICBvdXRbMl0gPSAoc20zMSArIHNtMTMpIC8gUztcbiAgfSBlbHNlIGlmIChzbTIyID4gc20zMykge1xuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgc20yMiAtIHNtMTEgLSBzbTMzKSAqIDI7XG4gICAgb3V0WzNdID0gKHNtMzEgLSBzbTEzKSAvIFM7XG4gICAgb3V0WzBdID0gKHNtMTIgKyBzbTIxKSAvIFM7XG4gICAgb3V0WzFdID0gMC4yNSAqIFM7XG4gICAgb3V0WzJdID0gKHNtMjMgKyBzbTMyKSAvIFM7XG4gIH0gZWxzZSB7XG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBzbTMzIC0gc20xMSAtIHNtMjIpICogMjtcbiAgICBvdXRbM10gPSAoc20xMiAtIHNtMjEpIC8gUztcbiAgICBvdXRbMF0gPSAoc20zMSArIHNtMTMpIC8gUztcbiAgICBvdXRbMV0gPSAoc20yMyArIHNtMzIpIC8gUztcbiAgICBvdXRbMl0gPSAwLjI1ICogUztcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGVcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcclxuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcclxuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XHJcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIHNjYWxlKVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHMgU2NhbGluZyB2ZWN0b3JcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUob3V0LCBxLCB2LCBzKSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHh5ID0geCAqIHkyO1xuICB2YXIgeHogPSB4ICogejI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHl6ID0geSAqIHoyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIHZhciBzeCA9IHNbMF07XG4gIHZhciBzeSA9IHNbMV07XG4gIHZhciBzeiA9IHNbMl07XG4gIG91dFswXSA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuICBvdXRbMV0gPSAoeHkgKyB3eikgKiBzeDtcbiAgb3V0WzJdID0gKHh6IC0gd3kpICogc3g7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9ICh4eSAtIHd6KSAqIHN5O1xuICBvdXRbNV0gPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgb3V0WzZdID0gKHl6ICsgd3gpICogc3k7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9ICh4eiArIHd5KSAqIHN6O1xuICBvdXRbOV0gPSAoeXogLSB3eCkgKiBzejtcbiAgb3V0WzEwXSA9ICgxIC0gKHh4ICsgeXkpKSAqIHN6O1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF07XG4gIG91dFsxM10gPSB2WzFdO1xuICBvdXRbMTRdID0gdlsyXTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGUsIHJvdGF0aW5nIGFuZCBzY2FsaW5nIGFyb3VuZCB0aGUgZ2l2ZW4gb3JpZ2luXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XHJcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBvcmlnaW4pO1xyXG4gKiAgICAgbGV0IHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xyXG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xyXG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXHJcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBuZWdhdGl2ZU9yaWdpbik7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gcyBTY2FsaW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gbyBUaGUgb3JpZ2luIHZlY3RvciBhcm91bmQgd2hpY2ggdG8gc2NhbGUgYW5kIHJvdGF0ZVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbihvdXQsIHEsIHYsIHMsIG8pIHtcbiAgLy8gUXVhdGVybmlvbiBtYXRoXG4gIHZhciB4ID0gcVswXSxcbiAgICAgIHkgPSBxWzFdLFxuICAgICAgeiA9IHFbMl0sXG4gICAgICB3ID0gcVszXTtcbiAgdmFyIHgyID0geCArIHg7XG4gIHZhciB5MiA9IHkgKyB5O1xuICB2YXIgejIgPSB6ICsgejtcbiAgdmFyIHh4ID0geCAqIHgyO1xuICB2YXIgeHkgPSB4ICogeTI7XG4gIHZhciB4eiA9IHggKiB6MjtcbiAgdmFyIHl5ID0geSAqIHkyO1xuICB2YXIgeXogPSB5ICogejI7XG4gIHZhciB6eiA9IHogKiB6MjtcbiAgdmFyIHd4ID0gdyAqIHgyO1xuICB2YXIgd3kgPSB3ICogeTI7XG4gIHZhciB3eiA9IHcgKiB6MjtcbiAgdmFyIHN4ID0gc1swXTtcbiAgdmFyIHN5ID0gc1sxXTtcbiAgdmFyIHN6ID0gc1syXTtcbiAgdmFyIG94ID0gb1swXTtcbiAgdmFyIG95ID0gb1sxXTtcbiAgdmFyIG96ID0gb1syXTtcbiAgdmFyIG91dDAgPSAoMSAtICh5eSArIHp6KSkgKiBzeDtcbiAgdmFyIG91dDEgPSAoeHkgKyB3eikgKiBzeDtcbiAgdmFyIG91dDIgPSAoeHogLSB3eSkgKiBzeDtcbiAgdmFyIG91dDQgPSAoeHkgLSB3eikgKiBzeTtcbiAgdmFyIG91dDUgPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgdmFyIG91dDYgPSAoeXogKyB3eCkgKiBzeTtcbiAgdmFyIG91dDggPSAoeHogKyB3eSkgKiBzejtcbiAgdmFyIG91dDkgPSAoeXogLSB3eCkgKiBzejtcbiAgdmFyIG91dDEwID0gKDEgLSAoeHggKyB5eSkpICogc3o7XG4gIG91dFswXSA9IG91dDA7XG4gIG91dFsxXSA9IG91dDE7XG4gIG91dFsyXSA9IG91dDI7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IG91dDQ7XG4gIG91dFs1XSA9IG91dDU7XG4gIG91dFs2XSA9IG91dDY7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IG91dDg7XG4gIG91dFs5XSA9IG91dDk7XG4gIG91dFsxMF0gPSBvdXQxMDtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdICsgb3ggLSAob3V0MCAqIG94ICsgb3V0NCAqIG95ICsgb3V0OCAqIG96KTtcbiAgb3V0WzEzXSA9IHZbMV0gKyBveSAtIChvdXQxICogb3ggKyBvdXQ1ICogb3kgKyBvdXQ5ICogb3opO1xuICBvdXRbMTRdID0gdlsyXSArIG96IC0gKG91dDIgKiBveCArIG91dDYgKiBveSArIG91dDEwICogb3opO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGEgNHg0IG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cclxuICpcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21RdWF0KG91dCwgcSkge1xuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHl4ID0geSAqIHgyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB6eCA9IHogKiB4MjtcbiAgdmFyIHp5ID0geiAqIHkyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICBvdXRbMV0gPSB5eCArIHd6O1xuICBvdXRbMl0gPSB6eCAtIHd5O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB5eCAtIHd6O1xuICBvdXRbNV0gPSAxIC0geHggLSB6ejtcbiAgb3V0WzZdID0genkgKyB3eDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0genggKyB3eTtcbiAgb3V0WzldID0genkgLSB3eDtcbiAgb3V0WzEwXSA9IDEgLSB4eCAtIHl5O1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgZnJ1c3R1bSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtOdW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtOdW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJ1c3R1bShvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gIHZhciBybCA9IDEgLyAocmlnaHQgLSBsZWZ0KTtcbiAgdmFyIHRiID0gMSAvICh0b3AgLSBib3R0b20pO1xuICB2YXIgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMF0gPSBuZWFyICogMiAqIHJsO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSBuZWFyICogMiAqIHRiO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAocmlnaHQgKyBsZWZ0KSAqIHJsO1xuICBvdXRbOV0gPSAodG9wICsgYm90dG9tKSAqIHRiO1xuICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gIG91dFsxMV0gPSAtMTtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gZmFyICogbmVhciAqIDIgKiBuZjtcbiAgb3V0WzE1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzLlxyXG4gKiBQYXNzaW5nIG51bGwvdW5kZWZpbmVkL25vIHZhbHVlIGZvciBmYXIgd2lsbCBnZW5lcmF0ZSBpbmZpbml0ZSBwcm9qZWN0aW9uIG1hdHJpeC5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge251bWJlcn0gZm92eSBWZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IGluIHJhZGlhbnNcclxuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcclxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bSwgY2FuIGJlIG51bGwgb3IgSW5maW5pdHlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBlcnNwZWN0aXZlKG91dCwgZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcbiAgdmFyIGYgPSAxLjAgLyBNYXRoLnRhbihmb3Z5IC8gMiksXG4gICAgICBuZjtcbiAgb3V0WzBdID0gZiAvIGFzcGVjdDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gZjtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzExXSA9IC0xO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNV0gPSAwO1xuXG4gIGlmIChmYXIgIT0gbnVsbCAmJiBmYXIgIT09IEluZmluaXR5KSB7XG4gICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTRdID0gMiAqIGZhciAqIG5lYXIgKiBuZjtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMTBdID0gLTE7XG4gICAgb3V0WzE0XSA9IC0yICogbmVhcjtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZmllbGQgb2Ygdmlldy5cclxuICogVGhpcyBpcyBwcmltYXJpbHkgdXNlZnVsIGZvciBnZW5lcmF0aW5nIHByb2plY3Rpb24gbWF0cmljZXMgdG8gYmUgdXNlZFxyXG4gKiB3aXRoIHRoZSBzdGlsbCBleHBlcmllbWVudGFsIFdlYlZSIEFQSS5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge09iamVjdH0gZm92IE9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgdmFsdWVzOiB1cERlZ3JlZXMsIGRvd25EZWdyZWVzLCBsZWZ0RGVncmVlcywgcmlnaHREZWdyZWVzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3KG91dCwgZm92LCBuZWFyLCBmYXIpIHtcbiAgdmFyIHVwVGFuID0gTWF0aC50YW4oZm92LnVwRGVncmVlcyAqIE1hdGguUEkgLyAxODAuMCk7XG4gIHZhciBkb3duVGFuID0gTWF0aC50YW4oZm92LmRvd25EZWdyZWVzICogTWF0aC5QSSAvIDE4MC4wKTtcbiAgdmFyIGxlZnRUYW4gPSBNYXRoLnRhbihmb3YubGVmdERlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLjApO1xuICB2YXIgcmlnaHRUYW4gPSBNYXRoLnRhbihmb3YucmlnaHREZWdyZWVzICogTWF0aC5QSSAvIDE4MC4wKTtcbiAgdmFyIHhTY2FsZSA9IDIuMCAvIChsZWZ0VGFuICsgcmlnaHRUYW4pO1xuICB2YXIgeVNjYWxlID0gMi4wIC8gKHVwVGFuICsgZG93blRhbik7XG4gIG91dFswXSA9IHhTY2FsZTtcbiAgb3V0WzFdID0gMC4wO1xuICBvdXRbMl0gPSAwLjA7XG4gIG91dFszXSA9IDAuMDtcbiAgb3V0WzRdID0gMC4wO1xuICBvdXRbNV0gPSB5U2NhbGU7XG4gIG91dFs2XSA9IDAuMDtcbiAgb3V0WzddID0gMC4wO1xuICBvdXRbOF0gPSAtKChsZWZ0VGFuIC0gcmlnaHRUYW4pICogeFNjYWxlICogMC41KTtcbiAgb3V0WzldID0gKHVwVGFuIC0gZG93blRhbikgKiB5U2NhbGUgKiAwLjU7XG4gIG91dFsxMF0gPSBmYXIgLyAobmVhciAtIGZhcik7XG4gIG91dFsxMV0gPSAtMS4wO1xuICBvdXRbMTJdID0gMC4wO1xuICBvdXRbMTNdID0gMC4wO1xuICBvdXRbMTRdID0gZmFyICogbmVhciAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzE1XSA9IDAuMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBvcnRob2dvbmFsIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG9ydGhvKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgdmFyIGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpO1xuICB2YXIgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCk7XG4gIHZhciBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gIG91dFswXSA9IC0yICogbHI7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IC0yICogYnQ7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAyICogbmY7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gKGxlZnQgKyByaWdodCkgKiBscjtcbiAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG4gIG91dFsxNF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgbG9vay1hdCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZXllIHBvc2l0aW9uLCBmb2NhbCBwb2ludCwgYW5kIHVwIGF4aXMuXHJcbiAqIElmIHlvdSB3YW50IGEgbWF0cml4IHRoYXQgYWN0dWFsbHkgbWFrZXMgYW4gb2JqZWN0IGxvb2sgYXQgYW5vdGhlciBvYmplY3QsIHlvdSBzaG91bGQgdXNlIHRhcmdldFRvIGluc3RlYWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBjZW50ZXIgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB1cCB2ZWMzIHBvaW50aW5nIHVwXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsb29rQXQob3V0LCBleWUsIGNlbnRlciwgdXApIHtcbiAgdmFyIHgwLCB4MSwgeDIsIHkwLCB5MSwgeTIsIHowLCB6MSwgejIsIGxlbjtcbiAgdmFyIGV5ZXggPSBleWVbMF07XG4gIHZhciBleWV5ID0gZXllWzFdO1xuICB2YXIgZXlleiA9IGV5ZVsyXTtcbiAgdmFyIHVweCA9IHVwWzBdO1xuICB2YXIgdXB5ID0gdXBbMV07XG4gIHZhciB1cHogPSB1cFsyXTtcbiAgdmFyIGNlbnRlcnggPSBjZW50ZXJbMF07XG4gIHZhciBjZW50ZXJ5ID0gY2VudGVyWzFdO1xuICB2YXIgY2VudGVyeiA9IGNlbnRlclsyXTtcblxuICBpZiAoTWF0aC5hYnMoZXlleCAtIGNlbnRlcngpIDwgZ2xNYXRyaXguRVBTSUxPTiAmJiBNYXRoLmFicyhleWV5IC0gY2VudGVyeSkgPCBnbE1hdHJpeC5FUFNJTE9OICYmIE1hdGguYWJzKGV5ZXogLSBjZW50ZXJ6KSA8IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICByZXR1cm4gaWRlbnRpdHkob3V0KTtcbiAgfVxuXG4gIHowID0gZXlleCAtIGNlbnRlcng7XG4gIHoxID0gZXlleSAtIGNlbnRlcnk7XG4gIHoyID0gZXlleiAtIGNlbnRlcno7XG4gIGxlbiA9IDEgLyBNYXRoLmh5cG90KHowLCB6MSwgejIpO1xuICB6MCAqPSBsZW47XG4gIHoxICo9IGxlbjtcbiAgejIgKj0gbGVuO1xuICB4MCA9IHVweSAqIHoyIC0gdXB6ICogejE7XG4gIHgxID0gdXB6ICogejAgLSB1cHggKiB6MjtcbiAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICBsZW4gPSBNYXRoLmh5cG90KHgwLCB4MSwgeDIpO1xuXG4gIGlmICghbGVuKSB7XG4gICAgeDAgPSAwO1xuICAgIHgxID0gMDtcbiAgICB4MiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB4MCAqPSBsZW47XG4gICAgeDEgKj0gbGVuO1xuICAgIHgyICo9IGxlbjtcbiAgfVxuXG4gIHkwID0gejEgKiB4MiAtIHoyICogeDE7XG4gIHkxID0gejIgKiB4MCAtIHowICogeDI7XG4gIHkyID0gejAgKiB4MSAtIHoxICogeDA7XG4gIGxlbiA9IE1hdGguaHlwb3QoeTAsIHkxLCB5Mik7XG5cbiAgaWYgKCFsZW4pIHtcbiAgICB5MCA9IDA7XG4gICAgeTEgPSAwO1xuICAgIHkyID0gMDtcbiAgfSBlbHNlIHtcbiAgICBsZW4gPSAxIC8gbGVuO1xuICAgIHkwICo9IGxlbjtcbiAgICB5MSAqPSBsZW47XG4gICAgeTIgKj0gbGVuO1xuICB9XG5cbiAgb3V0WzBdID0geDA7XG4gIG91dFsxXSA9IHkwO1xuICBvdXRbMl0gPSB6MDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0geDE7XG4gIG91dFs1XSA9IHkxO1xuICBvdXRbNl0gPSB6MTtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0geDI7XG4gIG91dFs5XSA9IHkyO1xuICBvdXRbMTBdID0gejI7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gLSh4MCAqIGV5ZXggKyB4MSAqIGV5ZXkgKyB4MiAqIGV5ZXopO1xuICBvdXRbMTNdID0gLSh5MCAqIGV5ZXggKyB5MSAqIGV5ZXkgKyB5MiAqIGV5ZXopO1xuICBvdXRbMTRdID0gLSh6MCAqIGV5ZXggKyB6MSAqIGV5ZXkgKyB6MiAqIGV5ZXopO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBtYXRyaXggdGhhdCBtYWtlcyBzb21ldGhpbmcgbG9vayBhdCBzb21ldGhpbmcgZWxzZS5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gZXllIFBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGNlbnRlciBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHVwIHZlYzMgcG9pbnRpbmcgdXBcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRhcmdldFRvKG91dCwgZXllLCB0YXJnZXQsIHVwKSB7XG4gIHZhciBleWV4ID0gZXllWzBdLFxuICAgICAgZXlleSA9IGV5ZVsxXSxcbiAgICAgIGV5ZXogPSBleWVbMl0sXG4gICAgICB1cHggPSB1cFswXSxcbiAgICAgIHVweSA9IHVwWzFdLFxuICAgICAgdXB6ID0gdXBbMl07XG4gIHZhciB6MCA9IGV5ZXggLSB0YXJnZXRbMF0sXG4gICAgICB6MSA9IGV5ZXkgLSB0YXJnZXRbMV0sXG4gICAgICB6MiA9IGV5ZXogLSB0YXJnZXRbMl07XG4gIHZhciBsZW4gPSB6MCAqIHowICsgejEgKiB6MSArIHoyICogejI7XG5cbiAgaWYgKGxlbiA+IDApIHtcbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgejAgKj0gbGVuO1xuICAgIHoxICo9IGxlbjtcbiAgICB6MiAqPSBsZW47XG4gIH1cblxuICB2YXIgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxLFxuICAgICAgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyLFxuICAgICAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICBsZW4gPSB4MCAqIHgwICsgeDEgKiB4MSArIHgyICogeDI7XG5cbiAgaWYgKGxlbiA+IDApIHtcbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgeDAgKj0gbGVuO1xuICAgIHgxICo9IGxlbjtcbiAgICB4MiAqPSBsZW47XG4gIH1cblxuICBvdXRbMF0gPSB4MDtcbiAgb3V0WzFdID0geDE7XG4gIG91dFsyXSA9IHgyO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgb3V0WzVdID0gejIgKiB4MCAtIHowICogeDI7XG4gIG91dFs2XSA9IHowICogeDEgLSB6MSAqIHgwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB6MDtcbiAgb3V0WzldID0gejE7XG4gIG91dFsxMF0gPSB6MjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSBleWV4O1xuICBvdXRbMTNdID0gZXlleTtcbiAgb3V0WzE0XSA9IGV5ZXo7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJtYXQ0KFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIsIFwiICsgYVszXSArIFwiLCBcIiArIGFbNF0gKyBcIiwgXCIgKyBhWzVdICsgXCIsIFwiICsgYVs2XSArIFwiLCBcIiArIGFbN10gKyBcIiwgXCIgKyBhWzhdICsgXCIsIFwiICsgYVs5XSArIFwiLCBcIiArIGFbMTBdICsgXCIsIFwiICsgYVsxMV0gKyBcIiwgXCIgKyBhWzEyXSArIFwiLCBcIiArIGFbMTNdICsgXCIsIFwiICsgYVsxNF0gKyBcIiwgXCIgKyBhWzE1XSArIFwiKVwiO1xufVxuLyoqXHJcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybiBNYXRoLmh5cG90KGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0sIGFbNl0sIGFbN10sIGFbOF0sIGFbOV0sIGFbMTBdLCBhWzExXSwgYVsxMl0sIGFbMTNdLCBhWzE0XSwgYVsxNV0pO1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl07XG4gIG91dFs3XSA9IGFbN10gKyBiWzddO1xuICBvdXRbOF0gPSBhWzhdICsgYls4XTtcbiAgb3V0WzldID0gYVs5XSArIGJbOV07XG4gIG91dFsxMF0gPSBhWzEwXSArIGJbMTBdO1xuICBvdXRbMTFdID0gYVsxMV0gKyBiWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdICsgYlsxMl07XG4gIG91dFsxM10gPSBhWzEzXSArIGJbMTNdO1xuICBvdXRbMTRdID0gYVsxNF0gKyBiWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdICsgYlsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgb3V0WzZdID0gYVs2XSAtIGJbNl07XG4gIG91dFs3XSA9IGFbN10gLSBiWzddO1xuICBvdXRbOF0gPSBhWzhdIC0gYls4XTtcbiAgb3V0WzldID0gYVs5XSAtIGJbOV07XG4gIG91dFsxMF0gPSBhWzEwXSAtIGJbMTBdO1xuICBvdXRbMTFdID0gYVsxMV0gLSBiWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdIC0gYlsxMl07XG4gIG91dFsxM10gPSBhWzEzXSAtIGJbMTNdO1xuICBvdXRbMTRdID0gYVsxNF0gLSBiWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdIC0gYlsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIG91dFs2XSA9IGFbNl0gKiBiO1xuICBvdXRbN10gPSBhWzddICogYjtcbiAgb3V0WzhdID0gYVs4XSAqIGI7XG4gIG91dFs5XSA9IGFbOV0gKiBiO1xuICBvdXRbMTBdID0gYVsxMF0gKiBiO1xuICBvdXRbMTFdID0gYVsxMV0gKiBiO1xuICBvdXRbMTJdID0gYVsxMl0gKiBiO1xuICBvdXRbMTNdID0gYVsxM10gKiBiO1xuICBvdXRbMTRdID0gYVsxNF0gKiBiO1xuICBvdXRbMTVdID0gYVsxNV0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDQncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF0gKiBzY2FsZTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV0gKiBzY2FsZTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl0gKiBzY2FsZTtcbiAgb3V0WzddID0gYVs3XSArIGJbN10gKiBzY2FsZTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF0gKiBzY2FsZTtcbiAgb3V0WzldID0gYVs5XSArIGJbOV0gKiBzY2FsZTtcbiAgb3V0WzEwXSA9IGFbMTBdICsgYlsxMF0gKiBzY2FsZTtcbiAgb3V0WzExXSA9IGFbMTFdICsgYlsxMV0gKiBzY2FsZTtcbiAgb3V0WzEyXSA9IGFbMTJdICsgYlsxMl0gKiBzY2FsZTtcbiAgb3V0WzEzXSA9IGFbMTNdICsgYlsxM10gKiBzY2FsZTtcbiAgb3V0WzE0XSA9IGFbMTRdICsgYlsxNF0gKiBzY2FsZTtcbiAgb3V0WzE1XSA9IGFbMTVdICsgYlsxNV0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXSAmJiBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV0gJiYgYVs2XSA9PT0gYls2XSAmJiBhWzddID09PSBiWzddICYmIGFbOF0gPT09IGJbOF0gJiYgYVs5XSA9PT0gYls5XSAmJiBhWzEwXSA9PT0gYlsxMF0gJiYgYVsxMV0gPT09IGJbMTFdICYmIGFbMTJdID09PSBiWzEyXSAmJiBhWzEzXSA9PT0gYlsxM10gJiYgYVsxNF0gPT09IGJbMTRdICYmIGFbMTVdID09PSBiWzE1XTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTtcbiAgdmFyIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XSxcbiAgICAgIGE2ID0gYVs2XSxcbiAgICAgIGE3ID0gYVs3XTtcbiAgdmFyIGE4ID0gYVs4XSxcbiAgICAgIGE5ID0gYVs5XSxcbiAgICAgIGExMCA9IGFbMTBdLFxuICAgICAgYTExID0gYVsxMV07XG4gIHZhciBhMTIgPSBhWzEyXSxcbiAgICAgIGExMyA9IGFbMTNdLFxuICAgICAgYTE0ID0gYVsxNF0sXG4gICAgICBhMTUgPSBhWzE1XTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgdmFyIGI0ID0gYls0XSxcbiAgICAgIGI1ID0gYls1XSxcbiAgICAgIGI2ID0gYls2XSxcbiAgICAgIGI3ID0gYls3XTtcbiAgdmFyIGI4ID0gYls4XSxcbiAgICAgIGI5ID0gYls5XSxcbiAgICAgIGIxMCA9IGJbMTBdLFxuICAgICAgYjExID0gYlsxMV07XG4gIHZhciBiMTIgPSBiWzEyXSxcbiAgICAgIGIxMyA9IGJbMTNdLFxuICAgICAgYjE0ID0gYlsxNF0sXG4gICAgICBiMTUgPSBiWzE1XTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSAmJiBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiYgTWF0aC5hYnMoYTUgLSBiNSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpICYmIE1hdGguYWJzKGE2IC0gYjYpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE2KSwgTWF0aC5hYnMoYjYpKSAmJiBNYXRoLmFicyhhNyAtIGI3KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNyksIE1hdGguYWJzKGI3KSkgJiYgTWF0aC5hYnMoYTggLSBiOCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTgpLCBNYXRoLmFicyhiOCkpICYmIE1hdGguYWJzKGE5IC0gYjkpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE5KSwgTWF0aC5hYnMoYjkpKSAmJiBNYXRoLmFicyhhMTAgLSBiMTApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMCksIE1hdGguYWJzKGIxMCkpICYmIE1hdGguYWJzKGExMSAtIGIxMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTExKSwgTWF0aC5hYnMoYjExKSkgJiYgTWF0aC5hYnMoYTEyIC0gYjEyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTIpLCBNYXRoLmFicyhiMTIpKSAmJiBNYXRoLmFicyhhMTMgLSBiMTMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMyksIE1hdGguYWJzKGIxMykpICYmIE1hdGguYWJzKGExNCAtIGIxNCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTE0KSwgTWF0aC5hYnMoYjE0KSkgJiYgTWF0aC5hYnMoYTE1IC0gYjE1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTUpLCBNYXRoLmFicyhiMTUpKTtcbn1cbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDsiLCJleHBvcnQgZnVuY3Rpb24gcmFuZG9tU2VlZCgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMiAqKiAzMSk7XG59XG5leHBvcnQgY2xhc3MgUmFuZG9tIHtcbiAgICBjb25zdHJ1Y3RvcihzZWVkKSB7XG4gICAgICAgIHRoaXMuc2VlZCA9IHNlZWQ7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAoKDIgKiogMzEgLSAxKSAmICh0aGlzLnNlZWQgPSBNYXRoLmltdWwoNDgyNzEsIHRoaXMuc2VlZCkpKSAvIDIgKiogMzE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8vIFRoaXMgZmlsZSByZXBsYWNlcyBgaW5kZXguanNgIGluIGJ1bmRsZXJzIGxpa2Ugd2VicGFjayBvciBSb2xsdXAsXG4vLyBhY2NvcmRpbmcgdG8gYGJyb3dzZXJgIGNvbmZpZyBpbiBgcGFja2FnZS5qc29uYC5cblxuaW1wb3J0IHsgdXJsQWxwaGFiZXQgfSBmcm9tICcuL3VybC1hbHBoYWJldC9pbmRleC5qcydcblxuaWYgKGZhbHNlKSB7XG4gIC8vIEFsbCBidW5kbGVycyB3aWxsIHJlbW92ZSB0aGlzIGJsb2NrIGluIHRoZSBwcm9kdWN0aW9uIGJ1bmRsZS5cbiAgaWYgKFxuICAgIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScgJiZcbiAgICB0eXBlb2YgY3J5cHRvID09PSAndW5kZWZpbmVkJ1xuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnUmVhY3QgTmF0aXZlIGRvZXMgbm90IGhhdmUgYSBidWlsdC1pbiBzZWN1cmUgcmFuZG9tIGdlbmVyYXRvci4gJyArXG4gICAgICAgICdJZiB5b3UgZG9u4oCZdCBuZWVkIHVucHJlZGljdGFibGUgSURzIHVzZSBgbmFub2lkL25vbi1zZWN1cmVgLiAnICtcbiAgICAgICAgJ0ZvciBzZWN1cmUgSURzLCBpbXBvcnQgYHJlYWN0LW5hdGl2ZS1nZXQtcmFuZG9tLXZhbHVlc2AgJyArXG4gICAgICAgICdiZWZvcmUgTmFubyBJRC4nXG4gICAgKVxuICB9XG4gIGlmICh0eXBlb2YgbXNDcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjcnlwdG8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0ltcG9ydCBmaWxlIHdpdGggYGlmICghd2luZG93LmNyeXB0bykgd2luZG93LmNyeXB0byA9IHdpbmRvdy5tc0NyeXB0b2AnICtcbiAgICAgICAgJyBiZWZvcmUgaW1wb3J0aW5nIE5hbm8gSUQgdG8gZml4IElFIDExIHN1cHBvcnQnXG4gICAgKVxuICB9XG4gIGlmICh0eXBlb2YgY3J5cHRvID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdZb3VyIGJyb3dzZXIgZG9lcyBub3QgaGF2ZSBzZWN1cmUgcmFuZG9tIGdlbmVyYXRvci4gJyArXG4gICAgICAgICdJZiB5b3UgZG9u4oCZdCBuZWVkIHVucHJlZGljdGFibGUgSURzLCB5b3UgY2FuIHVzZSBuYW5vaWQvbm9uLXNlY3VyZS4nXG4gICAgKVxuICB9XG59XG5cbmxldCByYW5kb20gPSBieXRlcyA9PiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzKSlcblxubGV0IGN1c3RvbVJhbmRvbSA9IChhbHBoYWJldCwgc2l6ZSwgZ2V0UmFuZG9tKSA9PiB7XG4gIC8vIEZpcnN0LCBhIGJpdG1hc2sgaXMgbmVjZXNzYXJ5IHRvIGdlbmVyYXRlIHRoZSBJRC4gVGhlIGJpdG1hc2sgbWFrZXMgYnl0ZXNcbiAgLy8gdmFsdWVzIGNsb3NlciB0byB0aGUgYWxwaGFiZXQgc2l6ZS4gVGhlIGJpdG1hc2sgY2FsY3VsYXRlcyB0aGUgY2xvc2VzdFxuICAvLyBgMl4zMSAtIDFgIG51bWJlciwgd2hpY2ggZXhjZWVkcyB0aGUgYWxwaGFiZXQgc2l6ZS5cbiAgLy8gRm9yIGV4YW1wbGUsIHRoZSBiaXRtYXNrIGZvciB0aGUgYWxwaGFiZXQgc2l6ZSAzMCBpcyAzMSAoMDAwMTExMTEpLlxuICAvLyBgTWF0aC5jbHozMmAgaXMgbm90IHVzZWQsIGJlY2F1c2UgaXQgaXMgbm90IGF2YWlsYWJsZSBpbiBicm93c2Vycy5cbiAgbGV0IG1hc2sgPSAoMiA8PCAoTWF0aC5sb2coYWxwaGFiZXQubGVuZ3RoIC0gMSkgLyBNYXRoLkxOMikpIC0gMVxuICAvLyBUaG91Z2gsIHRoZSBiaXRtYXNrIHNvbHV0aW9uIGlzIG5vdCBwZXJmZWN0IHNpbmNlIHRoZSBieXRlcyBleGNlZWRpbmdcbiAgLy8gdGhlIGFscGhhYmV0IHNpemUgYXJlIHJlZnVzZWQuIFRoZXJlZm9yZSwgdG8gcmVsaWFibHkgZ2VuZXJhdGUgdGhlIElELFxuICAvLyB0aGUgcmFuZG9tIGJ5dGVzIHJlZHVuZGFuY3kgaGFzIHRvIGJlIHNhdGlzZmllZC5cblxuICAvLyBOb3RlOiBldmVyeSBoYXJkd2FyZSByYW5kb20gZ2VuZXJhdG9yIGNhbGwgaXMgcGVyZm9ybWFuY2UgZXhwZW5zaXZlLFxuICAvLyBiZWNhdXNlIHRoZSBzeXN0ZW0gY2FsbCBmb3IgZW50cm9weSBjb2xsZWN0aW9uIHRha2VzIGEgbG90IG9mIHRpbWUuXG4gIC8vIFNvLCB0byBhdm9pZCBhZGRpdGlvbmFsIHN5c3RlbSBjYWxscywgZXh0cmEgYnl0ZXMgYXJlIHJlcXVlc3RlZCBpbiBhZHZhbmNlLlxuXG4gIC8vIE5leHQsIGEgc3RlcCBkZXRlcm1pbmVzIGhvdyBtYW55IHJhbmRvbSBieXRlcyB0byBnZW5lcmF0ZS5cbiAgLy8gVGhlIG51bWJlciBvZiByYW5kb20gYnl0ZXMgZ2V0cyBkZWNpZGVkIHVwb24gdGhlIElEIHNpemUsIG1hc2ssXG4gIC8vIGFscGhhYmV0IHNpemUsIGFuZCBtYWdpYyBudW1iZXIgMS42ICh1c2luZyAxLjYgcGVha3MgYXQgcGVyZm9ybWFuY2VcbiAgLy8gYWNjb3JkaW5nIHRvIGJlbmNobWFya3MpLlxuXG4gIC8vIGAtfmYgPT4gTWF0aC5jZWlsKGYpYCBpZiBmIGlzIGEgZmxvYXRcbiAgLy8gYC1+aSA9PiBpICsgMWAgaWYgaSBpcyBhbiBpbnRlZ2VyXG4gIGxldCBzdGVwID0gLX4oKDEuNiAqIG1hc2sgKiBzaXplKSAvIGFscGhhYmV0Lmxlbmd0aClcblxuICByZXR1cm4gKCkgPT4ge1xuICAgIGxldCBpZCA9ICcnXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGxldCBieXRlcyA9IGdldFJhbmRvbShzdGVwKVxuICAgICAgLy8gQSBjb21wYWN0IGFsdGVybmF0aXZlIGZvciBgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGVwOyBpKyspYC5cbiAgICAgIGxldCBqID0gc3RlcFxuICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICAvLyBBZGRpbmcgYHx8ICcnYCByZWZ1c2VzIGEgcmFuZG9tIGJ5dGUgdGhhdCBleGNlZWRzIHRoZSBhbHBoYWJldCBzaXplLlxuICAgICAgICBpZCArPSBhbHBoYWJldFtieXRlc1tqXSAmIG1hc2tdIHx8ICcnXG4gICAgICAgIGlmIChpZC5sZW5ndGggPT09IHNpemUpIHJldHVybiBpZFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5sZXQgY3VzdG9tQWxwaGFiZXQgPSAoYWxwaGFiZXQsIHNpemUpID0+IGN1c3RvbVJhbmRvbShhbHBoYWJldCwgc2l6ZSwgcmFuZG9tKVxuXG5sZXQgbmFub2lkID0gKHNpemUgPSAyMSkgPT4ge1xuICBsZXQgaWQgPSAnJ1xuICBsZXQgYnl0ZXMgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KHNpemUpKVxuXG4gIC8vIEEgY29tcGFjdCBhbHRlcm5hdGl2ZSBmb3IgYGZvciAodmFyIGkgPSAwOyBpIDwgc3RlcDsgaSsrKWAuXG4gIHdoaWxlIChzaXplLS0pIHtcbiAgICAvLyBJdCBpcyBpbmNvcnJlY3QgdG8gdXNlIGJ5dGVzIGV4Y2VlZGluZyB0aGUgYWxwaGFiZXQgc2l6ZS5cbiAgICAvLyBUaGUgZm9sbG93aW5nIG1hc2sgcmVkdWNlcyB0aGUgcmFuZG9tIGJ5dGUgaW4gdGhlIDAtMjU1IHZhbHVlXG4gICAgLy8gcmFuZ2UgdG8gdGhlIDAtNjMgdmFsdWUgcmFuZ2UuIFRoZXJlZm9yZSwgYWRkaW5nIGhhY2tzLCBzdWNoXG4gICAgLy8gYXMgZW1wdHkgc3RyaW5nIGZhbGxiYWNrIG9yIG1hZ2ljIG51bWJlcnMsIGlzIHVubmVjY2Vzc2FyeSBiZWNhdXNlXG4gICAgLy8gdGhlIGJpdG1hc2sgdHJpbXMgYnl0ZXMgZG93biB0byB0aGUgYWxwaGFiZXQgc2l6ZS5cbiAgICBsZXQgYnl0ZSA9IGJ5dGVzW3NpemVdICYgNjNcbiAgICBpZiAoYnl0ZSA8IDM2KSB7XG4gICAgICAvLyBgMC05YS16YFxuICAgICAgaWQgKz0gYnl0ZS50b1N0cmluZygzNilcbiAgICB9IGVsc2UgaWYgKGJ5dGUgPCA2Mikge1xuICAgICAgLy8gYEEtWmBcbiAgICAgIGlkICs9IChieXRlIC0gMjYpLnRvU3RyaW5nKDM2KS50b1VwcGVyQ2FzZSgpXG4gICAgfSBlbHNlIGlmIChieXRlIDwgNjMpIHtcbiAgICAgIGlkICs9ICdfJ1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCArPSAnLSdcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlkXG59XG5cbmV4cG9ydCB7IG5hbm9pZCwgY3VzdG9tQWxwaGFiZXQsIGN1c3RvbVJhbmRvbSwgdXJsQWxwaGFiZXQsIHJhbmRvbSB9XG4iLCJpbXBvcnQgeyBSYW5kb20gfSBmcm9tIFwicm91Z2hqcy9iaW4vbWF0aFwiO1xuaW1wb3J0IHsgbmFub2lkIH0gZnJvbSBcIm5hbm9pZFwiO1xuaW1wb3J0IHsgUG9pbnQgfSBmcm9tIFwiLi9lbGVtZW50cy9FeGNhbGlkcmF3RWxlbWVudFwiO1xuXG5jb25zdCByYW5kb20gPSBuZXcgUmFuZG9tKERhdGUubm93KCkpO1xuXG5leHBvcnQgY29uc3QgcmFuZG9tSW50ZWdlciA9ICgpOiBudW1iZXIgPT4gTWF0aC5mbG9vcihyYW5kb20ubmV4dCgpICogMiAqKiAzMSk7XG5cbmV4cG9ydCBjb25zdCByYW5kb21JZCA9ICgpOiBzdHJpbmcgPT4gbmFub2lkKCk7XG5cbmV4cG9ydCBjb25zdCBzYWZlTnVtYmVyID0gKG51bWJlcjogbnVtYmVyKTogbnVtYmVyID0+IE51bWJlcihudW1iZXIudG9GaXhlZCgyKSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBkaW1lbnNpb25zRnJvbVBvaW50cyhwb2ludHM6IG51bWJlcltdW10pOiBudW1iZXJbXSB7XG4gIGNvbnN0IHhDb29yZHMgPSBwb2ludHMubWFwKChbeF0pID0+IHgpO1xuICBjb25zdCB5Q29vcmRzID0gcG9pbnRzLm1hcCgoWywgeV0pID0+IHkpO1xuXG4gIGNvbnN0IG1pblggPSBNYXRoLm1pbiguLi54Q29vcmRzKTtcbiAgY29uc3QgbWluWSA9IE1hdGgubWluKC4uLnlDb29yZHMpO1xuICBjb25zdCBtYXhYID0gTWF0aC5tYXgoLi4ueENvb3Jkcyk7XG4gIGNvbnN0IG1heFkgPSBNYXRoLm1heCguLi55Q29vcmRzKTtcblxuICByZXR1cm4gW21heFggLSBtaW5YLCBtYXhZIC0gbWluWV07XG59XG5cbi8vIHdpbmRpbmcgb3JkZXIgaXMgY2xvY2t3aXNlIHZhbHVlcyBpcyBwb3NpdGl2ZSwgY291bnRlciBjbG9ja3dpc2UgaWYgbmVnYXRpdmUuXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2luZGluZ09yZGVyKFxuICBwb2ludHM6IFBvaW50W10sXG4pOiBcImNsb2Nrd2lzZVwiIHwgXCJjb3VudGVyY2xvY2t3aXNlXCIge1xuICBjb25zdCB0b3RhbCA9IHBvaW50cy5yZWR1Y2UoKGFjYywgW3gxLCB5MV0sIGlkeCwgYXJyKSA9PiB7XG4gICAgY29uc3QgcDIgPSBhcnJbaWR4ICsgMV07XG4gICAgY29uc3QgeDIgPSBwMiA/IHAyWzBdIDogMDtcbiAgICBjb25zdCB5MiA9IHAyID8gcDJbMV0gOiAwO1xuXG4gICAgY29uc3QgZSA9ICh4MiAtIHgxKSAqICh5MiArIHkxKTtcblxuICAgIHJldHVybiBlICsgYWNjO1xuICB9LCAwKTtcblxuICByZXR1cm4gdG90YWwgPiAwID8gXCJjbG9ja3dpc2VcIiA6IFwiY291bnRlcmNsb2Nrd2lzZVwiO1xufVxuIiwiaW1wb3J0IGNocm9tYSBmcm9tIFwiY2hyb21hLWpzXCI7XG5pbXBvcnQgeyBFeGNhbGlkcmF3RWxlbWVudEJhc2UgfSBmcm9tIFwiLi9lbGVtZW50cy9FeGNhbGlkcmF3RWxlbWVudFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gaGV4V2l0aEFscGhhKGNvbG9yOiBzdHJpbmcsIGFscGhhOiBudW1iZXIpOiBzdHJpbmcge1xuICByZXR1cm4gY2hyb21hKGNvbG9yKS5hbHBoYShhbHBoYSkuY3NzKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXMoZWw6IEVsZW1lbnQsIGF0dHI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gZWwuaGFzQXR0cmlidXRlKGF0dHIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0KGVsOiBFbGVtZW50LCBhdHRyOiBzdHJpbmcsIGJhY2t1cD86IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoYXR0cikgfHwgYmFja3VwIHx8IFwiXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROdW0oZWw6IEVsZW1lbnQsIGF0dHI6IHN0cmluZywgYmFja3VwPzogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgbnVtVmFsID0gTnVtYmVyKGdldChlbCwgYXR0cikpO1xuICByZXR1cm4gbnVtVmFsID09PSBOYU4gPyBiYWNrdXAgfHwgMCA6IG51bVZhbDtcbn1cblxuY29uc3QgcHJlc0F0dHJzID0ge1xuICBzdHJva2U6IFwic3Ryb2tlXCIsXG4gIFwic3Ryb2tlLW9wYWNpdHlcIjogXCJzdHJva2Utb3BhY2l0eVwiLFxuICBcInN0cm9rZS13aWR0aFwiOiBcInN0cm9rZS13aWR0aFwiLFxuICBmaWxsOiBcImZpbGxcIixcbiAgXCJmaWxsLW9wYWNpdHlcIjogXCJmaWxsLW9wYWNpdHlcIixcbiAgb3BhY2l0eTogXCJvcGFjaXR5XCIsXG59IGFzIGNvbnN0O1xuXG50eXBlIEV4UGFydGlhbEVsZW1lbnQgPSBQYXJ0aWFsPEV4Y2FsaWRyYXdFbGVtZW50QmFzZT47XG5cbnR5cGUgQXR0ckhhbmRsZXJBcmdzID0ge1xuICBlbDogRWxlbWVudDtcbiAgZXhWYWxzOiBFeFBhcnRpYWxFbGVtZW50O1xufTtcblxudHlwZSBQcmVzQXR0ckhhbmRsZXJzID0ge1xuICBba2V5IGluIGtleW9mIHR5cGVvZiBwcmVzQXR0cnNdOiAoYXJnczogQXR0ckhhbmRsZXJBcmdzKSA9PiB2b2lkO1xufTtcblxuY29uc3QgYXR0ckhhbmRsZXJzOiBQcmVzQXR0ckhhbmRsZXJzID0ge1xuICBzdHJva2U6ICh7IGVsLCBleFZhbHMgfSkgPT4ge1xuICAgIGNvbnN0IHN0cm9rZUNvbG9yID0gZ2V0KGVsLCBcInN0cm9rZVwiKTtcblxuICAgIGV4VmFscy5zdHJva2VDb2xvciA9IGhhcyhlbCwgXCJzdHJva2Utb3BhY2l0eVwiKVxuICAgICAgPyBoZXhXaXRoQWxwaGEoc3Ryb2tlQ29sb3IsIGdldE51bShlbCwgXCJzdHJva2Utb3BhY2l0eVwiKSlcbiAgICAgIDogc3Ryb2tlQ29sb3I7XG4gIH0sXG5cbiAgXCJzdHJva2Utb3BhY2l0eVwiOiAoeyBlbCwgZXhWYWxzIH0pID0+IHtcbiAgICBleFZhbHMuc3Ryb2tlQ29sb3IgPSBoZXhXaXRoQWxwaGEoXG4gICAgICBnZXQoZWwsIFwic3Ryb2tlXCIsIFwiIzAwMDAwMFwiKSxcbiAgICAgIGdldE51bShlbCwgXCJzdHJva2Utb3BhY2l0eVwiKSxcbiAgICApO1xuICB9LFxuXG4gIFwic3Ryb2tlLXdpZHRoXCI6ICh7IGVsLCBleFZhbHMgfSkgPT4ge1xuICAgIGV4VmFscy5zdHJva2VXaWR0aCA9IGdldE51bShlbCwgXCJzdHJva2Utd2lkdGhcIik7XG4gIH0sXG5cbiAgZmlsbDogKHsgZWwsIGV4VmFscyB9KSA9PiB7XG4gICAgY29uc3QgZmlsbCA9IGdldChlbCwgYGZpbGxgKTtcblxuICAgIGV4VmFscy5iYWNrZ3JvdW5kQ29sb3IgPSBmaWxsID09PSBcIm5vbmVcIiA/IFwiIzAwMDAwMDAwXCIgOiBmaWxsO1xuICB9LFxuXG4gIFwiZmlsbC1vcGFjaXR5XCI6ICh7IGVsLCBleFZhbHMgfSkgPT4ge1xuICAgIGV4VmFscy5iYWNrZ3JvdW5kQ29sb3IgPSBoZXhXaXRoQWxwaGEoXG4gICAgICBnZXQoZWwsIFwiZmlsbFwiLCBcIiMwMDAwMDBcIiksXG4gICAgICBnZXROdW0oZWwsIFwiZmlsbC1vcGFjaXR5XCIpLFxuICAgICk7XG4gIH0sXG5cbiAgb3BhY2l0eTogKHsgZWwsIGV4VmFscyB9KSA9PiB7XG4gICAgZXhWYWxzLm9wYWNpdHkgPSBnZXROdW0oZWwsIFwib3BhY2l0eVwiLCAxMDApO1xuICB9LFxufTtcblxuLy8gUHJlc2VudGF0aW9uIEF0dHJpYnV0ZXMgZm9yIFNWRyBFbGVtZW50czpcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvUHJlc2VudGF0aW9uXG5leHBvcnQgZnVuY3Rpb24gcHJlc0F0dHJzVG9FbGVtZW50VmFsdWVzKFxuICBlbDogRWxlbWVudCxcbik6IFBhcnRpYWw8RXhjYWxpZHJhd0VsZW1lbnRCYXNlPiB7XG4gIGNvbnN0IGV4VmFscyA9IFsuLi5lbC5hdHRyaWJ1dGVzXS5yZWR1Y2UoKGV4VmFscywgYXR0cikgPT4ge1xuICAgIGNvbnN0IG5hbWUgPSBhdHRyLm5hbWU7XG5cbiAgICBpZiAoT2JqZWN0LmtleXMoYXR0ckhhbmRsZXJzKS5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgYXR0ckhhbmRsZXJzW25hbWUgYXMga2V5b2YgUHJlc0F0dHJIYW5kbGVyc10oeyBlbCwgZXhWYWxzIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBleFZhbHM7XG4gIH0sIHt9IGFzIEV4UGFydGlhbEVsZW1lbnQpO1xuXG4gIHJldHVybiBleFZhbHM7XG59XG5cbnR5cGUgRmlsdGVyQXR0cnMgPSBQYXJ0aWFsPFxuICBQaWNrPEV4Y2FsaWRyYXdFbGVtZW50QmFzZSwgXCJ4XCIgfCBcInlcIiB8IFwid2lkdGhcIiB8IFwiaGVpZ2h0XCI+XG4+O1xuXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyQXR0cnNUb0VsZW1lbnRWYWx1ZXMoZWw6IEVsZW1lbnQpOiBGaWx0ZXJBdHRycyB7XG4gIGNvbnN0IGZpbHRlclZhbHM6IEZpbHRlckF0dHJzID0ge307XG5cbiAgaWYgKGhhcyhlbCwgXCJ4XCIpKSB7XG4gICAgZmlsdGVyVmFscy54ID0gZ2V0TnVtKGVsLCBcInhcIik7XG4gIH1cblxuICBpZiAoaGFzKGVsLCBcInlcIikpIHtcbiAgICBmaWx0ZXJWYWxzLnkgPSBnZXROdW0oZWwsIFwieVwiKTtcbiAgfVxuXG4gIGlmIChoYXMoZWwsIFwid2lkdGhcIikpIHtcbiAgICBmaWx0ZXJWYWxzLndpZHRoID0gZ2V0TnVtKGVsLCBcIndpZHRoXCIpO1xuICB9XG5cbiAgaWYgKGhhcyhlbCwgXCJoZWlnaHRcIikpIHtcbiAgICBmaWx0ZXJWYWxzLmhlaWdodCA9IGdldE51bShlbCwgXCJoZWlnaHRcIik7XG4gIH1cblxuICByZXR1cm4gZmlsdGVyVmFscztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50c0F0dHJUb1BvaW50cyhlbDogRWxlbWVudCk6IG51bWJlcltdW10ge1xuICBsZXQgcG9pbnRzOiBudW1iZXJbXVtdID0gW107XG5cbiAgaWYgKGhhcyhlbCwgXCJwb2ludHNcIikpIHtcbiAgICBwb2ludHMgPSBnZXQoZWwsIFwicG9pbnRzXCIpXG4gICAgICAuc3BsaXQoXCIgXCIpXG4gICAgICAubWFwKChwKSA9PiBwLnNwbGl0KFwiLFwiKS5tYXAocGFyc2VGbG9hdCkpO1xuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn1cbiIsImltcG9ydCB7IHJhbmRvbUlkIH0gZnJvbSBcIi4uL3V0aWxzXCI7XG5pbXBvcnQgeyBwcmVzQXR0cnNUb0VsZW1lbnRWYWx1ZXMgfSBmcm9tIFwiLi4vYXR0cmlidXRlc1wiO1xuaW1wb3J0IHsgRXhjYWxpZHJhd0VsZW1lbnRCYXNlIH0gZnJvbSBcIi4uL2VsZW1lbnRzL0V4Y2FsaWRyYXdFbGVtZW50XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRHcm91cEF0dHJzKGdyb3VwczogR3JvdXBbXSk6IGFueSB7XG4gIHJldHVybiBncm91cHMucmVkdWNlKChhY2MsIHsgZWxlbWVudCB9KSA9PiB7XG4gICAgY29uc3QgZWxWYWxzID0gcHJlc0F0dHJzVG9FbGVtZW50VmFsdWVzKGVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIHsgLi4uYWNjLCAuLi5lbFZhbHMgfTtcbiAgfSwge30gYXMgUGFydGlhbDxFeGNhbGlkcmF3RWxlbWVudEJhc2U+KTtcbn1cblxuY2xhc3MgR3JvdXAge1xuICBpZCA9IHJhbmRvbUlkKCk7XG5cbiAgZWxlbWVudDogRWxlbWVudDtcblxuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBFbGVtZW50KSB7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBHcm91cDtcbiIsImltcG9ydCB7IHJhbmRvbUlkLCByYW5kb21JbnRlZ2VyIH0gZnJvbSBcIi4uL3V0aWxzXCI7XG5cbmltcG9ydCB7XG4gIEdyb3VwSWQsXG4gIEZpbGxTdHlsZSxcbiAgU3Ryb2tlU3R5bGUsXG4gIFN0cm9rZVNoYXJwbmVzcyxcbiAgRXhjYWxpZHJhd0xpbmVhckVsZW1lbnQsXG59IGZyb20gXCIuLi90eXBlc1wiO1xuXG5leHBvcnQgdHlwZSBQb2ludCA9IFtudW1iZXIsIG51bWJlcl07XG5cbmV4cG9ydCB0eXBlIEV4Y2FsaWRyYXdFbGVtZW50QmFzZSA9IHtcbiAgaWQ6IHN0cmluZztcbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG4gIHN0cm9rZUNvbG9yOiBzdHJpbmc7XG4gIGJhY2tncm91bmRDb2xvcjogc3RyaW5nO1xuICBmaWxsU3R5bGU6IEZpbGxTdHlsZTtcbiAgc3Ryb2tlV2lkdGg6IG51bWJlcjtcbiAgc3Ryb2tlU3R5bGU6IFN0cm9rZVN0eWxlO1xuICBzdHJva2VTaGFycG5lc3M6IFN0cm9rZVNoYXJwbmVzcztcbiAgcm91Z2huZXNzOiBudW1iZXI7XG4gIG9wYWNpdHk6IG51bWJlcjtcbiAgd2lkdGg6IG51bWJlcjtcbiAgaGVpZ2h0OiBudW1iZXI7XG4gIGFuZ2xlOiBudW1iZXI7XG4gIC8qKiBSYW5kb20gaW50ZWdlciB1c2VkIHRvIHNlZWQgc2hhcGUgZ2VuZXJhdGlvbiBzbyB0aGF0IHRoZSByb3VnaGpzIHNoYXBlXG4gICAgICBkb2Vzbid0IGRpZmZlciBhY3Jvc3MgcmVuZGVycy4gKi9cbiAgc2VlZDogbnVtYmVyO1xuICAvKiogSW50ZWdlciB0aGF0IGlzIHNlcXVlbnRpYWxseSBpbmNyZW1lbnRlZCBvbiBlYWNoIGNoYW5nZS4gVXNlZCB0byByZWNvbmNpbGVcbiAgICAgIGVsZW1lbnRzIGR1cmluZyBjb2xsYWJvcmF0aW9uIG9yIHdoZW4gc2F2aW5nIHRvIHNlcnZlci4gKi9cbiAgdmVyc2lvbjogbnVtYmVyO1xuICAvKiogUmFuZG9tIGludGVnZXIgdGhhdCBpcyByZWdlbmVyYXRlZCBvbiBlYWNoIGNoYW5nZS5cbiAgICAgIFVzZWQgZm9yIGRldGVybWluaXN0aWMgcmVjb25jaWxpYXRpb24gb2YgdXBkYXRlcyBkdXJpbmcgY29sbGFib3JhdGlvbixcbiAgICAgIGluIGNhc2UgdGhlIHZlcnNpb25zIChzZWUgYWJvdmUpIGFyZSBpZGVudGljYWwuICovXG4gIHZlcnNpb25Ob25jZTogbnVtYmVyO1xuICBpc0RlbGV0ZWQ6IGJvb2xlYW47XG4gIC8qKiBMaXN0IG9mIGdyb3VwcyB0aGUgZWxlbWVudCBiZWxvbmdzIHRvLlxuICAgICAgT3JkZXJlZCBmcm9tIGRlZXBlc3QgdG8gc2hhbGxvd2VzdC4gKi9cbiAgZ3JvdXBJZHM6IEdyb3VwSWRbXTtcbiAgLyoqIElkcyBvZiAobGluZWFyKSBlbGVtZW50cyB0aGF0IGFyZSBib3VuZCB0byB0aGlzIGVsZW1lbnQuICovXG4gIGJvdW5kRWxlbWVudElkczogRXhjYWxpZHJhd0xpbmVhckVsZW1lbnRbXCJpZFwiXVtdIHwgbnVsbDtcbn07XG5cbmV4cG9ydCB0eXBlIEV4Y2FsaWRyYXdSZWN0YW5nbGUgPSBFeGNhbGlkcmF3RWxlbWVudEJhc2UgJiB7XG4gIHR5cGU6IFwicmVjdGFuZ2xlXCI7XG59O1xuXG5leHBvcnQgdHlwZSBFeGNhbGlkcmF3TGluZSA9IEV4Y2FsaWRyYXdFbGVtZW50QmFzZSAmIHtcbiAgdHlwZTogXCJsaW5lXCI7XG4gIHBvaW50czogcmVhZG9ubHkgUG9pbnRbXTtcbn07XG5cbmV4cG9ydCB0eXBlIEV4Y2FsaWRyYXdFbGxpcHNlID0gRXhjYWxpZHJhd0VsZW1lbnRCYXNlICYge1xuICB0eXBlOiBcImVsbGlwc2VcIjtcbn07XG5cbmV4cG9ydCB0eXBlIEV4Y2FsaWRyYXdHZW5lcmljRWxlbWVudCA9XG4gIHwgRXhjYWxpZHJhd1JlY3RhbmdsZVxuICB8IEV4Y2FsaWRyYXdFbGxpcHNlXG4gIHwgRXhjYWxpZHJhd0xpbmVcbiAgfCBFeGNhbGlkcmF3RHJhdztcblxuZXhwb3J0IHR5cGUgRXhjYWxpZHJhd0RyYXcgPSBFeGNhbGlkcmF3RWxlbWVudEJhc2UgJiB7XG4gIHR5cGU6IFwiZHJhd1wiO1xuICBwb2ludHM6IHJlYWRvbmx5IFBvaW50W107XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXhFbGVtZW50KCk6IEV4Y2FsaWRyYXdFbGVtZW50QmFzZSB7XG4gIHJldHVybiB7XG4gICAgaWQ6IHJhbmRvbUlkKCksXG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHN0cm9rZUNvbG9yOiBcIiMwMDAwMDBcIixcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzAwMDAwMFwiLFxuICAgIGZpbGxTdHlsZTogXCJzb2xpZFwiLFxuICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgIHN0cm9rZVN0eWxlOiBcInNvbGlkXCIsXG4gICAgc3Ryb2tlU2hhcnBuZXNzOiBcInNoYXJwXCIsXG4gICAgcm91Z2huZXNzOiAwLFxuICAgIG9wYWNpdHk6IDEwMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgYW5nbGU6IDAsXG4gICAgc2VlZDogcmFuZG9tSW50ZWdlcigpLFxuICAgIHZlcnNpb246IDAsXG4gICAgdmVyc2lvbk5vbmNlOiAwLFxuICAgIGlzRGVsZXRlZDogZmFsc2UsXG4gICAgZ3JvdXBJZHM6IFtdLFxuICAgIGJvdW5kRWxlbWVudElkczogbnVsbCxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV4UmVjdCgpOiBFeGNhbGlkcmF3UmVjdGFuZ2xlIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5jcmVhdGVFeEVsZW1lbnQoKSxcbiAgICB0eXBlOiBcInJlY3RhbmdsZVwiLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXhMaW5lKCk6IEV4Y2FsaWRyYXdMaW5lIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5jcmVhdGVFeEVsZW1lbnQoKSxcbiAgICB0eXBlOiBcImxpbmVcIixcbiAgICBwb2ludHM6IFtdLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXhFbGxpcHNlKCk6IEV4Y2FsaWRyYXdFbGxpcHNlIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5jcmVhdGVFeEVsZW1lbnQoKSxcbiAgICB0eXBlOiBcImVsbGlwc2VcIixcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV4RHJhdygpOiBFeGNhbGlkcmF3RHJhdyB7XG4gIHJldHVybiB7XG4gICAgLi4uY3JlYXRlRXhFbGVtZW50KCksXG4gICAgdHlwZTogXCJkcmF3XCIsXG4gICAgcG9pbnRzOiBbXSxcbiAgfTtcbn1cbiIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuLyoqXHJcbiAqIDMgRGltZW5zaW9uYWwgVmVjdG9yXHJcbiAqIEBtb2R1bGUgdmVjM1xyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzNcclxuICpcclxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSwgeik7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5LCB6KSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMyB0byBhbm90aGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBzb3VyY2UgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgeCwgeSwgeikge1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKiBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIERpdmlkZXMgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRpdmlkZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC8gYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjZWlsXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5jZWlsKGFbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBmbG9vclxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguZmxvb3IoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gcm91bmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLnJvdW5kKGFbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNjYWxlcyBhIHZlYzMgYnkgYSBzY2FsYXIgbnVtYmVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIHZlYzMncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdO1xuICB2YXIgeSA9IGJbMV0gLSBhWzFdO1xuICB2YXIgeiA9IGJbMl0gLSBhWzJdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5LCB6KTtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXTtcbiAgdmFyIHkgPSBiWzFdIC0gYVsxXTtcbiAgdmFyIHogPSBiWzJdIC0gYVsyXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogejtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHJldHVybiB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG59XG4vKipcclxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBpbnZlcnRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIG91dFsyXSA9IDEuMCAvIGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTm9ybWFsaXplIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHZhciBsZW4gPSB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG5cbiAgaWYgKGxlbiA+IDApIHtcbiAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgfVxuXG4gIG91dFswXSA9IGFbMF0gKiBsZW47XG4gIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gIG91dFsyXSA9IGFbMl0gKiBsZW47XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG59XG4vKipcclxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdO1xuICB2YXIgYnggPSBiWzBdLFxuICAgICAgYnkgPSBiWzFdLFxuICAgICAgYnogPSBiWzJdO1xuICBvdXRbMF0gPSBheSAqIGJ6IC0gYXogKiBieTtcbiAgb3V0WzFdID0gYXogKiBieCAtIGF4ICogYno7XG4gIG91dFsyXSA9IGF4ICogYnkgLSBheSAqIGJ4O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICB2YXIgYXggPSBhWzBdO1xuICB2YXIgYXkgPSBhWzFdO1xuICB2YXIgYXogPSBhWzJdO1xuICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgaGVybWl0ZSBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYyB0aGUgdGhpcmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gZCB0aGUgZm91cnRoIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaGVybWl0ZShvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgdmFyIGZhY3RvclRpbWVzMiA9IHQgKiB0O1xuICB2YXIgZmFjdG9yMSA9IGZhY3RvclRpbWVzMiAqICgyICogdCAtIDMpICsgMTtcbiAgdmFyIGZhY3RvcjIgPSBmYWN0b3JUaW1lczIgKiAodCAtIDIpICsgdDtcbiAgdmFyIGZhY3RvcjMgPSBmYWN0b3JUaW1lczIgKiAodCAtIDEpO1xuICB2YXIgZmFjdG9yNCA9IGZhY3RvclRpbWVzMiAqICgzIC0gMiAqIHQpO1xuICBvdXRbMF0gPSBhWzBdICogZmFjdG9yMSArIGJbMF0gKiBmYWN0b3IyICsgY1swXSAqIGZhY3RvcjMgKyBkWzBdICogZmFjdG9yNDtcbiAgb3V0WzFdID0gYVsxXSAqIGZhY3RvcjEgKyBiWzFdICogZmFjdG9yMiArIGNbMV0gKiBmYWN0b3IzICsgZFsxXSAqIGZhY3RvcjQ7XG4gIG91dFsyXSA9IGFbMl0gKiBmYWN0b3IxICsgYlsyXSAqIGZhY3RvcjIgKyBjWzJdICogZmFjdG9yMyArIGRbMl0gKiBmYWN0b3I0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgYmV6aWVyIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBjIHRoZSB0aGlyZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBkIHRoZSBmb3VydGggb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBiZXppZXIob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gIHZhciBpbnZlcnNlRmFjdG9yID0gMSAtIHQ7XG4gIHZhciBpbnZlcnNlRmFjdG9yVGltZXNUd28gPSBpbnZlcnNlRmFjdG9yICogaW52ZXJzZUZhY3RvcjtcbiAgdmFyIGZhY3RvclRpbWVzMiA9IHQgKiB0O1xuICB2YXIgZmFjdG9yMSA9IGludmVyc2VGYWN0b3JUaW1lc1R3byAqIGludmVyc2VGYWN0b3I7XG4gIHZhciBmYWN0b3IyID0gMyAqIHQgKiBpbnZlcnNlRmFjdG9yVGltZXNUd287XG4gIHZhciBmYWN0b3IzID0gMyAqIGZhY3RvclRpbWVzMiAqIGludmVyc2VGYWN0b3I7XG4gIHZhciBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogdDtcbiAgb3V0WzBdID0gYVswXSAqIGZhY3RvcjEgKyBiWzBdICogZmFjdG9yMiArIGNbMF0gKiBmYWN0b3IzICsgZFswXSAqIGZhY3RvcjQ7XG4gIG91dFsxXSA9IGFbMV0gKiBmYWN0b3IxICsgYlsxXSAqIGZhY3RvcjIgKyBjWzFdICogZmFjdG9yMyArIGRbMV0gKiBmYWN0b3I0O1xuICBvdXRbMl0gPSBhWzJdICogZmFjdG9yMSArIGJbMl0gKiBmYWN0b3IyICsgY1syXSAqIGZhY3RvcjMgKyBkWzJdICogZmFjdG9yNDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG4gIHZhciByID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICB2YXIgeiA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wIC0gMS4wO1xuICB2YXIgelNjYWxlID0gTWF0aC5zcXJ0KDEuMCAtIHogKiB6KSAqIHNjYWxlO1xuICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHpTY2FsZTtcbiAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiB6U2NhbGU7XG4gIG91dFsyXSA9IHogKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQ0LlxyXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl07XG4gIHZhciB3ID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdO1xuICB3ID0gdyB8fCAxLjA7XG4gIG91dFswXSA9IChtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSkgLyB3O1xuICBvdXRbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10pIC8gdztcbiAgb3V0WzJdID0gKG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSkgLyB3O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBtIHRoZSAzeDMgbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdO1xuICBvdXRbMF0gPSB4ICogbVswXSArIHkgKiBtWzNdICsgeiAqIG1bNl07XG4gIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XTtcbiAgb3V0WzJdID0geCAqIG1bMl0gKyB5ICogbVs1XSArIHogKiBtWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIHF1YXRcclxuICogQ2FuIGFsc28gYmUgdXNlZCBmb3IgZHVhbCBxdWF0ZXJuaW9ucy4gKE11bHRpcGx5IGl0IHdpdGggdGhlIHJlYWwgcGFydClcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtUXVhdChvdXQsIGEsIHEpIHtcbiAgLy8gYmVuY2htYXJrczogaHR0cHM6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tdHJhbnNmb3JtLXZlYzMtaW1wbGVtZW50YXRpb25zLWZpeGVkXG4gIHZhciBxeCA9IHFbMF0sXG4gICAgICBxeSA9IHFbMV0sXG4gICAgICBxeiA9IHFbMl0sXG4gICAgICBxdyA9IHFbM107XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl07IC8vIHZhciBxdmVjID0gW3F4LCBxeSwgcXpdO1xuICAvLyB2YXIgdXYgPSB2ZWMzLmNyb3NzKFtdLCBxdmVjLCBhKTtcblxuICB2YXIgdXZ4ID0gcXkgKiB6IC0gcXogKiB5LFxuICAgICAgdXZ5ID0gcXogKiB4IC0gcXggKiB6LFxuICAgICAgdXZ6ID0gcXggKiB5IC0gcXkgKiB4OyAvLyB2YXIgdXV2ID0gdmVjMy5jcm9zcyhbXSwgcXZlYywgdXYpO1xuXG4gIHZhciB1dXZ4ID0gcXkgKiB1dnogLSBxeiAqIHV2eSxcbiAgICAgIHV1dnkgPSBxeiAqIHV2eCAtIHF4ICogdXZ6LFxuICAgICAgdXV2eiA9IHF4ICogdXZ5IC0gcXkgKiB1dng7IC8vIHZlYzMuc2NhbGUodXYsIHV2LCAyICogdyk7XG5cbiAgdmFyIHcyID0gcXcgKiAyO1xuICB1dnggKj0gdzI7XG4gIHV2eSAqPSB3MjtcbiAgdXZ6ICo9IHcyOyAvLyB2ZWMzLnNjYWxlKHV1diwgdXV2LCAyKTtcblxuICB1dXZ4ICo9IDI7XG4gIHV1dnkgKj0gMjtcbiAgdXV2eiAqPSAyOyAvLyByZXR1cm4gdmVjMy5hZGQob3V0LCBhLCB2ZWMzLmFkZChvdXQsIHV2LCB1dXYpKTtcblxuICBvdXRbMF0gPSB4ICsgdXZ4ICsgdXV2eDtcbiAgb3V0WzFdID0geSArIHV2eSArIHV1dnk7XG4gIG91dFsyXSA9IHogKyB1dnogKyB1dXZ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHgtYXhpc1xyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnNcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVgob3V0LCBhLCBiLCByYWQpIHtcbiAgdmFyIHAgPSBbXSxcbiAgICAgIHIgPSBbXTsgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXG4gIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBwWzJdID0gYVsyXSAtIGJbMl07IC8vcGVyZm9ybSByb3RhdGlvblxuXG4gIHJbMF0gPSBwWzBdO1xuICByWzFdID0gcFsxXSAqIE1hdGguY29zKHJhZCkgLSBwWzJdICogTWF0aC5zaW4ocmFkKTtcbiAgclsyXSA9IHBbMV0gKiBNYXRoLnNpbihyYWQpICsgcFsyXSAqIE1hdGguY29zKHJhZCk7IC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblxuICBvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgb3V0WzFdID0gclsxXSArIGJbMV07XG4gIG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHktYXhpc1xyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnNcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCBiLCByYWQpIHtcbiAgdmFyIHAgPSBbXSxcbiAgICAgIHIgPSBbXTsgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXG4gIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBwWzJdID0gYVsyXSAtIGJbMl07IC8vcGVyZm9ybSByb3RhdGlvblxuXG4gIHJbMF0gPSBwWzJdICogTWF0aC5zaW4ocmFkKSArIHBbMF0gKiBNYXRoLmNvcyhyYWQpO1xuICByWzFdID0gcFsxXTtcbiAgclsyXSA9IHBbMl0gKiBNYXRoLmNvcyhyYWQpIC0gcFswXSAqIE1hdGguc2luKHJhZCk7IC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblxuICBvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgb3V0WzFdID0gclsxXSArIGJbMV07XG4gIG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHotYXhpc1xyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnNcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCBiLCByYWQpIHtcbiAgdmFyIHAgPSBbXSxcbiAgICAgIHIgPSBbXTsgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXG4gIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBwWzJdID0gYVsyXSAtIGJbMl07IC8vcGVyZm9ybSByb3RhdGlvblxuXG4gIHJbMF0gPSBwWzBdICogTWF0aC5jb3MocmFkKSAtIHBbMV0gKiBNYXRoLnNpbihyYWQpO1xuICByWzFdID0gcFswXSAqIE1hdGguc2luKHJhZCkgKyBwWzFdICogTWF0aC5jb3MocmFkKTtcbiAgclsyXSA9IHBbMl07IC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblxuICBvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgb3V0WzFdID0gclsxXSArIGJbMV07XG4gIG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gM0QgdmVjdG9yc1xyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl0sXG4gICAgICBieCA9IGJbMF0sXG4gICAgICBieSA9IGJbMV0sXG4gICAgICBieiA9IGJbMl0sXG4gICAgICBtYWcxID0gTWF0aC5zcXJ0KGF4ICogYXggKyBheSAqIGF5ICsgYXogKiBheiksXG4gICAgICBtYWcyID0gTWF0aC5zcXJ0KGJ4ICogYnggKyBieSAqIGJ5ICsgYnogKiBieiksXG4gICAgICBtYWcgPSBtYWcxICogbWFnMixcbiAgICAgIGNvc2luZSA9IG1hZyAmJiBkb3QoYSwgYikgLyBtYWc7XG4gIHJldHVybiBNYXRoLmFjb3MoTWF0aC5taW4oTWF0aC5tYXgoY29zaW5lLCAtMSksIDEpKTtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHplcm9cclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHplcm8ob3V0KSB7XG4gIG91dFswXSA9IDAuMDtcbiAgb3V0WzFdID0gMC4wO1xuICBvdXRbMl0gPSAwLjA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwidmVjMyhcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiKVwiO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl07XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSk7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnN1YnRyYWN0fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc3ViID0gc3VidHJhY3Q7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLm11bHRpcGx5fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpdmlkZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGRpdiA9IGRpdmlkZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGlzdGFuY2V9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBkaXN0ID0gZGlzdGFuY2U7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWREaXN0YW5jZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHNxckRpc3QgPSBzcXVhcmVkRGlzdGFuY2U7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmxlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGxlbiA9IGxlbmd0aDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZExlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG4vKipcclxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzNzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzMuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjM3MgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gYVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZlYyA9IGNyZWF0ZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgIHZhciBpLCBsO1xuXG4gICAgaWYgKCFzdHJpZGUpIHtcbiAgICAgIHN0cmlkZSA9IDM7XG4gICAgfVxuXG4gICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBsID0gTWF0aC5taW4oY291bnQgKiBzdHJpZGUgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbCA9IGEubGVuZ3RoO1xuICAgIH1cblxuICAgIGZvciAoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICB2ZWNbMF0gPSBhW2ldO1xuICAgICAgdmVjWzFdID0gYVtpICsgMV07XG4gICAgICB2ZWNbMl0gPSBhW2kgKyAyXTtcbiAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgYVtpXSA9IHZlY1swXTtcbiAgICAgIGFbaSArIDFdID0gdmVjWzFdO1xuICAgICAgYVtpICsgMl0gPSB2ZWNbMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH07XG59KCk7IiwiaW1wb3J0IEdyb3VwIGZyb20gXCIuL2VsZW1lbnRzL0dyb3VwXCI7XG5pbXBvcnQgeyB2ZWMzLCBtYXQ0IH0gZnJvbSBcImdsLW1hdHJpeFwiO1xuXG4vKlxuU1ZHIHRyYW5zZm9ybSBhdHRyIGlzIGEgYml0IHN0cmFuZ2UgaW4gdGhhdCBpdCBjYW4gYWNjZXB0IHRyYWRpdGlvbmFsXG5jc3MgdHJhbnNmb3JtIHN0cmluZyAoYXQgbGVhc3QgcGVyIHNwZWMpIGFzIHdlbGwgYXMgYSBpdCdzIG93biBcInVuaXRsZXNzXCJcbnZlcnNpb24gb2YgdHJhbnNmb3JtIGZ1bmN0aW9ucy5cblxuaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS90cmFuc2Zvcm1cbiovXG5cbmNvbnN0IHRyYW5zZm9ybUZ1bmN0aW9ucyA9IHtcbiAgbWF0cml4OiBcIm1hdHJpeFwiLFxuICBtYXRyaXgzZDogXCJtYXRyaXgzZFwiLFxuICBwZXJzcGVjdGl2ZTogXCJwZXJzcGVjdGl2ZVwiLFxuICByb3RhdGU6IFwicm90YXRlXCIsXG4gIHJvdGF0ZTNkOiBcInJvdGF0ZTNkXCIsXG4gIHJvdGF0ZVg6IFwicm90YXRlWFwiLFxuICByb3RhdGVZOiBcInJvdGF0ZVlcIixcbiAgcm90YXRlWjogXCJyb3RhdGVaXCIsXG4gIHNjYWxlOiBcInNjYWxlXCIsXG4gIHNjYWxlM2Q6IFwic2NhbGUzZFwiLFxuICBzY2FsZVg6IFwic2NhbGVYXCIsXG4gIHNjYWxlWTogXCJzY2FsZVlcIixcbiAgc2NhbGVaOiBcInNjYWxlWlwiLFxuICBza2V3OiBcInNrZXdcIixcbiAgc2tld1g6IFwic2tld1hcIixcbiAgc2tld1k6IFwic2tld1lcIixcbiAgdHJhbnNsYXRlOiBcInRyYW5zbGF0ZVwiLFxuICB0cmFuc2xhdGUzZDogXCJ0cmFuc2xhdGUzZFwiLFxuICB0cmFuc2xhdGVYOiBcInRyYW5zbGF0ZVhcIixcbiAgdHJhbnNsYXRlWTogXCJ0cmFuc2xhdGVZXCIsXG4gIHRyYW5zbGF0ZVo6IFwidHJhbnNsYXRlWlwiLFxufSBhcyBjb25zdDtcblxuY29uc3QgdHJhbnNmb3JtRnVuY3Rpb25zQXJyID0gT2JqZWN0LmtleXModHJhbnNmb3JtRnVuY3Rpb25zKTtcblxuLy8gdHlwZSBUcmFuc2Zvcm1cblxudHlwZSBUcmFuc2Zvcm1GdW5jVmFsdWUgPSB7XG4gIHZhbHVlOiBzdHJpbmc7XG4gIHVuaXQ6IHN0cmluZztcbn07XG5cbnR5cGUgVHJhbnNmb3JtRnVuYyA9IHtcbiAgdHlwZToga2V5b2YgdHlwZW9mIHRyYW5zZm9ybUZ1bmN0aW9ucztcbiAgdmFsdWVzOiBUcmFuc2Zvcm1GdW5jVmFsdWVbXTtcbn07XG5cbmNvbnN0IGRlZmF1bHRVbml0cyA9IHtcbiAgbWF0cml4OiBcIlwiLFxuICBtYXRyaXgzZDogXCJcIixcbiAgcGVyc3BlY3RpdmU6IFwicGVyc3BlY3RpdmVcIixcbiAgcm90YXRlOiBcImRlZ1wiLFxuICByb3RhdGUzZDogXCJkZWdcIixcbiAgcm90YXRlWDogXCJkZWdcIixcbiAgcm90YXRlWTogXCJkZWdcIixcbiAgcm90YXRlWjogXCJkZWdcIixcbiAgc2NhbGU6IFwiXCIsXG4gIHNjYWxlM2Q6IFwiXCIsXG4gIHNjYWxlWDogXCJcIixcbiAgc2NhbGVZOiBcIlwiLFxuICBzY2FsZVo6IFwiXCIsXG4gIHNrZXc6IFwic2tld1wiLFxuICBza2V3WDogXCJkZWdcIixcbiAgc2tld1k6IFwiZGVnXCIsXG4gIHRyYW5zbGF0ZTogXCJweFwiLFxuICB0cmFuc2xhdGUzZDogXCJweFwiLFxuICB0cmFuc2xhdGVYOiBcInB4XCIsXG4gIHRyYW5zbGF0ZVk6IFwicHhcIixcbiAgdHJhbnNsYXRlWjogXCJweFwiLFxufTtcblxuLy8gQ29udmVydCBiZXR3ZWVuIHBvc3NpYmxlIHN2ZyB0cmFuc2Zvcm0gYXR0cmlidXRlIHZhbHVlcyB0byBjc3MgdHJhbnNmb3JtIGF0dHJpYnV0ZSB2YWx1ZXMuXG5jb25zdCBzdmdUcmFuc2Zvcm1Ub0NTU1RyYW5zZm9ybSA9IChzdmdUcmFuc2Zvcm1TdHI6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIC8vIENyZWF0ZSB0cmFuc2Zvcm0gZnVuY3Rpb24gc3RyaW5nIFwiY2h1bmtzXCIsIGUuZyBcInJvdGF0ZSg5MGRlZylcIlxuICBjb25zdCB0RnVuY3MgPSBzdmdUcmFuc2Zvcm1TdHIubWF0Y2goLyhcXHcrKVxcKChbXildKilcXCkvZyk7XG4gIGlmICghdEZ1bmNzKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cblxuICBjb25zdCB0RnVuY1ZhbHVlczogVHJhbnNmb3JtRnVuY1tdID0gdEZ1bmNzLm1hcChcbiAgICAodEZ1bmNTdHIpOiBUcmFuc2Zvcm1GdW5jID0+IHtcbiAgICAgIGNvbnN0IHR5cGUgPSB0RnVuY1N0ci5zcGxpdChcIihcIilbMF0gYXMga2V5b2YgdHlwZW9mIHRyYW5zZm9ybUZ1bmN0aW9ucztcbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmluZCB0cmFuc2Zvcm0gbmFtZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghdHJhbnNmb3JtRnVuY3Rpb25zQXJyLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdHJhbnNmb3JtIGZ1bmN0aW9uIG5hbWUgXCIke3R5cGV9XCIgaXMgbm90IHZhbGlkYCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGdldCB0aGUgYXJnL3Byb3BzIG9mIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24sIGUuZyBcIjkwZGVnXCIuXG4gICAgICBjb25zdCB0RnVuY1BhcnRzID0gdEZ1bmNTdHIubWF0Y2goLyhbLStdP1swLTldKlxcLj9bMC05XSspKFthLXpdKSovZyk7XG4gICAgICBpZiAoIXRGdW5jUGFydHMpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZSwgdmFsdWVzOiBbXSB9O1xuICAgICAgfVxuXG4gICAgICBsZXQgdmFsdWVzID0gdEZ1bmNQYXJ0cy5tYXAoXG4gICAgICAgIChhKTogVHJhbnNmb3JtRnVuY1ZhbHVlID0+IHtcbiAgICAgICAgICAvLyBTZXBhcmF0ZSB0aGUgYXJnIHZhbHVlIGFuZCB1bml0LiBlLmcgW1wiOTBcIiwgXCJkZWdcIl1cbiAgICAgICAgICBjb25zdCBbdmFsdWUsIHVuaXRdID0gYS5tYXRjaEFsbCgvKFstK10/WzAtOV0qXFwuP1swLTldKyl8KFthLXpdKSovZyk7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdW5pdDogdW5pdFswXSB8fCBkZWZhdWx0VW5pdHNbdHlwZV0sXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVbMF0sXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICk7XG5cbiAgICAgIC8vIE5vdCBzdXBwb3J0aW5nIHgsIHkgYXJncyBvZiBzdmcgcm90YXRlIHRyYW5zZm9ybSB5ZXQuLi5cbiAgICAgIGlmICh2YWx1ZXMgJiYgdHlwZSA9PT0gXCJyb3RhdGVcIiAmJiB2YWx1ZXM/Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFsdWVzID0gW3ZhbHVlc1swXV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHZhbHVlcyxcbiAgICAgIH07XG4gICAgfSxcbiAgKTtcblxuICAvLyBHZW5lcmF0ZSBhIHN0cmluZyBvZiB0cmFuc2Zvcm0gZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHNldCBhcyBhIENTUyBUcmFuc2Zvcm0uXG4gIGNvbnN0IGNzc3RyYW5zZm9ybVN0ciA9IHRGdW5jVmFsdWVzXG4gICAgLm1hcCgoeyB0eXBlLCB2YWx1ZXMgfSkgPT4ge1xuICAgICAgY29uc3QgdmFsU3RyID0gdmFsdWVzXG4gICAgICAgIC5tYXAoKHsgdW5pdCwgdmFsdWUgfSkgPT4gYCR7dmFsdWV9JHt1bml0fWApXG4gICAgICAgIC5qb2luKFwiLCBcIik7XG4gICAgICByZXR1cm4gYCR7dHlwZX0oJHt2YWxTdHJ9KWA7XG4gICAgfSlcbiAgICAuam9pbihcIiBcIik7XG5cbiAgcmV0dXJuIGNzc3RyYW5zZm9ybVN0cjtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVET01NYXRyaXhGcm9tU1ZHU3RyID0gKFxuICBzdmdUcmFuc2Zvcm1TdHI6IHN0cmluZyxcbik6IERPTU1hdHJpeCA9PiB7XG4gIGNvbnN0IGNzc1RyYW5zZm9ybVN0ciA9IHN2Z1RyYW5zZm9ybVRvQ1NTVHJhbnNmb3JtKHN2Z1RyYW5zZm9ybVN0cik7XG5cbiAgcmV0dXJuIG5ldyBET01NYXRyaXgoY3NzVHJhbnNmb3JtU3RyKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbGVtZW50TWF0cml4KGVsOiBFbGVtZW50KTogbWF0NCB7XG4gIGlmIChlbC5oYXNBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIikpIHtcbiAgICBjb25zdCBlbE1hdCA9IG5ldyBET01NYXRyaXgoXG4gICAgICBzdmdUcmFuc2Zvcm1Ub0NTU1RyYW5zZm9ybShlbC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIikgfHwgXCJcIiksXG4gICAgKTtcblxuICAgIHJldHVybiBtYXQ0Lm11bHRpcGx5KG1hdDQuY3JlYXRlKCksIG1hdDQuY3JlYXRlKCksIGVsTWF0LnRvRmxvYXQzMkFycmF5KCkpO1xuICB9XG5cbiAgcmV0dXJuIG1hdDQuY3JlYXRlKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1NYXRyaXgoZWw6IEVsZW1lbnQsIGdyb3VwczogR3JvdXBbXSk6IG1hdDQge1xuICBjb25zdCBhY2N1bU1hdCA9IGdyb3Vwc1xuICAgIC5tYXAoKHsgZWxlbWVudCB9KSA9PiBnZXRFbGVtZW50TWF0cml4KGVsZW1lbnQpKVxuICAgIC5jb25jYXQoW2dldEVsZW1lbnRNYXRyaXgoZWwpXSlcbiAgICAucmVkdWNlKChhY2MsIG1hdCkgPT4gbWF0NC5tdWx0aXBseShhY2MsIGFjYywgbWF0KSwgbWF0NC5jcmVhdGUoKSk7XG5cbiAgcmV0dXJuIGFjY3VtTWF0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtUG9pbnRzKFxuICBwb2ludHM6IG51bWJlcltdW10sXG4gIHRyYW5zZm9ybTogbWF0NCxcbik6IFtudW1iZXIsIG51bWJlcl1bXSB7XG4gIHJldHVybiBwb2ludHMubWFwKChbeCwgeV0pID0+IHtcbiAgICBjb25zdCBbbmV3WCwgbmV3WV0gPSB2ZWMzLnRyYW5zZm9ybU1hdDQoXG4gICAgICB2ZWMzLmNyZWF0ZSgpLFxuICAgICAgdmVjMy5mcm9tVmFsdWVzKHgsIHksIDEpLFxuICAgICAgdHJhbnNmb3JtLFxuICAgICk7XG5cbiAgICByZXR1cm4gW25ld1gsIG5ld1ldO1xuICB9KTtcbn1cbiIsIi8vIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHNcbmZ1bmN0aW9uIGRpc3RhbmNlKHAxLCBwMikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoZGlzdGFuY2VTcShwMSwgcDIpKTtcbn1cbi8vIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHMgc3F1YXJlZFxuZnVuY3Rpb24gZGlzdGFuY2VTcShwMSwgcDIpIHtcbiAgICByZXR1cm4gTWF0aC5wb3cocDFbMF0gLSBwMlswXSwgMikgKyBNYXRoLnBvdyhwMVsxXSAtIHAyWzFdLCAyKTtcbn1cbi8vIFNpc3RhbmNlIHNxdWFyZWQgZnJvbSBhIHBvaW50IHAgdG8gdGhlIGxpbmUgc2VnbWVudCB2d1xuZnVuY3Rpb24gZGlzdGFuY2VUb1NlZ21lbnRTcShwLCB2LCB3KSB7XG4gICAgY29uc3QgbDIgPSBkaXN0YW5jZVNxKHYsIHcpO1xuICAgIGlmIChsMiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZGlzdGFuY2VTcShwLCB2KTtcbiAgICB9XG4gICAgbGV0IHQgPSAoKHBbMF0gLSB2WzBdKSAqICh3WzBdIC0gdlswXSkgKyAocFsxXSAtIHZbMV0pICogKHdbMV0gLSB2WzFdKSkgLyBsMjtcbiAgICB0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdCkpO1xuICAgIHJldHVybiBkaXN0YW5jZVNxKHAsIGxlcnAodiwgdywgdCkpO1xufVxuZnVuY3Rpb24gbGVycChhLCBiLCB0KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgYVswXSArIChiWzBdIC0gYVswXSkgKiB0LFxuICAgICAgICBhWzFdICsgKGJbMV0gLSBhWzFdKSAqIHQsXG4gICAgXTtcbn1cbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL3NlYW50MjMud29yZHByZXNzLmNvbS8yMDEwLzExLzEyL29mZnNldC1iZXppZXItY3VydmVzL1xuZnVuY3Rpb24gZmxhdG5lc3MocG9pbnRzLCBvZmZzZXQpIHtcbiAgICBjb25zdCBwMSA9IHBvaW50c1tvZmZzZXQgKyAwXTtcbiAgICBjb25zdCBwMiA9IHBvaW50c1tvZmZzZXQgKyAxXTtcbiAgICBjb25zdCBwMyA9IHBvaW50c1tvZmZzZXQgKyAyXTtcbiAgICBjb25zdCBwNCA9IHBvaW50c1tvZmZzZXQgKyAzXTtcbiAgICBsZXQgdXggPSAzICogcDJbMF0gLSAyICogcDFbMF0gLSBwNFswXTtcbiAgICB1eCAqPSB1eDtcbiAgICBsZXQgdXkgPSAzICogcDJbMV0gLSAyICogcDFbMV0gLSBwNFsxXTtcbiAgICB1eSAqPSB1eTtcbiAgICBsZXQgdnggPSAzICogcDNbMF0gLSAyICogcDRbMF0gLSBwMVswXTtcbiAgICB2eCAqPSB2eDtcbiAgICBsZXQgdnkgPSAzICogcDNbMV0gLSAyICogcDRbMV0gLSBwMVsxXTtcbiAgICB2eSAqPSB2eTtcbiAgICBpZiAodXggPCB2eCkge1xuICAgICAgICB1eCA9IHZ4O1xuICAgIH1cbiAgICBpZiAodXkgPCB2eSkge1xuICAgICAgICB1eSA9IHZ5O1xuICAgIH1cbiAgICByZXR1cm4gdXggKyB1eTtcbn1cbmZ1bmN0aW9uIGdldFBvaW50c09uQmV6aWVyQ3VydmVXaXRoU3BsaXR0aW5nKHBvaW50cywgb2Zmc2V0LCB0b2xlcmFuY2UsIG5ld1BvaW50cykge1xuICAgIGNvbnN0IG91dFBvaW50cyA9IG5ld1BvaW50cyB8fCBbXTtcbiAgICBpZiAoZmxhdG5lc3MocG9pbnRzLCBvZmZzZXQpIDwgdG9sZXJhbmNlKSB7XG4gICAgICAgIGNvbnN0IHAwID0gcG9pbnRzW29mZnNldCArIDBdO1xuICAgICAgICBpZiAob3V0UG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZCA9IGRpc3RhbmNlKG91dFBvaW50c1tvdXRQb2ludHMubGVuZ3RoIC0gMV0sIHAwKTtcbiAgICAgICAgICAgIGlmIChkID4gMSkge1xuICAgICAgICAgICAgICAgIG91dFBvaW50cy5wdXNoKHAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dFBvaW50cy5wdXNoKHAwKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRQb2ludHMucHVzaChwb2ludHNbb2Zmc2V0ICsgM10pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gc3ViZGl2aWRlXG4gICAgICAgIGNvbnN0IHQgPSAuNTtcbiAgICAgICAgY29uc3QgcDEgPSBwb2ludHNbb2Zmc2V0ICsgMF07XG4gICAgICAgIGNvbnN0IHAyID0gcG9pbnRzW29mZnNldCArIDFdO1xuICAgICAgICBjb25zdCBwMyA9IHBvaW50c1tvZmZzZXQgKyAyXTtcbiAgICAgICAgY29uc3QgcDQgPSBwb2ludHNbb2Zmc2V0ICsgM107XG4gICAgICAgIGNvbnN0IHExID0gbGVycChwMSwgcDIsIHQpO1xuICAgICAgICBjb25zdCBxMiA9IGxlcnAocDIsIHAzLCB0KTtcbiAgICAgICAgY29uc3QgcTMgPSBsZXJwKHAzLCBwNCwgdCk7XG4gICAgICAgIGNvbnN0IHIxID0gbGVycChxMSwgcTIsIHQpO1xuICAgICAgICBjb25zdCByMiA9IGxlcnAocTIsIHEzLCB0KTtcbiAgICAgICAgY29uc3QgcmVkID0gbGVycChyMSwgcjIsIHQpO1xuICAgICAgICBnZXRQb2ludHNPbkJlemllckN1cnZlV2l0aFNwbGl0dGluZyhbcDEsIHExLCByMSwgcmVkXSwgMCwgdG9sZXJhbmNlLCBvdXRQb2ludHMpO1xuICAgICAgICBnZXRQb2ludHNPbkJlemllckN1cnZlV2l0aFNwbGl0dGluZyhbcmVkLCByMiwgcTMsIHA0XSwgMCwgdG9sZXJhbmNlLCBvdXRQb2ludHMpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0UG9pbnRzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50cywgZGlzdGFuY2UpIHtcbiAgICByZXR1cm4gc2ltcGxpZnlQb2ludHMocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLCBkaXN0YW5jZSk7XG59XG4vLyBSYW1lcuKAk0RvdWdsYXPigJNQZXVja2VyIGFsZ29yaXRobVxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmFtZXIlRTIlODAlOTNEb3VnbGFzJUUyJTgwJTkzUGV1Y2tlcl9hbGdvcml0aG1cbmZ1bmN0aW9uIHNpbXBsaWZ5UG9pbnRzKHBvaW50cywgc3RhcnQsIGVuZCwgZXBzaWxvbiwgbmV3UG9pbnRzKSB7XG4gICAgY29uc3Qgb3V0UG9pbnRzID0gbmV3UG9pbnRzIHx8IFtdO1xuICAgIC8vIGZpbmQgdGhlIG1vc3QgZGlzdGFuY2UgcG9pbnQgZnJvbSB0aGUgZW5kcG9pbnRzXG4gICAgY29uc3QgcyA9IHBvaW50c1tzdGFydF07XG4gICAgY29uc3QgZSA9IHBvaW50c1tlbmQgLSAxXTtcbiAgICBsZXQgbWF4RGlzdFNxID0gMDtcbiAgICBsZXQgbWF4TmR4ID0gMTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQgKyAxOyBpIDwgZW5kIC0gMTsgKytpKSB7XG4gICAgICAgIGNvbnN0IGRpc3RTcSA9IGRpc3RhbmNlVG9TZWdtZW50U3EocG9pbnRzW2ldLCBzLCBlKTtcbiAgICAgICAgaWYgKGRpc3RTcSA+IG1heERpc3RTcSkge1xuICAgICAgICAgICAgbWF4RGlzdFNxID0gZGlzdFNxO1xuICAgICAgICAgICAgbWF4TmR4ID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiB0aGF0IHBvaW50IGlzIHRvbyBmYXIsIHNwbGl0XG4gICAgaWYgKE1hdGguc3FydChtYXhEaXN0U3EpID4gZXBzaWxvbikge1xuICAgICAgICBzaW1wbGlmeVBvaW50cyhwb2ludHMsIHN0YXJ0LCBtYXhOZHggKyAxLCBlcHNpbG9uLCBvdXRQb2ludHMpO1xuICAgICAgICBzaW1wbGlmeVBvaW50cyhwb2ludHMsIG1heE5keCwgZW5kLCBlcHNpbG9uLCBvdXRQb2ludHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFvdXRQb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdXRQb2ludHMucHVzaChzKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRQb2ludHMucHVzaChlKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dFBvaW50cztcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb2ludHNPbkJlemllckN1cnZlcyhwb2ludHMsIHRvbGVyYW5jZSA9IDAuMTUsIGRpc3RhbmNlKSB7XG4gICAgY29uc3QgbmV3UG9pbnRzID0gW107XG4gICAgY29uc3QgbnVtU2VnbWVudHMgPSAocG9pbnRzLmxlbmd0aCAtIDEpIC8gMztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaSAqIDM7XG4gICAgICAgIGdldFBvaW50c09uQmV6aWVyQ3VydmVXaXRoU3BsaXR0aW5nKHBvaW50cywgb2Zmc2V0LCB0b2xlcmFuY2UsIG5ld1BvaW50cyk7XG4gICAgfVxuICAgIGlmIChkaXN0YW5jZSAmJiBkaXN0YW5jZSA+IDApIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsaWZ5UG9pbnRzKG5ld1BvaW50cywgMCwgbmV3UG9pbnRzLmxlbmd0aCwgZGlzdGFuY2UpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3UG9pbnRzO1xufVxuIiwiY29uc3QgQ09NTUFORCA9IDA7XG5jb25zdCBOVU1CRVIgPSAxO1xuY29uc3QgRU9EID0gMjtcbmNvbnN0IFBBUkFNUyA9IHsgQTogNywgYTogNywgQzogNiwgYzogNiwgSDogMSwgaDogMSwgTDogMiwgbDogMiwgTTogMiwgbTogMiwgUTogNCwgcTogNCwgUzogNCwgczogNCwgVDogMiwgdDogMiwgVjogMSwgdjogMSwgWjogMCwgejogMCB9O1xuZnVuY3Rpb24gdG9rZW5pemUoZCkge1xuICAgIGNvbnN0IHRva2VucyA9IG5ldyBBcnJheSgpO1xuICAgIHdoaWxlIChkICE9PSAnJykge1xuICAgICAgICBpZiAoZC5tYXRjaCgvXihbIFxcdFxcclxcbixdKykvKSkge1xuICAgICAgICAgICAgZCA9IGQuc3Vic3RyKFJlZ0V4cC4kMS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGQubWF0Y2goL14oW2FBY0NoSGxMbU1xUXNTdFR2VnpaXSkvKSkge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2Vucy5sZW5ndGhdID0geyB0eXBlOiBDT01NQU5ELCB0ZXh0OiBSZWdFeHAuJDEgfTtcbiAgICAgICAgICAgIGQgPSBkLnN1YnN0cihSZWdFeHAuJDEubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkLm1hdGNoKC9eKChbLStdP1swLTldKyhcXC5bMC05XSopP3xbLStdP1xcLlswLTldKykoW2VFXVstK10/WzAtOV0rKT8pLykpIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbnMubGVuZ3RoXSA9IHsgdHlwZTogTlVNQkVSLCB0ZXh0OiBgJHtwYXJzZUZsb2F0KFJlZ0V4cC4kMSl9YCB9O1xuICAgICAgICAgICAgZCA9IGQuc3Vic3RyKFJlZ0V4cC4kMS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRva2Vuc1t0b2tlbnMubGVuZ3RoXSA9IHsgdHlwZTogRU9ELCB0ZXh0OiAnJyB9O1xuICAgIHJldHVybiB0b2tlbnM7XG59XG5mdW5jdGlvbiBpc1R5cGUodG9rZW4sIHR5cGUpIHtcbiAgICByZXR1cm4gdG9rZW4udHlwZSA9PT0gdHlwZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVBhdGgoZCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gW107XG4gICAgY29uc3QgdG9rZW5zID0gdG9rZW5pemUoZCk7XG4gICAgbGV0IG1vZGUgPSAnQk9EJztcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGxldCB0b2tlbiA9IHRva2Vuc1tpbmRleF07XG4gICAgd2hpbGUgKCFpc1R5cGUodG9rZW4sIEVPRCkpIHtcbiAgICAgICAgbGV0IHBhcmFtc0NvdW50ID0gMDtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgICAgIGlmIChtb2RlID09PSAnQk9EJykge1xuICAgICAgICAgICAgaWYgKHRva2VuLnRleHQgPT09ICdNJyB8fCB0b2tlbi50ZXh0ID09PSAnbScpIHtcbiAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgIHBhcmFtc0NvdW50ID0gUEFSQU1TW3Rva2VuLnRleHRdO1xuICAgICAgICAgICAgICAgIG1vZGUgPSB0b2tlbi50ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlUGF0aCgnTTAsMCcgKyBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1R5cGUodG9rZW4sIE5VTUJFUikpIHtcbiAgICAgICAgICAgIHBhcmFtc0NvdW50ID0gUEFSQU1TW21vZGVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIHBhcmFtc0NvdW50ID0gUEFSQU1TW3Rva2VuLnRleHRdO1xuICAgICAgICAgICAgbW9kZSA9IHRva2VuLnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChpbmRleCArIHBhcmFtc0NvdW50KSA8IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleDsgaSA8IGluZGV4ICsgcGFyYW1zQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bWJlVG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGlzVHlwZShudW1iZVRva2VuLCBOVU1CRVIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1twYXJhbXMubGVuZ3RoXSA9ICtudW1iZVRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtIG5vdCBhIG51bWJlcjogJyArIG1vZGUgKyAnLCcgKyBudW1iZVRva2VuLnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgUEFSQU1TW21vZGVdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlZ21lbnQgPSB7IGtleTogbW9kZSwgZGF0YTogcGFyYW1zIH07XG4gICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICAgICAgICAgICAgICBpbmRleCArPSBwYXJhbXNDb3VudDtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdNJylcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9ICdMJztcbiAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gJ20nKVxuICAgICAgICAgICAgICAgICAgICBtb2RlID0gJ2wnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgc2VnbWVudDogJyArIG1vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXRoIGRhdGEgZW5kZWQgc2hvcnQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VnbWVudHM7XG59XG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplKHNlZ21lbnRzKSB7XG4gICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgZm9yIChjb25zdCB7IGtleSwgZGF0YSB9IG9mIHNlZ21lbnRzKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKGtleSk7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKGRhdGFbMF0sIGAke2RhdGFbMV19LGAsIGRhdGFbMl0sIGAke2RhdGFbM119LGAsIGRhdGFbNF0sIGRhdGFbNV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgY2FzZSAncSc6XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goZGF0YVswXSwgYCR7ZGF0YVsxXX0sYCwgZGF0YVsyXSwgZGF0YVszXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKC4uLmRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b2tlbnMuam9pbignICcpO1xufVxuIiwiLy8gVHJhbnNsYXRlIHJlbGF0aXZlIGNvbW1hbmRzIHRvIGFic29sdXRlIGNvbW1hbmRzXG5leHBvcnQgZnVuY3Rpb24gYWJzb2x1dGl6ZShzZWdtZW50cykge1xuICAgIGxldCBjeCA9IDAsIGN5ID0gMDtcbiAgICBsZXQgc3VieCA9IDAsIHN1YnkgPSAwO1xuICAgIGNvbnN0IG91dCA9IFtdO1xuICAgIGZvciAoY29uc3QgeyBrZXksIGRhdGEgfSBvZiBzZWdtZW50cykge1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goeyBrZXk6ICdNJywgZGF0YTogWy4uLmRhdGFdIH0pO1xuICAgICAgICAgICAgICAgIFtjeCwgY3ldID0gZGF0YTtcbiAgICAgICAgICAgICAgICBbc3VieCwgc3VieV0gPSBkYXRhO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgY3ggKz0gZGF0YVswXTtcbiAgICAgICAgICAgICAgICBjeSArPSBkYXRhWzFdO1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKHsga2V5OiAnTScsIGRhdGE6IFtjeCwgY3ldIH0pO1xuICAgICAgICAgICAgICAgIHN1YnggPSBjeDtcbiAgICAgICAgICAgICAgICBzdWJ5ID0gY3k7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGtleTogJ0wnLCBkYXRhOiBbLi4uZGF0YV0gfSk7XG4gICAgICAgICAgICAgICAgW2N4LCBjeV0gPSBkYXRhO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgY3ggKz0gZGF0YVswXTtcbiAgICAgICAgICAgICAgICBjeSArPSBkYXRhWzFdO1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKHsga2V5OiAnTCcsIGRhdGE6IFtjeCwgY3ldIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goeyBrZXk6ICdDJywgZGF0YTogWy4uLmRhdGFdIH0pO1xuICAgICAgICAgICAgICAgIGN4ID0gZGF0YVs0XTtcbiAgICAgICAgICAgICAgICBjeSA9IGRhdGFbNV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld2RhdGEgPSBkYXRhLm1hcCgoZCwgaSkgPT4gKGkgJSAyKSA/IChkICsgY3kpIDogKGQgKyBjeCkpO1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKHsga2V5OiAnQycsIGRhdGE6IG5ld2RhdGEgfSk7XG4gICAgICAgICAgICAgICAgY3ggPSBuZXdkYXRhWzRdO1xuICAgICAgICAgICAgICAgIGN5ID0gbmV3ZGF0YVs1XTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgICAgIG91dC5wdXNoKHsga2V5OiAnUScsIGRhdGE6IFsuLi5kYXRhXSB9KTtcbiAgICAgICAgICAgICAgICBjeCA9IGRhdGFbMl07XG4gICAgICAgICAgICAgICAgY3kgPSBkYXRhWzNdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncSc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdkYXRhID0gZGF0YS5tYXAoKGQsIGkpID0+IChpICUgMikgPyAoZCArIGN5KSA6IChkICsgY3gpKTtcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGtleTogJ1EnLCBkYXRhOiBuZXdkYXRhIH0pO1xuICAgICAgICAgICAgICAgIGN4ID0gbmV3ZGF0YVsyXTtcbiAgICAgICAgICAgICAgICBjeSA9IG5ld2RhdGFbM107XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGtleTogJ0EnLCBkYXRhOiBbLi4uZGF0YV0gfSk7XG4gICAgICAgICAgICAgICAgY3ggPSBkYXRhWzVdO1xuICAgICAgICAgICAgICAgIGN5ID0gZGF0YVs2XTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgIGN4ICs9IGRhdGFbNV07XG4gICAgICAgICAgICAgICAgY3kgKz0gZGF0YVs2XTtcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGtleTogJ0EnLCBkYXRhOiBbZGF0YVswXSwgZGF0YVsxXSwgZGF0YVsyXSwgZGF0YVszXSwgZGF0YVs0XSwgY3gsIGN5XSB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgICAgIG91dC5wdXNoKHsga2V5OiAnSCcsIGRhdGE6IFsuLi5kYXRhXSB9KTtcbiAgICAgICAgICAgICAgICBjeCA9IGRhdGFbMF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgICAgICBjeCArPSBkYXRhWzBdO1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKHsga2V5OiAnSCcsIGRhdGE6IFtjeF0gfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGtleTogJ1YnLCBkYXRhOiBbLi4uZGF0YV0gfSk7XG4gICAgICAgICAgICAgICAgY3kgPSBkYXRhWzBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICAgICAgY3kgKz0gZGF0YVswXTtcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGtleTogJ1YnLCBkYXRhOiBbY3ldIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goeyBrZXk6ICdTJywgZGF0YTogWy4uLmRhdGFdIH0pO1xuICAgICAgICAgICAgICAgIGN4ID0gZGF0YVsyXTtcbiAgICAgICAgICAgICAgICBjeSA9IGRhdGFbM107XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld2RhdGEgPSBkYXRhLm1hcCgoZCwgaSkgPT4gKGkgJSAyKSA/IChkICsgY3kpIDogKGQgKyBjeCkpO1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKHsga2V5OiAnUycsIGRhdGE6IG5ld2RhdGEgfSk7XG4gICAgICAgICAgICAgICAgY3ggPSBuZXdkYXRhWzJdO1xuICAgICAgICAgICAgICAgIGN5ID0gbmV3ZGF0YVszXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgICAgICAgIG91dC5wdXNoKHsga2V5OiAnVCcsIGRhdGE6IFsuLi5kYXRhXSB9KTtcbiAgICAgICAgICAgICAgICBjeCA9IGRhdGFbMF07XG4gICAgICAgICAgICAgICAgY3kgPSBkYXRhWzFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgY3ggKz0gZGF0YVswXTtcbiAgICAgICAgICAgICAgICBjeSArPSBkYXRhWzFdO1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKHsga2V5OiAnVCcsIGRhdGE6IFtjeCwgY3ldIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGtleTogJ1onLCBkYXRhOiBbXSB9KTtcbiAgICAgICAgICAgICAgICBjeCA9IHN1Yng7XG4gICAgICAgICAgICAgICAgY3kgPSBzdWJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG4iLCIvLyBOb3JtYWxpemUgcGF0aCB0byBpbmNsdWRlIG9ubHkgTSwgTCwgQywgYW5kIFogY29tbWFuZHNcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUoc2VnbWVudHMpIHtcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBsZXQgbGFzdFR5cGUgPSAnJztcbiAgICBsZXQgY3ggPSAwLCBjeSA9IDA7XG4gICAgbGV0IHN1YnggPSAwLCBzdWJ5ID0gMDtcbiAgICBsZXQgbGN4ID0gMCwgbGN5ID0gMDtcbiAgICBmb3IgKGNvbnN0IHsga2V5LCBkYXRhIH0gb2Ygc2VnbWVudHMpIHtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgIG91dC5wdXNoKHsga2V5OiAnTScsIGRhdGE6IFsuLi5kYXRhXSB9KTtcbiAgICAgICAgICAgICAgICBbY3gsIGN5XSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgW3N1YngsIHN1YnldID0gZGF0YTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgIG91dC5wdXNoKHsga2V5OiAnQycsIGRhdGE6IFsuLi5kYXRhXSB9KTtcbiAgICAgICAgICAgICAgICBjeCA9IGRhdGFbNF07XG4gICAgICAgICAgICAgICAgY3kgPSBkYXRhWzVdO1xuICAgICAgICAgICAgICAgIGxjeCA9IGRhdGFbMl07XG4gICAgICAgICAgICAgICAgbGN5ID0gZGF0YVszXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgIG91dC5wdXNoKHsga2V5OiAnTCcsIGRhdGE6IFsuLi5kYXRhXSB9KTtcbiAgICAgICAgICAgICAgICBbY3gsIGN5XSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICAgICAgICBjeCA9IGRhdGFbMF07XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goeyBrZXk6ICdMJywgZGF0YTogW2N4LCBjeV0gfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICAgICAgICBjeSA9IGRhdGFbMF07XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goeyBrZXk6ICdMJywgZGF0YTogW2N4LCBjeV0gfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdTJzoge1xuICAgICAgICAgICAgICAgIGxldCBjeDEgPSAwLCBjeTEgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0VHlwZSA9PT0gJ0MnIHx8IGxhc3RUeXBlID09PSAnUycpIHtcbiAgICAgICAgICAgICAgICAgICAgY3gxID0gY3ggKyAoY3ggLSBsY3gpO1xuICAgICAgICAgICAgICAgICAgICBjeTEgPSBjeSArIChjeSAtIGxjeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjeDEgPSBjeDtcbiAgICAgICAgICAgICAgICAgICAgY3kxID0gY3k7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dC5wdXNoKHsga2V5OiAnQycsIGRhdGE6IFtjeDEsIGN5MSwgLi4uZGF0YV0gfSk7XG4gICAgICAgICAgICAgICAgbGN4ID0gZGF0YVswXTtcbiAgICAgICAgICAgICAgICBsY3kgPSBkYXRhWzFdO1xuICAgICAgICAgICAgICAgIGN4ID0gZGF0YVsyXTtcbiAgICAgICAgICAgICAgICBjeSA9IGRhdGFbM107XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdUJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IFt4LCB5XSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgbGV0IHgxID0gMCwgeTEgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0VHlwZSA9PT0gJ1EnIHx8IGxhc3RUeXBlID09PSAnVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgeDEgPSBjeCArIChjeCAtIGxjeCk7XG4gICAgICAgICAgICAgICAgICAgIHkxID0gY3kgKyAoY3kgLSBsY3kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeDEgPSBjeDtcbiAgICAgICAgICAgICAgICAgICAgeTEgPSBjeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY3gxID0gY3ggKyAyICogKHgxIC0gY3gpIC8gMztcbiAgICAgICAgICAgICAgICBjb25zdCBjeTEgPSBjeSArIDIgKiAoeTEgLSBjeSkgLyAzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN4MiA9IHggKyAyICogKHgxIC0geCkgLyAzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN5MiA9IHkgKyAyICogKHkxIC0geSkgLyAzO1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKHsga2V5OiAnQycsIGRhdGE6IFtjeDEsIGN5MSwgY3gyLCBjeTIsIHgsIHldIH0pO1xuICAgICAgICAgICAgICAgIGxjeCA9IHgxO1xuICAgICAgICAgICAgICAgIGxjeSA9IHkxO1xuICAgICAgICAgICAgICAgIGN4ID0geDtcbiAgICAgICAgICAgICAgICBjeSA9IHk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdRJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IFt4MSwgeTEsIHgsIHldID0gZGF0YTtcbiAgICAgICAgICAgICAgICBjb25zdCBjeDEgPSBjeCArIDIgKiAoeDEgLSBjeCkgLyAzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN5MSA9IGN5ICsgMiAqICh5MSAtIGN5KSAvIDM7XG4gICAgICAgICAgICAgICAgY29uc3QgY3gyID0geCArIDIgKiAoeDEgLSB4KSAvIDM7XG4gICAgICAgICAgICAgICAgY29uc3QgY3kyID0geSArIDIgKiAoeTEgLSB5KSAvIDM7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goeyBrZXk6ICdDJywgZGF0YTogW2N4MSwgY3kxLCBjeDIsIGN5MiwgeCwgeV0gfSk7XG4gICAgICAgICAgICAgICAgbGN4ID0geDE7XG4gICAgICAgICAgICAgICAgbGN5ID0geTE7XG4gICAgICAgICAgICAgICAgY3ggPSB4O1xuICAgICAgICAgICAgICAgIGN5ID0geTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0EnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcjEgPSBNYXRoLmFicyhkYXRhWzBdKTtcbiAgICAgICAgICAgICAgICBjb25zdCByMiA9IE1hdGguYWJzKGRhdGFbMV0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuZ2xlID0gZGF0YVsyXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXJnZUFyY0ZsYWcgPSBkYXRhWzNdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN3ZWVwRmxhZyA9IGRhdGFbNF07XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IGRhdGFbNV07XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IGRhdGFbNl07XG4gICAgICAgICAgICAgICAgaWYgKHIxID09PSAwIHx8IHIyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKHsga2V5OiAnQycsIGRhdGE6IFtjeCwgY3ksIHgsIHksIHgsIHldIH0pO1xuICAgICAgICAgICAgICAgICAgICBjeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIGN5ID0geTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjeCAhPT0geCB8fCBjeSAhPT0geSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VydmVzID0gYXJjVG9DdWJpY0N1cnZlcyhjeCwgY3ksIHgsIHksIHIxLCByMiwgYW5nbGUsIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlcy5mb3JFYWNoKGZ1bmN0aW9uIChjdXJ2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKHsga2V5OiAnQycsIGRhdGE6IGN1cnZlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGtleTogJ1onLCBkYXRhOiBbXSB9KTtcbiAgICAgICAgICAgICAgICBjeCA9IHN1Yng7XG4gICAgICAgICAgICAgICAgY3kgPSBzdWJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RUeXBlID0ga2V5O1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gZGVnVG9SYWQoZGVncmVlcykge1xuICAgIHJldHVybiAoTWF0aC5QSSAqIGRlZ3JlZXMpIC8gMTgwO1xufVxuZnVuY3Rpb24gcm90YXRlKHgsIHksIGFuZ2xlUmFkKSB7XG4gICAgY29uc3QgWCA9IHggKiBNYXRoLmNvcyhhbmdsZVJhZCkgLSB5ICogTWF0aC5zaW4oYW5nbGVSYWQpO1xuICAgIGNvbnN0IFkgPSB4ICogTWF0aC5zaW4oYW5nbGVSYWQpICsgeSAqIE1hdGguY29zKGFuZ2xlUmFkKTtcbiAgICByZXR1cm4gW1gsIFldO1xufVxuZnVuY3Rpb24gYXJjVG9DdWJpY0N1cnZlcyh4MSwgeTEsIHgyLCB5MiwgcjEsIHIyLCBhbmdsZSwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIHJlY3Vyc2l2ZSkge1xuICAgIGNvbnN0IGFuZ2xlUmFkID0gZGVnVG9SYWQoYW5nbGUpO1xuICAgIGxldCBwYXJhbXMgPSBbXTtcbiAgICBsZXQgZjEgPSAwLCBmMiA9IDAsIGN4ID0gMCwgY3kgPSAwO1xuICAgIGlmIChyZWN1cnNpdmUpIHtcbiAgICAgICAgW2YxLCBmMiwgY3gsIGN5XSA9IHJlY3Vyc2l2ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIFt4MSwgeTFdID0gcm90YXRlKHgxLCB5MSwgLWFuZ2xlUmFkKTtcbiAgICAgICAgW3gyLCB5Ml0gPSByb3RhdGUoeDIsIHkyLCAtYW5nbGVSYWQpO1xuICAgICAgICBjb25zdCB4ID0gKHgxIC0geDIpIC8gMjtcbiAgICAgICAgY29uc3QgeSA9ICh5MSAtIHkyKSAvIDI7XG4gICAgICAgIGxldCBoID0gKHggKiB4KSAvIChyMSAqIHIxKSArICh5ICogeSkgLyAocjIgKiByMik7XG4gICAgICAgIGlmIChoID4gMSkge1xuICAgICAgICAgICAgaCA9IE1hdGguc3FydChoKTtcbiAgICAgICAgICAgIHIxID0gaCAqIHIxO1xuICAgICAgICAgICAgcjIgPSBoICogcjI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lnbiA9IChsYXJnZUFyY0ZsYWcgPT09IHN3ZWVwRmxhZykgPyAtMSA6IDE7XG4gICAgICAgIGNvbnN0IHIxUG93ID0gcjEgKiByMTtcbiAgICAgICAgY29uc3QgcjJQb3cgPSByMiAqIHIyO1xuICAgICAgICBjb25zdCBsZWZ0ID0gcjFQb3cgKiByMlBvdyAtIHIxUG93ICogeSAqIHkgLSByMlBvdyAqIHggKiB4O1xuICAgICAgICBjb25zdCByaWdodCA9IHIxUG93ICogeSAqIHkgKyByMlBvdyAqIHggKiB4O1xuICAgICAgICBjb25zdCBrID0gc2lnbiAqIE1hdGguc3FydChNYXRoLmFicyhsZWZ0IC8gcmlnaHQpKTtcbiAgICAgICAgY3ggPSBrICogcjEgKiB5IC8gcjIgKyAoeDEgKyB4MikgLyAyO1xuICAgICAgICBjeSA9IGsgKiAtcjIgKiB4IC8gcjEgKyAoeTEgKyB5MikgLyAyO1xuICAgICAgICBmMSA9IE1hdGguYXNpbihwYXJzZUZsb2F0KCgoeTEgLSBjeSkgLyByMikudG9GaXhlZCg5KSkpO1xuICAgICAgICBmMiA9IE1hdGguYXNpbihwYXJzZUZsb2F0KCgoeTIgLSBjeSkgLyByMikudG9GaXhlZCg5KSkpO1xuICAgICAgICBpZiAoeDEgPCBjeCkge1xuICAgICAgICAgICAgZjEgPSBNYXRoLlBJIC0gZjE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHgyIDwgY3gpIHtcbiAgICAgICAgICAgIGYyID0gTWF0aC5QSSAtIGYyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmMSA8IDApIHtcbiAgICAgICAgICAgIGYxID0gTWF0aC5QSSAqIDIgKyBmMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZjIgPCAwKSB7XG4gICAgICAgICAgICBmMiA9IE1hdGguUEkgKiAyICsgZjI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN3ZWVwRmxhZyAmJiBmMSA+IGYyKSB7XG4gICAgICAgICAgICBmMSA9IGYxIC0gTWF0aC5QSSAqIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzd2VlcEZsYWcgJiYgZjIgPiBmMSkge1xuICAgICAgICAgICAgZjIgPSBmMiAtIE1hdGguUEkgKiAyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBkZiA9IGYyIC0gZjE7XG4gICAgaWYgKE1hdGguYWJzKGRmKSA+IChNYXRoLlBJICogMTIwIC8gMTgwKSkge1xuICAgICAgICBjb25zdCBmMm9sZCA9IGYyO1xuICAgICAgICBjb25zdCB4Mm9sZCA9IHgyO1xuICAgICAgICBjb25zdCB5Mm9sZCA9IHkyO1xuICAgICAgICBpZiAoc3dlZXBGbGFnICYmIGYyID4gZjEpIHtcbiAgICAgICAgICAgIGYyID0gZjEgKyAoTWF0aC5QSSAqIDEyMCAvIDE4MCkgKiAoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmMiA9IGYxICsgKE1hdGguUEkgKiAxMjAgLyAxODApICogKC0xKTtcbiAgICAgICAgfVxuICAgICAgICB4MiA9IGN4ICsgcjEgKiBNYXRoLmNvcyhmMik7XG4gICAgICAgIHkyID0gY3kgKyByMiAqIE1hdGguc2luKGYyKTtcbiAgICAgICAgcGFyYW1zID0gYXJjVG9DdWJpY0N1cnZlcyh4MiwgeTIsIHgyb2xkLCB5Mm9sZCwgcjEsIHIyLCBhbmdsZSwgMCwgc3dlZXBGbGFnLCBbZjIsIGYyb2xkLCBjeCwgY3ldKTtcbiAgICB9XG4gICAgZGYgPSBmMiAtIGYxO1xuICAgIGNvbnN0IGMxID0gTWF0aC5jb3MoZjEpO1xuICAgIGNvbnN0IHMxID0gTWF0aC5zaW4oZjEpO1xuICAgIGNvbnN0IGMyID0gTWF0aC5jb3MoZjIpO1xuICAgIGNvbnN0IHMyID0gTWF0aC5zaW4oZjIpO1xuICAgIGNvbnN0IHQgPSBNYXRoLnRhbihkZiAvIDQpO1xuICAgIGNvbnN0IGh4ID0gNCAvIDMgKiByMSAqIHQ7XG4gICAgY29uc3QgaHkgPSA0IC8gMyAqIHIyICogdDtcbiAgICBjb25zdCBtMSA9IFt4MSwgeTFdO1xuICAgIGNvbnN0IG0yID0gW3gxICsgaHggKiBzMSwgeTEgLSBoeSAqIGMxXTtcbiAgICBjb25zdCBtMyA9IFt4MiArIGh4ICogczIsIHkyIC0gaHkgKiBjMl07XG4gICAgY29uc3QgbTQgPSBbeDIsIHkyXTtcbiAgICBtMlswXSA9IDIgKiBtMVswXSAtIG0yWzBdO1xuICAgIG0yWzFdID0gMiAqIG0xWzFdIC0gbTJbMV07XG4gICAgaWYgKHJlY3Vyc2l2ZSkge1xuICAgICAgICByZXR1cm4gW20yLCBtMywgbTRdLmNvbmNhdChwYXJhbXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGFyYW1zID0gW20yLCBtMywgbTRdLmNvbmNhdChwYXJhbXMpO1xuICAgICAgICBjb25zdCBjdXJ2ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGNvbnN0IHIxID0gcm90YXRlKHBhcmFtc1tpXVswXSwgcGFyYW1zW2ldWzFdLCBhbmdsZVJhZCk7XG4gICAgICAgICAgICBjb25zdCByMiA9IHJvdGF0ZShwYXJhbXNbaSArIDFdWzBdLCBwYXJhbXNbaSArIDFdWzFdLCBhbmdsZVJhZCk7XG4gICAgICAgICAgICBjb25zdCByMyA9IHJvdGF0ZShwYXJhbXNbaSArIDJdWzBdLCBwYXJhbXNbaSArIDJdWzFdLCBhbmdsZVJhZCk7XG4gICAgICAgICAgICBjdXJ2ZXMucHVzaChbcjFbMF0sIHIxWzFdLCByMlswXSwgcjJbMV0sIHIzWzBdLCByM1sxXV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJ2ZXM7XG4gICAgfVxufVxuIiwiZXhwb3J0IHsgcGFyc2VQYXRoLCBzZXJpYWxpemUgfSBmcm9tICcuL3BhcnNlci5qcyc7XG5leHBvcnQgeyBhYnNvbHV0aXplIH0gZnJvbSAnLi9hYnNvbHV0aXplLmpzJztcbmV4cG9ydCB7IG5vcm1hbGl6ZSB9IGZyb20gJy4vbm9ybWFsaXplLmpzJztcbiIsImltcG9ydCB7IHBvaW50c09uQmV6aWVyQ3VydmVzLCBzaW1wbGlmeSB9IGZyb20gJ3BvaW50cy1vbi1jdXJ2ZSc7XG5pbXBvcnQgeyBwYXJzZVBhdGgsIGFic29sdXRpemUsIG5vcm1hbGl6ZSB9IGZyb20gJ3BhdGgtZGF0YS1wYXJzZXInO1xuZXhwb3J0IGZ1bmN0aW9uIHBvaW50c09uUGF0aChwYXRoLCB0b2xlcmFuY2UsIGRpc3RhbmNlKSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBwYXJzZVBhdGgocGF0aCk7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZShhYnNvbHV0aXplKHNlZ21lbnRzKSk7XG4gICAgY29uc3Qgc2V0cyA9IFtdO1xuICAgIGxldCBjdXJyZW50UG9pbnRzID0gW107XG4gICAgbGV0IHN0YXJ0ID0gWzAsIDBdO1xuICAgIGxldCBwZW5kaW5nQ3VydmUgPSBbXTtcbiAgICBjb25zdCBhcHBlbmRQZW5kaW5nQ3VydmUgPSAoKSA9PiB7XG4gICAgICAgIGlmIChwZW5kaW5nQ3VydmUubGVuZ3RoID49IDQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludHMucHVzaCguLi5wb2ludHNPbkJlemllckN1cnZlcyhwZW5kaW5nQ3VydmUsIHRvbGVyYW5jZSkpO1xuICAgICAgICB9XG4gICAgICAgIHBlbmRpbmdDdXJ2ZSA9IFtdO1xuICAgIH07XG4gICAgY29uc3QgYXBwZW5kUGVuZGluZ1BvaW50cyA9ICgpID0+IHtcbiAgICAgICAgYXBwZW5kUGVuZGluZ0N1cnZlKCk7XG4gICAgICAgIGlmIChjdXJyZW50UG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgc2V0cy5wdXNoKGN1cnJlbnRQb2ludHMpO1xuICAgICAgICAgICAgY3VycmVudFBvaW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHsga2V5LCBkYXRhIH0gb2Ygbm9ybWFsaXplZCkge1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgYXBwZW5kUGVuZGluZ1BvaW50cygpO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gW2RhdGFbMF0sIGRhdGFbMV1dO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb2ludHMucHVzaChzdGFydCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgICAgICBhcHBlbmRQZW5kaW5nQ3VydmUoKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9pbnRzLnB1c2goW2RhdGFbMF0sIGRhdGFbMV1dKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgIGlmICghcGVuZGluZ0N1cnZlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0UG9pbnQgPSBjdXJyZW50UG9pbnRzLmxlbmd0aCA/IGN1cnJlbnRQb2ludHNbY3VycmVudFBvaW50cy5sZW5ndGggLSAxXSA6IHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nQ3VydmUucHVzaChbbGFzdFBvaW50WzBdLCBsYXN0UG9pbnRbMV1dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGVuZGluZ0N1cnZlLnB1c2goW2RhdGFbMF0sIGRhdGFbMV1dKTtcbiAgICAgICAgICAgICAgICBwZW5kaW5nQ3VydmUucHVzaChbZGF0YVsyXSwgZGF0YVszXV0pO1xuICAgICAgICAgICAgICAgIHBlbmRpbmdDdXJ2ZS5wdXNoKFtkYXRhWzRdLCBkYXRhWzVdXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICAgICAgICBhcHBlbmRQZW5kaW5nQ3VydmUoKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9pbnRzLnB1c2goW3N0YXJ0WzBdLCBzdGFydFsxXV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGVuZFBlbmRpbmdQb2ludHMoKTtcbiAgICBpZiAoIWRpc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBzZXRzO1xuICAgIH1cbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHNldCBvZiBzZXRzKSB7XG4gICAgICAgIGNvbnN0IHNpbXBsaWZpZWRTZXQgPSBzaW1wbGlmeShzZXQsIGRpc3RhbmNlKTtcbiAgICAgICAgaWYgKHNpbXBsaWZpZWRTZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdXQucHVzaChzaW1wbGlmaWVkU2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuIiwiaW1wb3J0IHsgbWF0NCB9IGZyb20gXCJnbC1tYXRyaXhcIjtcbmltcG9ydCB7IGRpbWVuc2lvbnNGcm9tUG9pbnRzIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCBFeGNhbGlkcmF3U2NlbmUgZnJvbSBcIi4vZWxlbWVudHMvRXhjYWxpZHJhd1NjZW5lXCI7XG5pbXBvcnQgR3JvdXAsIHsgZ2V0R3JvdXBBdHRycyB9IGZyb20gXCIuL2VsZW1lbnRzL0dyb3VwXCI7XG5pbXBvcnQge1xuICBFeGNhbGlkcmF3RWxlbWVudEJhc2UsXG4gIEV4Y2FsaWRyYXdSZWN0YW5nbGUsXG4gIEV4Y2FsaWRyYXdFbGxpcHNlLFxuICBFeGNhbGlkcmF3TGluZSxcbiAgRXhjYWxpZHJhd0RyYXcsXG4gIGNyZWF0ZUV4UmVjdCxcbiAgY3JlYXRlRXhFbGxpcHNlLFxuICBjcmVhdGVFeExpbmUsXG4gIGNyZWF0ZUV4RHJhdyxcbiAgUG9pbnQsXG59IGZyb20gXCIuL2VsZW1lbnRzL0V4Y2FsaWRyYXdFbGVtZW50XCI7XG5pbXBvcnQge1xuICBwcmVzQXR0cnNUb0VsZW1lbnRWYWx1ZXMsXG4gIGZpbHRlckF0dHJzVG9FbGVtZW50VmFsdWVzLFxuICBwb2ludHNBdHRyVG9Qb2ludHMsXG4gIGhhcyxcbiAgZ2V0LFxuICBnZXROdW0sXG59IGZyb20gXCIuL2F0dHJpYnV0ZXNcIjtcbmltcG9ydCB7IGdldFRyYW5zZm9ybU1hdHJpeCwgdHJhbnNmb3JtUG9pbnRzIH0gZnJvbSBcIi4vdHJhbnNmb3JtXCI7XG5pbXBvcnQgeyBwb2ludHNPblBhdGggfSBmcm9tIFwicG9pbnRzLW9uLXBhdGhcIjtcbmltcG9ydCB7IHJhbmRvbUlkLCBnZXRXaW5kaW5nT3JkZXIgfSBmcm9tIFwiLi91dGlsc1wiO1xuXG5jb25zdCBTVVBQT1JURURfVEFHUyA9IFtcbiAgXCJzdmdcIixcbiAgXCJwYXRoXCIsXG4gIFwiZ1wiLFxuICBcInVzZVwiLFxuICBcImNpcmNsZVwiLFxuICBcImVsbGlwc2VcIixcbiAgXCJyZWN0XCIsXG4gIFwicG9seWxpbmVcIixcbiAgXCJwb2x5Z29uXCIsXG5dO1xuXG5jb25zdCBub2RlVmFsaWRhdG9yID0gKG5vZGU6IEVsZW1lbnQpOiBudW1iZXIgPT4ge1xuICBpZiAoU1VQUE9SVEVEX1RBR1MuaW5jbHVkZXMobm9kZS50YWdOYW1lKSkge1xuICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQ7XG4gIH1cblxuICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfUkVKRUNUO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRyZWVXYWxrZXIoZG9tOiBOb2RlKTogVHJlZVdhbGtlciB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGRvbSwgTm9kZUZpbHRlci5TSE9XX0FMTCwge1xuICAgIGFjY2VwdE5vZGU6IG5vZGVWYWxpZGF0b3IsXG4gIH0pO1xufVxuXG50eXBlIFdhbGtlckFyZ3MgPSB7XG4gIHJvb3Q6IERvY3VtZW50O1xuICB0dzogVHJlZVdhbGtlcjtcbiAgc2NlbmU6IEV4Y2FsaWRyYXdTY2VuZTtcbiAgZ3JvdXBzOiBHcm91cFtdO1xufTtcblxuY29uc3QgcHJlc0F0dHJzID0gKFxuICBlbDogRWxlbWVudCxcbiAgZ3JvdXBzOiBHcm91cFtdLFxuKTogUGFydGlhbDxFeGNhbGlkcmF3RWxlbWVudEJhc2U+ID0+IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5nZXRHcm91cEF0dHJzKGdyb3VwcyksXG4gICAgLi4ucHJlc0F0dHJzVG9FbGVtZW50VmFsdWVzKGVsKSxcbiAgICAuLi5maWx0ZXJBdHRyc1RvRWxlbWVudFZhbHVlcyhlbCksXG4gIH07XG59O1xuXG5jb25zdCBza2lwcGVkVXNlQXR0cnMgPSBbXCJpZFwiXTtcbmNvbnN0IGFsbHdheXNQYXNzZWRVc2VBdHRycyA9IFtcbiAgXCJ4XCIsXG4gIFwieVwiLFxuICBcIndpZHRoXCIsXG4gIFwiaGVpZ2h0XCIsXG4gIFwiaHJlZlwiLFxuICBcInhsaW5rOmhyZWZcIixcbl07XG5cbi8qXG4gIFwiTW9zdCBhdHRyaWJ1dGVzIG9uIHVzZSBkbyBub3Qgb3ZlcnJpZGUgdGhvc2UgYWxyZWFkeSBvbiB0aGUgZWxlbWVudFxuICByZWZlcmVuY2VkIGJ5IHVzZS4gKFRoaXMgZGlmZmVycyBmcm9tIGhvdyBDU1Mgc3R5bGUgYXR0cmlidXRlcyBvdmVycmlkZVxuICB0aG9zZSBzZXQgJ2VhcmxpZXInIGluIHRoZSBjYXNjYWRlKS4gT25seSB0aGUgYXR0cmlidXRlcyB4LCB5LCB3aWR0aCxcbiAgaGVpZ2h0IGFuZCBocmVmIG9uIHRoZSB1c2UgZWxlbWVudCB3aWxsIG92ZXJyaWRlIHRob3NlIHNldCBvbiB0aGVcbiAgcmVmZXJlbmNlZCBlbGVtZW50LiBIb3dldmVyLCBhbnkgb3RoZXIgYXR0cmlidXRlcyBub3Qgc2V0IG9uIHRoZSByZWZlcmVuY2VkXG4gIGVsZW1lbnQgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSB1c2UgZWxlbWVudC5cIlxuXG4gIFNpdHVhdGlvbiAxOiBBdHRyIGlzIHNldCBvbiBkZWZFbCwgTk9UIG9uIHVzZUVsXG4gICAgLSByZXN1bHQ6IHVzZSBkZWZFbCBhdHRyXG4gIFNpdHVhdGlvbiAyOiBBdHRyIGlzIG9uIHVzZUVsLCBOT1Qgb24gZGVmRWxcbiAgICAtIHJlc3VsdDogdXNlIHRoZSB1c2VFbCBhdHRyXG4gIFNpdHVhdGlvbiAzOiBBdHRyIGlzIG9uIGJvdGggdXNlRWwgYW5kIGRlZkVsXG4gICAgLSByZXN1bHQ6IHVzZSB0aGUgZGVmRWwgYXR0ciAoVW5sZXNzIHgsIHksIHdpZHRoLCBoZWlnaHQsIGhyZWYsIHhsaW5rOmhyZWYpXG4qL1xuY29uc3QgZ2V0RGVmRWxXaXRoQ29ycmVjdEF0dHJzID0gKGRlZkVsOiBFbGVtZW50LCB1c2VFbDogRWxlbWVudCk6IEVsZW1lbnQgPT4ge1xuICBjb25zdCBmaW5hbEVsID0gWy4uLnVzZUVsLmF0dHJpYnV0ZXNdLnJlZHVjZSgoZWwsIGF0dHIpID0+IHtcbiAgICBpZiAoc2tpcHBlZFVzZUF0dHJzLmluY2x1ZGVzKGF0dHIudmFsdWUpKSB7XG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuXG4gICAgLy8gRG9lcyBkZWZFbCBoYXZlIHRoZSBhdHRyPyBJZiBzbywgdXNlIGl0LCBlbHNlIHVzZSB0aGUgdXNlRWwgYXR0clxuICAgIGlmIChcbiAgICAgICFkZWZFbC5oYXNBdHRyaWJ1dGUoYXR0ci5uYW1lKSB8fFxuICAgICAgYWxsd2F5c1Bhc3NlZFVzZUF0dHJzLmluY2x1ZGVzKGF0dHIubmFtZSlcbiAgICApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyLm5hbWUsIHVzZUVsLmdldEF0dHJpYnV0ZShhdHRyLm5hbWUpIHx8IFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZWw7XG4gIH0sIGRlZkVsLmNsb25lTm9kZSgpIGFzIEVsZW1lbnQpO1xuXG4gIHJldHVybiBmaW5hbEVsO1xufTtcblxuY29uc3Qgd2Fsa2VycyA9IHtcbiAgc3ZnOiAoYXJnczogV2Fsa2VyQXJncykgPT4ge1xuICAgIHdhbGsoYXJncywgYXJncy50dy5uZXh0Tm9kZSgpKTtcbiAgfSxcblxuICBnOiAoYXJnczogV2Fsa2VyQXJncykgPT4ge1xuICAgIGNvbnN0IG5leHRBcmdzID0ge1xuICAgICAgLi4uYXJncyxcbiAgICAgIHR3OiBjcmVhdGVUcmVlV2Fsa2VyKGFyZ3MudHcuY3VycmVudE5vZGUpLFxuICAgICAgZ3JvdXBzOiBbLi4uYXJncy5ncm91cHMsIG5ldyBHcm91cChhcmdzLnR3LmN1cnJlbnROb2RlIGFzIEVsZW1lbnQpXSxcbiAgICB9O1xuXG4gICAgd2FsayhuZXh0QXJncywgbmV4dEFyZ3MudHcubmV4dE5vZGUoKSk7XG5cbiAgICB3YWxrKGFyZ3MsIGFyZ3MudHcubmV4dFNpYmxpbmcoKSk7XG4gIH0sXG5cbiAgdXNlOiAoYXJnczogV2Fsa2VyQXJncykgPT4ge1xuICAgIGNvbnN0IHsgcm9vdCwgdHcsIHNjZW5lIH0gPSBhcmdzO1xuICAgIGNvbnN0IHVzZUVsID0gdHcuY3VycmVudE5vZGUgYXMgRWxlbWVudDtcblxuICAgIGNvbnN0IGlkID0gdXNlRWwuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSB8fCB1c2VFbC5nZXRBdHRyaWJ1dGUoXCJ4bGluazpocmVmXCIpO1xuXG4gICAgaWYgKCFpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5hYmxlIHRvIGdldCBpZCBvZiB1c2UgZWxlbWVudFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWZFbCA9IHJvb3QucXVlcnlTZWxlY3RvcihpZCk7XG5cbiAgICBpZiAoIWRlZkVsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuYWJsZSB0byBmaW5kIGRlZiBlbGVtZW50IHdpdGggaWQ6ICR7aWR9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgdGVtcFNjZW5lID0gbmV3IEV4Y2FsaWRyYXdTY2VuZSgpO1xuXG4gICAgY29uc3QgZmluYWxFbCA9IGdldERlZkVsV2l0aENvcnJlY3RBdHRycyhkZWZFbCwgdXNlRWwpO1xuXG4gICAgd2FsayhcbiAgICAgIHtcbiAgICAgICAgLi4uYXJncyxcbiAgICAgICAgc2NlbmU6IHRlbXBTY2VuZSxcbiAgICAgICAgdHc6IGNyZWF0ZVRyZWVXYWxrZXIoZmluYWxFbCksXG4gICAgICB9LFxuICAgICAgZmluYWxFbCxcbiAgICApO1xuXG4gICAgY29uc3QgZXhFbCA9IHRlbXBTY2VuZS5lbGVtZW50cy5wb3AoKTtcblxuICAgIGlmICghZXhFbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNyZWF0ZSBleCBlbGVtZW50XCIpO1xuICAgIH1cblxuICAgIHNjZW5lLmVsZW1lbnRzLnB1c2goZXhFbCk7XG5cbiAgICB3YWxrKGFyZ3MsIGFyZ3MudHcubmV4dE5vZGUoKSk7XG4gIH0sXG5cbiAgY2lyY2xlOiAoYXJnczogV2Fsa2VyQXJncyk6IHZvaWQgPT4ge1xuICAgIGNvbnN0IHsgdHcsIHNjZW5lLCBncm91cHMgfSA9IGFyZ3M7XG4gICAgY29uc3QgZWwgPSB0dy5jdXJyZW50Tm9kZSBhcyBFbGVtZW50O1xuXG4gICAgY29uc3QgciA9IGdldE51bShlbCwgXCJyXCIsIDApO1xuICAgIGNvbnN0IGQgPSByICogMjtcbiAgICBjb25zdCB4ID0gZ2V0TnVtKGVsLCBcInhcIiwgMCkgKyBnZXROdW0oZWwsIFwiY3hcIiwgMCkgLSByO1xuICAgIGNvbnN0IHkgPSBnZXROdW0oZWwsIFwieVwiLCAwKSArIGdldE51bShlbCwgXCJjeVwiLCAwKSAtIHI7XG5cbiAgICBjb25zdCBtYXQgPSBnZXRUcmFuc2Zvcm1NYXRyaXgoZWwsIGdyb3Vwcyk7XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgbSA9IG1hdDQuZnJvbVZhbHVlcyhkLCAwLCAwLCAwLCAwLCBkLCAwLCAwLCAwLCAwLCAxLCAwLCB4LCB5LCAwLCAxKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IG1hdDQubXVsdGlwbHkobWF0NC5jcmVhdGUoKSwgbWF0LCBtKTtcblxuICAgIGNvbnN0IGNpcmNsZTogRXhjYWxpZHJhd0VsbGlwc2UgPSB7XG4gICAgICAuLi5jcmVhdGVFeEVsbGlwc2UoKSxcbiAgICAgIC4uLnByZXNBdHRycyhlbCwgZ3JvdXBzKSxcbiAgICAgIHg6IHJlc3VsdFsxMl0sXG4gICAgICB5OiByZXN1bHRbMTNdLFxuICAgICAgd2lkdGg6IHJlc3VsdFswXSxcbiAgICAgIGhlaWdodDogcmVzdWx0WzVdLFxuICAgICAgZ3JvdXBJZHM6IGdyb3Vwcy5tYXAoKGcpID0+IGcuaWQpLFxuICAgIH07XG5cbiAgICBzY2VuZS5lbGVtZW50cy5wdXNoKGNpcmNsZSk7XG5cbiAgICB3YWxrKGFyZ3MsIHR3Lm5leHROb2RlKCkpO1xuICB9LFxuXG4gIGVsbGlwc2U6IChhcmdzOiBXYWxrZXJBcmdzKTogdm9pZCA9PiB7XG4gICAgY29uc3QgeyB0dywgc2NlbmUsIGdyb3VwcyB9ID0gYXJncztcbiAgICBjb25zdCBlbCA9IHR3LmN1cnJlbnROb2RlIGFzIEVsZW1lbnQ7XG5cbiAgICBjb25zdCByeCA9IGdldE51bShlbCwgXCJyeFwiLCAwKTtcbiAgICBjb25zdCByeSA9IGdldE51bShlbCwgXCJyeVwiLCAwKTtcbiAgICBjb25zdCBjeCA9IGdldE51bShlbCwgXCJjeFwiLCAwKTtcbiAgICBjb25zdCBjeSA9IGdldE51bShlbCwgXCJjeVwiLCAwKTtcbiAgICBjb25zdCB4ID0gZ2V0TnVtKGVsLCBcInhcIiwgMCkgKyBjeCAtIHJ4O1xuICAgIGNvbnN0IHkgPSBnZXROdW0oZWwsIFwieVwiLCAwKSArIGN5IC0gcnk7XG4gICAgY29uc3QgdyA9IHJ4ICogMjtcbiAgICBjb25zdCBoID0gcnkgKiAyO1xuXG4gICAgY29uc3QgbWF0ID0gZ2V0VHJhbnNmb3JtTWF0cml4KGVsLCBncm91cHMpO1xuXG4gICAgY29uc3QgbSA9IG1hdDQuZnJvbVZhbHVlcyh3LCAwLCAwLCAwLCAwLCBoLCAwLCAwLCAwLCAwLCAxLCAwLCB4LCB5LCAwLCAxKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IG1hdDQubXVsdGlwbHkobWF0NC5jcmVhdGUoKSwgbWF0LCBtKTtcblxuICAgIGNvbnN0IGVsbGlwc2U6IEV4Y2FsaWRyYXdFbGxpcHNlID0ge1xuICAgICAgLi4uY3JlYXRlRXhFbGxpcHNlKCksXG4gICAgICAuLi5wcmVzQXR0cnMoZWwsIGdyb3VwcyksXG4gICAgICB4OiByZXN1bHRbMTJdLFxuICAgICAgeTogcmVzdWx0WzEzXSxcbiAgICAgIHdpZHRoOiByZXN1bHRbMF0sXG4gICAgICBoZWlnaHQ6IHJlc3VsdFs1XSxcbiAgICAgIGdyb3VwSWRzOiBncm91cHMubWFwKChnKSA9PiBnLmlkKSxcbiAgICB9O1xuXG4gICAgc2NlbmUuZWxlbWVudHMucHVzaChlbGxpcHNlKTtcblxuICAgIHdhbGsoYXJncywgdHcubmV4dE5vZGUoKSk7XG4gIH0sXG5cbiAgbGluZTogKGFyZ3M6IFdhbGtlckFyZ3MpID0+IHtcbiAgICAvLyB1bmltcGxlbWVudGVkXG4gICAgd2FsayhhcmdzLCBhcmdzLnR3Lm5leHROb2RlKCkpO1xuICB9LFxuXG4gIHBvbHlnb246IChhcmdzOiBXYWxrZXJBcmdzKSA9PiB7XG4gICAgY29uc3QgeyB0dywgc2NlbmUsIGdyb3VwcyB9ID0gYXJncztcbiAgICBjb25zdCBlbCA9IHR3LmN1cnJlbnROb2RlIGFzIEVsZW1lbnQ7XG5cbiAgICBjb25zdCBwb2ludHMgPSBwb2ludHNBdHRyVG9Qb2ludHMoZWwpO1xuXG4gICAgY29uc3QgbWF0ID0gZ2V0VHJhbnNmb3JtTWF0cml4KGVsLCBncm91cHMpO1xuXG4gICAgY29uc3QgdHJhbnNmb3JtZWRQb2ludHMgPSB0cmFuc2Zvcm1Qb2ludHMocG9pbnRzLCBtYXQpO1xuXG4gICAgLy8gVGhlIGZpcnN0IHBvaW50IG5lZWRzIHRvIGJlIDAsIDAsIGFuZCBhbGwgZm9sbG93aW5nIHBvaW50c1xuICAgIC8vIGFyZSByZWxhdGl2ZSB0byB0aGUgZmlyc3QgcG9pbnQuXG4gICAgY29uc3QgeCA9IHRyYW5zZm9ybWVkUG9pbnRzWzBdWzBdO1xuICAgIGNvbnN0IHkgPSB0cmFuc2Zvcm1lZFBvaW50c1swXVsxXTtcblxuICAgIGNvbnN0IHJlbGF0aXZlUG9pbnRzID0gdHJhbnNmb3JtZWRQb2ludHMubWFwKChbX3gsIF95XSkgPT4gW1xuICAgICAgX3ggLSB4LFxuICAgICAgX3kgLSB5LFxuICAgIF0pO1xuXG4gICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gZGltZW5zaW9uc0Zyb21Qb2ludHMocmVsYXRpdmVQb2ludHMpO1xuXG4gICAgY29uc3QgbGluZTogRXhjYWxpZHJhd0xpbmUgPSB7XG4gICAgICAuLi5jcmVhdGVFeExpbmUoKSxcbiAgICAgIC4uLmdldEdyb3VwQXR0cnMoZ3JvdXBzKSxcbiAgICAgIC4uLnByZXNBdHRyc1RvRWxlbWVudFZhbHVlcyhlbCksXG4gICAgICBwb2ludHM6IHJlbGF0aXZlUG9pbnRzLmNvbmNhdChbWzAsIDBdXSksXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgIH07XG5cbiAgICBzY2VuZS5lbGVtZW50cy5wdXNoKGxpbmUpO1xuXG4gICAgd2FsayhhcmdzLCBhcmdzLnR3Lm5leHROb2RlKCkpO1xuICB9LFxuXG4gIHBvbHlsaW5lOiAoYXJnczogV2Fsa2VyQXJncykgPT4ge1xuICAgIGNvbnN0IHsgdHcsIHNjZW5lLCBncm91cHMgfSA9IGFyZ3M7XG4gICAgY29uc3QgZWwgPSB0dy5jdXJyZW50Tm9kZSBhcyBFbGVtZW50O1xuXG4gICAgY29uc3QgbWF0ID0gZ2V0VHJhbnNmb3JtTWF0cml4KGVsLCBncm91cHMpO1xuXG4gICAgY29uc3QgcG9pbnRzID0gcG9pbnRzQXR0clRvUG9pbnRzKGVsKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1lZFBvaW50cyA9IHRyYW5zZm9ybVBvaW50cyhwb2ludHMsIG1hdCk7XG5cbiAgICAvLyBUaGUgZmlyc3QgcG9pbnQgbmVlZHMgdG8gYmUgMCwgMCwgYW5kIGFsbCBmb2xsb3dpbmcgcG9pbnRzXG4gICAgLy8gYXJlIHJlbGF0aXZlIHRvIHRoZSBmaXJzdCBwb2ludC5cbiAgICBjb25zdCB4ID0gdHJhbnNmb3JtZWRQb2ludHNbMF1bMF07XG4gICAgY29uc3QgeSA9IHRyYW5zZm9ybWVkUG9pbnRzWzBdWzFdO1xuXG4gICAgY29uc3QgcmVsYXRpdmVQb2ludHMgPSB0cmFuc2Zvcm1lZFBvaW50cy5tYXAoKFtfeCwgX3ldKSA9PiBbXG4gICAgICBfeCAtIHgsXG4gICAgICBfeSAtIHksXG4gICAgXSk7XG5cbiAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSBkaW1lbnNpb25zRnJvbVBvaW50cyhyZWxhdGl2ZVBvaW50cyk7XG5cbiAgICBjb25zdCBoYXNGaWxsID0gaGFzKGVsLCBcImZpbGxcIik7XG4gICAgY29uc3QgZmlsbCA9IGdldChlbCwgXCJmaWxsXCIpO1xuXG4gICAgY29uc3Qgc2hvdWxkRmlsbCA9ICFoYXNGaWxsIHx8IChoYXNGaWxsICYmIGZpbGwgIT09IFwibm9uZVwiKTtcblxuICAgIGNvbnN0IGxpbmU6IEV4Y2FsaWRyYXdMaW5lID0ge1xuICAgICAgLi4uY3JlYXRlRXhMaW5lKCksXG4gICAgICAuLi5nZXRHcm91cEF0dHJzKGdyb3VwcyksXG4gICAgICAuLi5wcmVzQXR0cnNUb0VsZW1lbnRWYWx1ZXMoZWwpLFxuICAgICAgcG9pbnRzOiByZWxhdGl2ZVBvaW50cy5jb25jYXQoc2hvdWxkRmlsbCA/IFtbMCwgMF1dIDogW10pLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICB9O1xuXG4gICAgc2NlbmUuZWxlbWVudHMucHVzaChsaW5lKTtcblxuICAgIHdhbGsoYXJncywgYXJncy50dy5uZXh0Tm9kZSgpKTtcbiAgfSxcblxuICByZWN0OiAoYXJnczogV2Fsa2VyQXJncykgPT4ge1xuICAgIGNvbnN0IHsgdHcsIHNjZW5lLCBncm91cHMgfSA9IGFyZ3M7XG4gICAgY29uc3QgZWwgPSB0dy5jdXJyZW50Tm9kZSBhcyBFbGVtZW50O1xuXG4gICAgY29uc3QgeCA9IGdldE51bShlbCwgXCJ4XCIsIDApO1xuICAgIGNvbnN0IHkgPSBnZXROdW0oZWwsIFwieVwiLCAwKTtcbiAgICBjb25zdCB3ID0gZ2V0TnVtKGVsLCBcIndpZHRoXCIsIDApO1xuICAgIGNvbnN0IGggPSBnZXROdW0oZWwsIFwiaGVpZ2h0XCIsIDApO1xuXG4gICAgY29uc3QgbWF0ID0gZ2V0VHJhbnNmb3JtTWF0cml4KGVsLCBncm91cHMpO1xuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IG0gPSBtYXQ0LmZyb21WYWx1ZXModywgMCwgMCwgMCwgMCwgaCwgMCwgMCwgMCwgMCwgMSwgMCwgeCwgeSwgMCwgMSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBtYXQ0Lm11bHRpcGx5KG1hdDQuY3JlYXRlKCksIG1hdCwgbSk7XG5cbiAgICAvKlxuICAgIE5PVEU6IEN1cnJlbnRseSB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSB3YXkgdG8gc3BlY2lmeSB0aGUgYm9yZGVyXG4gICAgICAgICAgcmFkaXVzIG9mIGEgcmVjdCB3aXRoaW4gRXhjYWxpZHJhdy4gVGhpcyBtZWFucyB0aGF0IGF0dHJpYnV0ZXNcbiAgICAgICAgICByeCBhbmQgcnkgY2FuJ3QgYmUgdXNlZC5cbiAgICAqL1xuICAgIGNvbnN0IGlzUm91bmQgPSBlbC5oYXNBdHRyaWJ1dGUoXCJyeFwiKSB8fCBlbC5oYXNBdHRyaWJ1dGUoXCJyeVwiKTtcblxuICAgIGNvbnN0IHJlY3Q6IEV4Y2FsaWRyYXdSZWN0YW5nbGUgPSB7XG4gICAgICAuLi5jcmVhdGVFeFJlY3QoKSxcbiAgICAgIC4uLnByZXNBdHRycyhlbCwgZ3JvdXBzKSxcbiAgICAgIHg6IHJlc3VsdFsxMl0sXG4gICAgICB5OiByZXN1bHRbMTNdLFxuICAgICAgd2lkdGg6IHJlc3VsdFswXSxcbiAgICAgIGhlaWdodDogcmVzdWx0WzVdLFxuICAgICAgc3Ryb2tlU2hhcnBuZXNzOiBpc1JvdW5kID8gXCJyb3VuZFwiIDogXCJzaGFycFwiLFxuICAgIH07XG5cbiAgICBzY2VuZS5lbGVtZW50cy5wdXNoKHJlY3QpO1xuXG4gICAgd2FsayhhcmdzLCBhcmdzLnR3Lm5leHROb2RlKCkpO1xuICB9LFxuXG4gIHBhdGg6IChhcmdzOiBXYWxrZXJBcmdzKSA9PiB7XG4gICAgY29uc3QgeyB0dywgc2NlbmUsIGdyb3VwcyB9ID0gYXJncztcbiAgICBjb25zdCBlbCA9IHR3LmN1cnJlbnROb2RlIGFzIEVsZW1lbnQ7XG5cbiAgICBjb25zdCBtYXQgPSBnZXRUcmFuc2Zvcm1NYXRyaXgoZWwsIGdyb3Vwcyk7XG5cbiAgICBjb25zdCBwb2ludHMgPSBwb2ludHNPblBhdGgoZ2V0KGVsLCBcImRcIikpO1xuXG4gICAgY29uc3QgZmlsbENvbG9yID0gZ2V0KGVsLCBcImZpbGxcIiwgXCJibGFja1wiKTtcbiAgICBjb25zdCBmaWxsUnVsZSA9IGdldChlbCwgXCJmaWxsLXJ1bGVcIiwgXCJub256ZXJvXCIpO1xuXG4gICAgbGV0IGVsZW1lbnRzOiBFeGNhbGlkcmF3RHJhd1tdID0gW107XG4gICAgbGV0IGxvY2FsR3JvdXAgPSByYW5kb21JZCgpO1xuXG4gICAgc3dpdGNoIChmaWxsUnVsZSkge1xuICAgICAgY2FzZSBcIm5vbnplcm9cIjpcbiAgICAgICAgbGV0IGluaXRpYWxXaW5kaW5nT3JkZXIgPSBcImNsb2Nrd2lzZVwiO1xuXG4gICAgICAgIGVsZW1lbnRzID0gcG9pbnRzLm1hcChcbiAgICAgICAgICAocG9pbnRBcnIsIGlkeCk6IEV4Y2FsaWRyYXdEcmF3ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRQb2ludHM6IFBvaW50W10gPSB0cmFuc2Zvcm1Qb2ludHMocG9pbnRBcnIsIG1hdDQuY2xvbmUobWF0KSk7XG4gICAgICAgICAgICBjb25zdCB4ID0gdFBvaW50c1swXVswXTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSB0UG9pbnRzWzBdWzFdO1xuXG4gICAgICAgICAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSBkaW1lbnNpb25zRnJvbVBvaW50cyh0UG9pbnRzKTtcblxuICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVQb2ludHMgPSB0UG9pbnRzLm1hcChcbiAgICAgICAgICAgICAgKFtfeCwgX3ldKTogUG9pbnQgPT4gW194IC0geCwgX3kgLSB5XSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGNvbnN0IHdpbmRpbmdPcmRlciA9IGdldFdpbmRpbmdPcmRlcihyZWxhdGl2ZVBvaW50cyk7XG4gICAgICAgICAgICBpZiAoaWR4ID09PSAwKSB7XG4gICAgICAgICAgICAgIGluaXRpYWxXaW5kaW5nT3JkZXIgPSB3aW5kaW5nT3JkZXI7XG4gICAgICAgICAgICAgIGxvY2FsR3JvdXAgPSByYW5kb21JZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgYmFja2dyb3VuZENvbG9yID0gZmlsbENvbG9yO1xuICAgICAgICAgICAgaWYgKGluaXRpYWxXaW5kaW5nT3JkZXIgIT09IHdpbmRpbmdPcmRlcikge1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgPSBcIiNGRkZGRkZcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uY3JlYXRlRXhEcmF3KCksXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgICAgICAgICAgICBzdHJva2VDb2xvcjogXCIjMDAwMDAwMDBcIixcbiAgICAgICAgICAgICAgLi4ucHJlc0F0dHJzKGVsLCBncm91cHMpLFxuICAgICAgICAgICAgICBwb2ludHM6IHJlbGF0aXZlUG9pbnRzLFxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgIHg6IHggKyBnZXROdW0oZWwsIFwieFwiLCAwKSxcbiAgICAgICAgICAgICAgeTogeSArIGdldE51bShlbCwgXCJ5XCIsIDApLFxuICAgICAgICAgICAgICBncm91cElkczogW2xvY2FsR3JvdXBdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJldmVub2RkXCI6XG4gICAgICAgIGVsZW1lbnRzID0gcG9pbnRzLm1hcChcbiAgICAgICAgICAocG9pbnRBcnIsIGlkeCk6IEV4Y2FsaWRyYXdEcmF3ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRQb2ludHM6IFBvaW50W10gPSB0cmFuc2Zvcm1Qb2ludHMocG9pbnRBcnIsIG1hdDQuY2xvbmUobWF0KSk7XG4gICAgICAgICAgICBjb25zdCB4ID0gdFBvaW50c1swXVswXTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSB0UG9pbnRzWzBdWzFdO1xuXG4gICAgICAgICAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSBkaW1lbnNpb25zRnJvbVBvaW50cyh0UG9pbnRzKTtcblxuICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVQb2ludHMgPSB0UG9pbnRzLm1hcChcbiAgICAgICAgICAgICAgKFtfeCwgX3ldKTogUG9pbnQgPT4gW194IC0geCwgX3kgLSB5XSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChpZHggPT09IDApIHtcbiAgICAgICAgICAgICAgbG9jYWxHcm91cCA9IHJhbmRvbUlkKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLmNyZWF0ZUV4RHJhdygpLFxuICAgICAgICAgICAgICAuLi5wcmVzQXR0cnMoZWwsIGdyb3VwcyksXG4gICAgICAgICAgICAgIHBvaW50czogcmVsYXRpdmVQb2ludHMsXG4gICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgIHg6IHggKyBnZXROdW0oZWwsIFwieFwiLCAwKSxcbiAgICAgICAgICAgICAgeTogeSArIGdldE51bShlbCwgXCJ5XCIsIDApLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuXG4gICAgc2NlbmUuZWxlbWVudHMgPSBzY2VuZS5lbGVtZW50cy5jb25jYXQoZWxlbWVudHMpO1xuXG4gICAgd2FsayhhcmdzLCB0dy5uZXh0Tm9kZSgpKTtcbiAgfSxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB3YWxrKGFyZ3M6IFdhbGtlckFyZ3MsIG5leHROb2RlOiBOb2RlIHwgbnVsbCk6IHZvaWQge1xuICBpZiAoIW5leHROb2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgbm9kZU5hbWUgPSBuZXh0Tm9kZS5ub2RlTmFtZSBhcyBrZXlvZiB0eXBlb2Ygd2Fsa2VycztcbiAgaWYgKHdhbGtlcnNbbm9kZU5hbWVdKSB7XG4gICAgd2Fsa2Vyc1tub2RlTmFtZV0oYXJncyk7XG4gIH1cbn1cbiIsImltcG9ydCBFeGNhbGlkcmF3U2NlbmUgZnJvbSBcIi4vZWxlbWVudHMvRXhjYWxpZHJhd1NjZW5lXCI7XG5pbXBvcnQgR3JvdXAgZnJvbSBcIi4vZWxlbWVudHMvR3JvdXBcIjtcbmltcG9ydCB7IGNyZWF0ZVRyZWVXYWxrZXIsIHdhbGsgfSBmcm9tIFwiLi93YWxrZXJcIjtcblxuZXhwb3J0IHR5cGUgQ29udmVyc2lvblJlc3VsdCA9IHtcbiAgaGFzRXJyb3JzOiBib29sZWFuO1xuICBlcnJvcnM6IE5vZGVMaXN0T2Y8RWxlbWVudD4gfCBudWxsO1xuICBjb250ZW50OiBhbnk7IC8vIFNlcmlhbGl6ZWQgRXhjYWxpZHJhdyBKU09OXG59O1xuXG5leHBvcnQgY29uc3QgY29udmVydCA9IChzdmdTdHJpbmc6IHN0cmluZyk6IENvbnZlcnNpb25SZXN1bHQgPT4ge1xuICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gIGNvbnN0IHN2Z0RPTSA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoc3ZnU3RyaW5nLCBcImltYWdlL3N2Zyt4bWxcIik7XG5cbiAgLy8gd2FzIHRoZXJlIGEgcGFyc2luZyBlcnJvcj9cbiAgY29uc3QgZXJyb3JzRWxlbWVudHMgPSBzdmdET00ucXVlcnlTZWxlY3RvckFsbChcInBhcnNlcmVycm9yXCIpO1xuICBjb25zdCBoYXNFcnJvcnMgPSBlcnJvcnNFbGVtZW50cy5sZW5ndGggPiAwO1xuICBsZXQgY29udGVudCA9IG51bGw7XG5cbiAgaWYgKGhhc0Vycm9ycykge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBcIlRoZXJlIHdlcmUgZXJyb3JzIHdoaWxlIHBhcnNpbmcgdGhlIGdpdmVuIFNWRzogXCIsXG4gICAgICBbLi4uZXJyb3JzRWxlbWVudHNdLm1hcCgoZWwpID0+IGVsLmlubmVySFRNTCksXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0dyA9IGNyZWF0ZVRyZWVXYWxrZXIoc3ZnRE9NKTtcbiAgICBjb25zdCBzY2VuZSA9IG5ldyBFeGNhbGlkcmF3U2NlbmUoKTtcbiAgICBjb25zdCBncm91cHM6IEdyb3VwW10gPSBbXTtcblxuICAgIHdhbGsoeyB0dywgc2NlbmUsIGdyb3Vwcywgcm9vdDogc3ZnRE9NIH0sIHR3Lm5leHROb2RlKCkpO1xuXG4gICAgY29udGVudCA9IHNjZW5lLnRvRXhKU09OKCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGhhc0Vycm9ycyxcbiAgICBlcnJvcnM6IGhhc0Vycm9ycyA/IGVycm9yc0VsZW1lbnRzIDogbnVsbCxcbiAgICBjb250ZW50LFxuICB9O1xufTtcbiIsImltcG9ydCAqIGFzIHBhcnNlciBmcm9tIFwiLi9wYXJzZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgcGFyc2VyO1xuIl0sIm5hbWVzIjpbIkV4Y2FsaWRyYXdTY2VuZSIsImVsZW1lbnRzIiwibWFwIiwiZWwiLCJSYW5kb20iLCJuYW5vaWQiLCJyYW5kb20iLCJEYXRlIiwibm93IiwicmFuZG9tSW50ZWdlciIsIk1hdGgiLCJmbG9vciIsIm5leHQiLCJyYW5kb21JZCIsInNhZmVOdW1iZXIiLCJudW1iZXIiLCJOdW1iZXIiLCJ0b0ZpeGVkIiwiZGltZW5zaW9uc0Zyb21Qb2ludHMiLCJwb2ludHMiLCJ4Q29vcmRzIiwieCIsInlDb29yZHMiLCJ5IiwibWluWCIsIm1pbiIsIm1pblkiLCJtYXhYIiwibWF4IiwibWF4WSIsImdldFdpbmRpbmdPcmRlciIsInRvdGFsIiwicmVkdWNlIiwiYWNjIiwiaWR4IiwiYXJyIiwieDEiLCJ5MSIsInAyIiwieDIiLCJ5MiIsImUiLCJjaHJvbWEiLCJoZXhXaXRoQWxwaGEiLCJjb2xvciIsImFscGhhIiwiY3NzIiwiaGFzIiwiYXR0ciIsImhhc0F0dHJpYnV0ZSIsImdldCIsImJhY2t1cCIsImdldEF0dHJpYnV0ZSIsImdldE51bSIsIm51bVZhbCIsIk5hTiIsInByZXNBdHRycyIsInN0cm9rZSIsImZpbGwiLCJvcGFjaXR5IiwiYXR0ckhhbmRsZXJzIiwiZXhWYWxzIiwic3Ryb2tlQ29sb3IiLCJzdHJva2VXaWR0aCIsImJhY2tncm91bmRDb2xvciIsInByZXNBdHRyc1RvRWxlbWVudFZhbHVlcyIsImF0dHJpYnV0ZXMiLCJuYW1lIiwiT2JqZWN0Iiwia2V5cyIsImluY2x1ZGVzIiwiZmlsdGVyQXR0cnNUb0VsZW1lbnRWYWx1ZXMiLCJmaWx0ZXJWYWxzIiwid2lkdGgiLCJoZWlnaHQiLCJwb2ludHNBdHRyVG9Qb2ludHMiLCJzcGxpdCIsInAiLCJwYXJzZUZsb2F0IiwiZ2V0R3JvdXBBdHRycyIsImdyb3VwcyIsImVsZW1lbnQiLCJlbFZhbHMiLCJHcm91cCIsImNyZWF0ZUV4RWxlbWVudCIsImlkIiwiZmlsbFN0eWxlIiwic3Ryb2tlU3R5bGUiLCJzdHJva2VTaGFycG5lc3MiLCJyb3VnaG5lc3MiLCJhbmdsZSIsInNlZWQiLCJ2ZXJzaW9uIiwidmVyc2lvbk5vbmNlIiwiaXNEZWxldGVkIiwiZ3JvdXBJZHMiLCJib3VuZEVsZW1lbnRJZHMiLCJjcmVhdGVFeFJlY3QiLCJ0eXBlIiwiY3JlYXRlRXhMaW5lIiwiY3JlYXRlRXhFbGxpcHNlIiwiY3JlYXRlRXhEcmF3IiwidmVjMyIsIm1hdDQiLCJ0cmFuc2Zvcm1GdW5jdGlvbnMiLCJtYXRyaXgiLCJtYXRyaXgzZCIsInBlcnNwZWN0aXZlIiwicm90YXRlIiwicm90YXRlM2QiLCJyb3RhdGVYIiwicm90YXRlWSIsInJvdGF0ZVoiLCJzY2FsZSIsInNjYWxlM2QiLCJzY2FsZVgiLCJzY2FsZVkiLCJzY2FsZVoiLCJza2V3Iiwic2tld1giLCJza2V3WSIsInRyYW5zbGF0ZSIsInRyYW5zbGF0ZTNkIiwidHJhbnNsYXRlWCIsInRyYW5zbGF0ZVkiLCJ0cmFuc2xhdGVaIiwidHJhbnNmb3JtRnVuY3Rpb25zQXJyIiwiZGVmYXVsdFVuaXRzIiwic3ZnVHJhbnNmb3JtVG9DU1NUcmFuc2Zvcm0iLCJzdmdUcmFuc2Zvcm1TdHIiLCJ0RnVuY3MiLCJtYXRjaCIsInRGdW5jVmFsdWVzIiwidEZ1bmNTdHIiLCJFcnJvciIsInRGdW5jUGFydHMiLCJ2YWx1ZXMiLCJhIiwibWF0Y2hBbGwiLCJ2YWx1ZSIsInVuaXQiLCJsZW5ndGgiLCJjc3N0cmFuc2Zvcm1TdHIiLCJ2YWxTdHIiLCJqb2luIiwiY3JlYXRlRE9NTWF0cml4RnJvbVNWR1N0ciIsImNzc1RyYW5zZm9ybVN0ciIsIkRPTU1hdHJpeCIsImdldEVsZW1lbnRNYXRyaXgiLCJlbE1hdCIsIm11bHRpcGx5IiwiY3JlYXRlIiwidG9GbG9hdDMyQXJyYXkiLCJnZXRUcmFuc2Zvcm1NYXRyaXgiLCJhY2N1bU1hdCIsImNvbmNhdCIsIm1hdCIsInRyYW5zZm9ybVBvaW50cyIsInRyYW5zZm9ybSIsInRyYW5zZm9ybU1hdDQiLCJmcm9tVmFsdWVzIiwibmV3WCIsIm5ld1kiLCJwb2ludHNPblBhdGgiLCJTVVBQT1JURURfVEFHUyIsIm5vZGVWYWxpZGF0b3IiLCJub2RlIiwidGFnTmFtZSIsIk5vZGVGaWx0ZXIiLCJGSUxURVJfQUNDRVBUIiwiRklMVEVSX1JFSkVDVCIsImNyZWF0ZVRyZWVXYWxrZXIiLCJkb20iLCJkb2N1bWVudCIsIlNIT1dfQUxMIiwiYWNjZXB0Tm9kZSIsInNraXBwZWRVc2VBdHRycyIsImFsbHdheXNQYXNzZWRVc2VBdHRycyIsImdldERlZkVsV2l0aENvcnJlY3RBdHRycyIsImRlZkVsIiwidXNlRWwiLCJmaW5hbEVsIiwic2V0QXR0cmlidXRlIiwiY2xvbmVOb2RlIiwid2Fsa2VycyIsInN2ZyIsImFyZ3MiLCJ3YWxrIiwidHciLCJuZXh0Tm9kZSIsImciLCJuZXh0QXJncyIsImN1cnJlbnROb2RlIiwibmV4dFNpYmxpbmciLCJ1c2UiLCJyb290Iiwic2NlbmUiLCJxdWVyeVNlbGVjdG9yIiwidGVtcFNjZW5lIiwiZXhFbCIsInBvcCIsInB1c2giLCJjaXJjbGUiLCJyIiwiZCIsIm0iLCJyZXN1bHQiLCJlbGxpcHNlIiwicngiLCJyeSIsImN4IiwiY3kiLCJ3IiwiaCIsImxpbmUiLCJwb2x5Z29uIiwidHJhbnNmb3JtZWRQb2ludHMiLCJyZWxhdGl2ZVBvaW50cyIsIl94IiwiX3kiLCJwb2x5bGluZSIsImhhc0ZpbGwiLCJzaG91bGRGaWxsIiwicmVjdCIsImlzUm91bmQiLCJwYXRoIiwiZmlsbENvbG9yIiwiZmlsbFJ1bGUiLCJsb2NhbEdyb3VwIiwiaW5pdGlhbFdpbmRpbmdPcmRlciIsInBvaW50QXJyIiwidFBvaW50cyIsImNsb25lIiwid2luZGluZ09yZGVyIiwibm9kZU5hbWUiLCJjb252ZXJ0Iiwic3ZnU3RyaW5nIiwicGFyc2VyIiwiRE9NUGFyc2VyIiwic3ZnRE9NIiwicGFyc2VGcm9tU3RyaW5nIiwiZXJyb3JzRWxlbWVudHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaGFzRXJyb3JzIiwiY29udGVudCIsImNvbnNvbGUiLCJlcnJvciIsImlubmVySFRNTCIsInRvRXhKU09OIiwiZXJyb3JzIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///773\\n')},792:function(module){eval(\"/**\\n * chroma.js - JavaScript library for color conversions\\n *\\n * Copyright (c) 2011-2019, Gregor Aisch\\n * All rights reserved.\\n *\\n * Redistribution and use in source and binary forms, with or without\\n * modification, are permitted provided that the following conditions are met:\\n *\\n * 1. Redistributions of source code must retain the above copyright notice, this\\n * list of conditions and the following disclaimer.\\n *\\n * 2. Redistributions in binary form must reproduce the above copyright notice,\\n * this list of conditions and the following disclaimer in the documentation\\n * and/or other materials provided with the distribution.\\n *\\n * 3. The name Gregor Aisch may not be used to endorse or promote products\\n * derived from this software without specific prior written permission.\\n *\\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\"\\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n *\\n * -------------------------------------------------------\\n *\\n * chroma.js includes colors from colorbrewer2.org, which are released under\\n * the following license:\\n *\\n * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,\\n * and The Pennsylvania State University.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n * http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing,\\n * software distributed under the License is distributed on an\\n * \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\\n * either express or implied. See the License for the specific\\n * language governing permissions and limitations under the License.\\n *\\n * ------------------------------------------------------\\n *\\n * Named colors are taken from X11 Color Names.\\n * http://www.w3.org/TR/css3-color/#svg-color\\n *\\n * @preserve\\n */\\n\\n(function (global, factory) {\\n     true ? module.exports = factory() :\\n    0;\\n}(this, (function () { 'use strict';\\n\\n    var limit = function (x, min, max) {\\n        if ( min === void 0 ) min=0;\\n        if ( max === void 0 ) max=1;\\n\\n        return x < min ? min : x > max ? max : x;\\n    };\\n\\n    var clip_rgb = function (rgb) {\\n        rgb._clipped = false;\\n        rgb._unclipped = rgb.slice(0);\\n        for (var i=0; i<=3; i++) {\\n            if (i < 3) {\\n                if (rgb[i] < 0 || rgb[i] > 255) { rgb._clipped = true; }\\n                rgb[i] = limit(rgb[i], 0, 255);\\n            } else if (i === 3) {\\n                rgb[i] = limit(rgb[i], 0, 1);\\n            }\\n        }\\n        return rgb;\\n    };\\n\\n    // ported from jQuery's $.type\\n    var classToType = {};\\n    for (var i = 0, list = ['Boolean', 'Number', 'String', 'Function', 'Array', 'Date', 'RegExp', 'Undefined', 'Null']; i < list.length; i += 1) {\\n        var name = list[i];\\n\\n        classToType[(\\\"[object \\\" + name + \\\"]\\\")] = name.toLowerCase();\\n    }\\n    var type = function(obj) {\\n        return classToType[Object.prototype.toString.call(obj)] || \\\"object\\\";\\n    };\\n\\n    var unpack = function (args, keyOrder) {\\n        if ( keyOrder === void 0 ) keyOrder=null;\\n\\n    \\t// if called with more than 3 arguments, we return the arguments\\n        if (args.length >= 3) { return Array.prototype.slice.call(args); }\\n        // with less than 3 args we check if first arg is object\\n        // and use the keyOrder string to extract and sort properties\\n    \\tif (type(args[0]) == 'object' && keyOrder) {\\n    \\t\\treturn keyOrder.split('')\\n    \\t\\t\\t.filter(function (k) { return args[0][k] !== undefined; })\\n    \\t\\t\\t.map(function (k) { return args[0][k]; });\\n    \\t}\\n    \\t// otherwise we just return the first argument\\n    \\t// (which we suppose is an array of args)\\n        return args[0];\\n    };\\n\\n    var last = function (args) {\\n        if (args.length < 2) { return null; }\\n        var l = args.length-1;\\n        if (type(args[l]) == 'string') { return args[l].toLowerCase(); }\\n        return null;\\n    };\\n\\n    var PI = Math.PI;\\n\\n    var utils = {\\n    \\tclip_rgb: clip_rgb,\\n    \\tlimit: limit,\\n    \\ttype: type,\\n    \\tunpack: unpack,\\n    \\tlast: last,\\n    \\tPI: PI,\\n    \\tTWOPI: PI*2,\\n    \\tPITHIRD: PI/3,\\n    \\tDEG2RAD: PI / 180,\\n    \\tRAD2DEG: 180 / PI\\n    };\\n\\n    var input = {\\n    \\tformat: {},\\n    \\tautodetect: []\\n    };\\n\\n    var last$1 = utils.last;\\n    var clip_rgb$1 = utils.clip_rgb;\\n    var type$1 = utils.type;\\n\\n\\n    var Color = function Color() {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        var me = this;\\n        if (type$1(args[0]) === 'object' &&\\n            args[0].constructor &&\\n            args[0].constructor === this.constructor) {\\n            // the argument is already a Color instance\\n            return args[0];\\n        }\\n\\n        // last argument could be the mode\\n        var mode = last$1(args);\\n        var autodetect = false;\\n\\n        if (!mode) {\\n            autodetect = true;\\n            if (!input.sorted) {\\n                input.autodetect = input.autodetect.sort(function (a,b) { return b.p - a.p; });\\n                input.sorted = true;\\n            }\\n            // auto-detect format\\n            for (var i = 0, list = input.autodetect; i < list.length; i += 1) {\\n                var chk = list[i];\\n\\n                mode = chk.test.apply(chk, args);\\n                if (mode) { break; }\\n            }\\n        }\\n\\n        if (input.format[mode]) {\\n            var rgb = input.format[mode].apply(null, autodetect ? args : args.slice(0,-1));\\n            me._rgb = clip_rgb$1(rgb);\\n        } else {\\n            throw new Error('unknown format: '+args);\\n        }\\n\\n        // add alpha channel\\n        if (me._rgb.length === 3) { me._rgb.push(1); }\\n    };\\n\\n    Color.prototype.toString = function toString () {\\n        if (type$1(this.hex) == 'function') { return this.hex(); }\\n        return (\\\"[\\\" + (this._rgb.join(',')) + \\\"]\\\");\\n    };\\n\\n    var Color_1 = Color;\\n\\n    var chroma = function () {\\n    \\tvar args = [], len = arguments.length;\\n    \\twhile ( len-- ) args[ len ] = arguments[ len ];\\n\\n    \\treturn new (Function.prototype.bind.apply( chroma.Color, [ null ].concat( args) ));\\n    };\\n\\n    chroma.Color = Color_1;\\n    chroma.version = '2.1.2';\\n\\n    var chroma_1 = chroma;\\n\\n    var unpack$1 = utils.unpack;\\n    var max = Math.max;\\n\\n    var rgb2cmyk = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        var ref = unpack$1(args, 'rgb');\\n        var r = ref[0];\\n        var g = ref[1];\\n        var b = ref[2];\\n        r = r / 255;\\n        g = g / 255;\\n        b = b / 255;\\n        var k = 1 - max(r,max(g,b));\\n        var f = k < 1 ? 1 / (1-k) : 0;\\n        var c = (1-r-k) * f;\\n        var m = (1-g-k) * f;\\n        var y = (1-b-k) * f;\\n        return [c,m,y,k];\\n    };\\n\\n    var rgb2cmyk_1 = rgb2cmyk;\\n\\n    var unpack$2 = utils.unpack;\\n\\n    var cmyk2rgb = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        args = unpack$2(args, 'cmyk');\\n        var c = args[0];\\n        var m = args[1];\\n        var y = args[2];\\n        var k = args[3];\\n        var alpha = args.length > 4 ? args[4] : 1;\\n        if (k === 1) { return [0,0,0,alpha]; }\\n        return [\\n            c >= 1 ? 0 : 255 * (1-c) * (1-k), // r\\n            m >= 1 ? 0 : 255 * (1-m) * (1-k), // g\\n            y >= 1 ? 0 : 255 * (1-y) * (1-k), // b\\n            alpha\\n        ];\\n    };\\n\\n    var cmyk2rgb_1 = cmyk2rgb;\\n\\n    var unpack$3 = utils.unpack;\\n    var type$2 = utils.type;\\n\\n\\n\\n    Color_1.prototype.cmyk = function() {\\n        return rgb2cmyk_1(this._rgb);\\n    };\\n\\n    chroma_1.cmyk = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['cmyk']) ));\\n    };\\n\\n    input.format.cmyk = cmyk2rgb_1;\\n\\n    input.autodetect.push({\\n        p: 2,\\n        test: function () {\\n            var args = [], len = arguments.length;\\n            while ( len-- ) args[ len ] = arguments[ len ];\\n\\n            args = unpack$3(args, 'cmyk');\\n            if (type$2(args) === 'array' && args.length === 4) {\\n                return 'cmyk';\\n            }\\n        }\\n    });\\n\\n    var unpack$4 = utils.unpack;\\n    var last$2 = utils.last;\\n    var rnd = function (a) { return Math.round(a*100)/100; };\\n\\n    /*\\n     * supported arguments:\\n     * - hsl2css(h,s,l)\\n     * - hsl2css(h,s,l,a)\\n     * - hsl2css([h,s,l], mode)\\n     * - hsl2css([h,s,l,a], mode)\\n     * - hsl2css({h,s,l,a}, mode)\\n     */\\n    var hsl2css = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        var hsla = unpack$4(args, 'hsla');\\n        var mode = last$2(args) || 'lsa';\\n        hsla[0] = rnd(hsla[0] || 0);\\n        hsla[1] = rnd(hsla[1]*100) + '%';\\n        hsla[2] = rnd(hsla[2]*100) + '%';\\n        if (mode === 'hsla' || (hsla.length > 3 && hsla[3]<1)) {\\n            hsla[3] = hsla.length > 3 ? hsla[3] : 1;\\n            mode = 'hsla';\\n        } else {\\n            hsla.length = 3;\\n        }\\n        return (mode + \\\"(\\\" + (hsla.join(',')) + \\\")\\\");\\n    };\\n\\n    var hsl2css_1 = hsl2css;\\n\\n    var unpack$5 = utils.unpack;\\n\\n    /*\\n     * supported arguments:\\n     * - rgb2hsl(r,g,b)\\n     * - rgb2hsl(r,g,b,a)\\n     * - rgb2hsl([r,g,b])\\n     * - rgb2hsl([r,g,b,a])\\n     * - rgb2hsl({r,g,b,a})\\n     */\\n    var rgb2hsl = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        args = unpack$5(args, 'rgba');\\n        var r = args[0];\\n        var g = args[1];\\n        var b = args[2];\\n\\n        r /= 255;\\n        g /= 255;\\n        b /= 255;\\n\\n        var min = Math.min(r, g, b);\\n        var max = Math.max(r, g, b);\\n\\n        var l = (max + min) / 2;\\n        var s, h;\\n\\n        if (max === min){\\n            s = 0;\\n            h = Number.NaN;\\n        } else {\\n            s = l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);\\n        }\\n\\n        if (r == max) { h = (g - b) / (max - min); }\\n        else if (g == max) { h = 2 + (b - r) / (max - min); }\\n        else if (b == max) { h = 4 + (r - g) / (max - min); }\\n\\n        h *= 60;\\n        if (h < 0) { h += 360; }\\n        if (args.length>3 && args[3]!==undefined) { return [h,s,l,args[3]]; }\\n        return [h,s,l];\\n    };\\n\\n    var rgb2hsl_1 = rgb2hsl;\\n\\n    var unpack$6 = utils.unpack;\\n    var last$3 = utils.last;\\n\\n\\n    var round = Math.round;\\n\\n    /*\\n     * supported arguments:\\n     * - rgb2css(r,g,b)\\n     * - rgb2css(r,g,b,a)\\n     * - rgb2css([r,g,b], mode)\\n     * - rgb2css([r,g,b,a], mode)\\n     * - rgb2css({r,g,b,a}, mode)\\n     */\\n    var rgb2css = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        var rgba = unpack$6(args, 'rgba');\\n        var mode = last$3(args) || 'rgb';\\n        if (mode.substr(0,3) == 'hsl') {\\n            return hsl2css_1(rgb2hsl_1(rgba), mode);\\n        }\\n        rgba[0] = round(rgba[0]);\\n        rgba[1] = round(rgba[1]);\\n        rgba[2] = round(rgba[2]);\\n        if (mode === 'rgba' || (rgba.length > 3 && rgba[3]<1)) {\\n            rgba[3] = rgba.length > 3 ? rgba[3] : 1;\\n            mode = 'rgba';\\n        }\\n        return (mode + \\\"(\\\" + (rgba.slice(0,mode==='rgb'?3:4).join(',')) + \\\")\\\");\\n    };\\n\\n    var rgb2css_1 = rgb2css;\\n\\n    var unpack$7 = utils.unpack;\\n    var round$1 = Math.round;\\n\\n    var hsl2rgb = function () {\\n        var assign;\\n\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n        args = unpack$7(args, 'hsl');\\n        var h = args[0];\\n        var s = args[1];\\n        var l = args[2];\\n        var r,g,b;\\n        if (s === 0) {\\n            r = g = b = l*255;\\n        } else {\\n            var t3 = [0,0,0];\\n            var c = [0,0,0];\\n            var t2 = l < 0.5 ? l * (1+s) : l+s-l*s;\\n            var t1 = 2 * l - t2;\\n            var h_ = h / 360;\\n            t3[0] = h_ + 1/3;\\n            t3[1] = h_;\\n            t3[2] = h_ - 1/3;\\n            for (var i=0; i<3; i++) {\\n                if (t3[i] < 0) { t3[i] += 1; }\\n                if (t3[i] > 1) { t3[i] -= 1; }\\n                if (6 * t3[i] < 1)\\n                    { c[i] = t1 + (t2 - t1) * 6 * t3[i]; }\\n                else if (2 * t3[i] < 1)\\n                    { c[i] = t2; }\\n                else if (3 * t3[i] < 2)\\n                    { c[i] = t1 + (t2 - t1) * ((2 / 3) - t3[i]) * 6; }\\n                else\\n                    { c[i] = t1; }\\n            }\\n            (assign = [round$1(c[0]*255),round$1(c[1]*255),round$1(c[2]*255)], r = assign[0], g = assign[1], b = assign[2]);\\n        }\\n        if (args.length > 3) {\\n            // keep alpha channel\\n            return [r,g,b,args[3]];\\n        }\\n        return [r,g,b,1];\\n    };\\n\\n    var hsl2rgb_1 = hsl2rgb;\\n\\n    var RE_RGB = /^rgb\\\\(\\\\s*(-?\\\\d+),\\\\s*(-?\\\\d+)\\\\s*,\\\\s*(-?\\\\d+)\\\\s*\\\\)$/;\\n    var RE_RGBA = /^rgba\\\\(\\\\s*(-?\\\\d+),\\\\s*(-?\\\\d+)\\\\s*,\\\\s*(-?\\\\d+)\\\\s*,\\\\s*([01]|[01]?\\\\.\\\\d+)\\\\)$/;\\n    var RE_RGB_PCT = /^rgb\\\\(\\\\s*(-?\\\\d+(?:\\\\.\\\\d+)?)%,\\\\s*(-?\\\\d+(?:\\\\.\\\\d+)?)%\\\\s*,\\\\s*(-?\\\\d+(?:\\\\.\\\\d+)?)%\\\\s*\\\\)$/;\\n    var RE_RGBA_PCT = /^rgba\\\\(\\\\s*(-?\\\\d+(?:\\\\.\\\\d+)?)%,\\\\s*(-?\\\\d+(?:\\\\.\\\\d+)?)%\\\\s*,\\\\s*(-?\\\\d+(?:\\\\.\\\\d+)?)%\\\\s*,\\\\s*([01]|[01]?\\\\.\\\\d+)\\\\)$/;\\n    var RE_HSL = /^hsl\\\\(\\\\s*(-?\\\\d+(?:\\\\.\\\\d+)?),\\\\s*(-?\\\\d+(?:\\\\.\\\\d+)?)%\\\\s*,\\\\s*(-?\\\\d+(?:\\\\.\\\\d+)?)%\\\\s*\\\\)$/;\\n    var RE_HSLA = /^hsla\\\\(\\\\s*(-?\\\\d+(?:\\\\.\\\\d+)?),\\\\s*(-?\\\\d+(?:\\\\.\\\\d+)?)%\\\\s*,\\\\s*(-?\\\\d+(?:\\\\.\\\\d+)?)%\\\\s*,\\\\s*([01]|[01]?\\\\.\\\\d+)\\\\)$/;\\n\\n    var round$2 = Math.round;\\n\\n    var css2rgb = function (css) {\\n        css = css.toLowerCase().trim();\\n        var m;\\n\\n        if (input.format.named) {\\n            try {\\n                return input.format.named(css);\\n            } catch (e) {\\n                // eslint-disable-next-line\\n            }\\n        }\\n\\n        // rgb(250,20,0)\\n        if ((m = css.match(RE_RGB))) {\\n            var rgb = m.slice(1,4);\\n            for (var i=0; i<3; i++) {\\n                rgb[i] = +rgb[i];\\n            }\\n            rgb[3] = 1;  // default alpha\\n            return rgb;\\n        }\\n\\n        // rgba(250,20,0,0.4)\\n        if ((m = css.match(RE_RGBA))) {\\n            var rgb$1 = m.slice(1,5);\\n            for (var i$1=0; i$1<4; i$1++) {\\n                rgb$1[i$1] = +rgb$1[i$1];\\n            }\\n            return rgb$1;\\n        }\\n\\n        // rgb(100%,0%,0%)\\n        if ((m = css.match(RE_RGB_PCT))) {\\n            var rgb$2 = m.slice(1,4);\\n            for (var i$2=0; i$2<3; i$2++) {\\n                rgb$2[i$2] = round$2(rgb$2[i$2] * 2.55);\\n            }\\n            rgb$2[3] = 1;  // default alpha\\n            return rgb$2;\\n        }\\n\\n        // rgba(100%,0%,0%,0.4)\\n        if ((m = css.match(RE_RGBA_PCT))) {\\n            var rgb$3 = m.slice(1,5);\\n            for (var i$3=0; i$3<3; i$3++) {\\n                rgb$3[i$3] = round$2(rgb$3[i$3] * 2.55);\\n            }\\n            rgb$3[3] = +rgb$3[3];\\n            return rgb$3;\\n        }\\n\\n        // hsl(0,100%,50%)\\n        if ((m = css.match(RE_HSL))) {\\n            var hsl = m.slice(1,4);\\n            hsl[1] *= 0.01;\\n            hsl[2] *= 0.01;\\n            var rgb$4 = hsl2rgb_1(hsl);\\n            rgb$4[3] = 1;\\n            return rgb$4;\\n        }\\n\\n        // hsla(0,100%,50%,0.5)\\n        if ((m = css.match(RE_HSLA))) {\\n            var hsl$1 = m.slice(1,4);\\n            hsl$1[1] *= 0.01;\\n            hsl$1[2] *= 0.01;\\n            var rgb$5 = hsl2rgb_1(hsl$1);\\n            rgb$5[3] = +m[4];  // default alpha = 1\\n            return rgb$5;\\n        }\\n    };\\n\\n    css2rgb.test = function (s) {\\n        return RE_RGB.test(s) ||\\n            RE_RGBA.test(s) ||\\n            RE_RGB_PCT.test(s) ||\\n            RE_RGBA_PCT.test(s) ||\\n            RE_HSL.test(s) ||\\n            RE_HSLA.test(s);\\n    };\\n\\n    var css2rgb_1 = css2rgb;\\n\\n    var type$3 = utils.type;\\n\\n\\n\\n\\n    Color_1.prototype.css = function(mode) {\\n        return rgb2css_1(this._rgb, mode);\\n    };\\n\\n    chroma_1.css = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['css']) ));\\n    };\\n\\n    input.format.css = css2rgb_1;\\n\\n    input.autodetect.push({\\n        p: 5,\\n        test: function (h) {\\n            var rest = [], len = arguments.length - 1;\\n            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];\\n\\n            if (!rest.length && type$3(h) === 'string' && css2rgb_1.test(h)) {\\n                return 'css';\\n            }\\n        }\\n    });\\n\\n    var unpack$8 = utils.unpack;\\n\\n    input.format.gl = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        var rgb = unpack$8(args, 'rgba');\\n        rgb[0] *= 255;\\n        rgb[1] *= 255;\\n        rgb[2] *= 255;\\n        return rgb;\\n    };\\n\\n    chroma_1.gl = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['gl']) ));\\n    };\\n\\n    Color_1.prototype.gl = function() {\\n        var rgb = this._rgb;\\n        return [rgb[0]/255, rgb[1]/255, rgb[2]/255, rgb[3]];\\n    };\\n\\n    var unpack$9 = utils.unpack;\\n\\n    var rgb2hcg = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        var ref = unpack$9(args, 'rgb');\\n        var r = ref[0];\\n        var g = ref[1];\\n        var b = ref[2];\\n        var min = Math.min(r, g, b);\\n        var max = Math.max(r, g, b);\\n        var delta = max - min;\\n        var c = delta * 100 / 255;\\n        var _g = min / (255 - delta) * 100;\\n        var h;\\n        if (delta === 0) {\\n            h = Number.NaN;\\n        } else {\\n            if (r === max) { h = (g - b) / delta; }\\n            if (g === max) { h = 2+(b - r) / delta; }\\n            if (b === max) { h = 4+(r - g) / delta; }\\n            h *= 60;\\n            if (h < 0) { h += 360; }\\n        }\\n        return [h, c, _g];\\n    };\\n\\n    var rgb2hcg_1 = rgb2hcg;\\n\\n    var unpack$a = utils.unpack;\\n    var floor = Math.floor;\\n\\n    /*\\n     * this is basically just HSV with some minor tweaks\\n     *\\n     * hue.. [0..360]\\n     * chroma .. [0..1]\\n     * grayness .. [0..1]\\n     */\\n\\n    var hcg2rgb = function () {\\n        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;\\n\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n        args = unpack$a(args, 'hcg');\\n        var h = args[0];\\n        var c = args[1];\\n        var _g = args[2];\\n        var r,g,b;\\n        _g = _g * 255;\\n        var _c = c * 255;\\n        if (c === 0) {\\n            r = g = b = _g;\\n        } else {\\n            if (h === 360) { h = 0; }\\n            if (h > 360) { h -= 360; }\\n            if (h < 0) { h += 360; }\\n            h /= 60;\\n            var i = floor(h);\\n            var f = h - i;\\n            var p = _g * (1 - c);\\n            var q = p + _c * (1 - f);\\n            var t = p + _c * f;\\n            var v = p + _c;\\n            switch (i) {\\n                case 0: (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]); break\\n                case 1: (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]); break\\n                case 2: (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]); break\\n                case 3: (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]); break\\n                case 4: (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]); break\\n                case 5: (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]); break\\n            }\\n        }\\n        return [r, g, b, args.length > 3 ? args[3] : 1];\\n    };\\n\\n    var hcg2rgb_1 = hcg2rgb;\\n\\n    var unpack$b = utils.unpack;\\n    var type$4 = utils.type;\\n\\n\\n\\n\\n\\n\\n    Color_1.prototype.hcg = function() {\\n        return rgb2hcg_1(this._rgb);\\n    };\\n\\n    chroma_1.hcg = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hcg']) ));\\n    };\\n\\n    input.format.hcg = hcg2rgb_1;\\n\\n    input.autodetect.push({\\n        p: 1,\\n        test: function () {\\n            var args = [], len = arguments.length;\\n            while ( len-- ) args[ len ] = arguments[ len ];\\n\\n            args = unpack$b(args, 'hcg');\\n            if (type$4(args) === 'array' && args.length === 3) {\\n                return 'hcg';\\n            }\\n        }\\n    });\\n\\n    var unpack$c = utils.unpack;\\n    var last$4 = utils.last;\\n    var round$3 = Math.round;\\n\\n    var rgb2hex = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        var ref = unpack$c(args, 'rgba');\\n        var r = ref[0];\\n        var g = ref[1];\\n        var b = ref[2];\\n        var a = ref[3];\\n        var mode = last$4(args) || 'auto';\\n        if (a === undefined) { a = 1; }\\n        if (mode === 'auto') {\\n            mode = a < 1 ? 'rgba' : 'rgb';\\n        }\\n        r = round$3(r);\\n        g = round$3(g);\\n        b = round$3(b);\\n        var u = r << 16 | g << 8 | b;\\n        var str = \\\"000000\\\" + u.toString(16); //#.toUpperCase();\\n        str = str.substr(str.length - 6);\\n        var hxa = '0' + round$3(a * 255).toString(16);\\n        hxa = hxa.substr(hxa.length - 2);\\n        switch (mode.toLowerCase()) {\\n            case 'rgba': return (\\\"#\\\" + str + hxa);\\n            case 'argb': return (\\\"#\\\" + hxa + str);\\n            default: return (\\\"#\\\" + str);\\n        }\\n    };\\n\\n    var rgb2hex_1 = rgb2hex;\\n\\n    var RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;\\n    var RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;\\n\\n    var hex2rgb = function (hex) {\\n        if (hex.match(RE_HEX)) {\\n            // remove optional leading #\\n            if (hex.length === 4 || hex.length === 7) {\\n                hex = hex.substr(1);\\n            }\\n            // expand short-notation to full six-digit\\n            if (hex.length === 3) {\\n                hex = hex.split('');\\n                hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];\\n            }\\n            var u = parseInt(hex, 16);\\n            var r = u >> 16;\\n            var g = u >> 8 & 0xFF;\\n            var b = u & 0xFF;\\n            return [r,g,b,1];\\n        }\\n\\n        // match rgba hex format, eg #FF000077\\n        if (hex.match(RE_HEXA)) {\\n            if (hex.length === 5 || hex.length === 9) {\\n                // remove optional leading #\\n                hex = hex.substr(1);\\n            }\\n            // expand short-notation to full eight-digit\\n            if (hex.length === 4) {\\n                hex = hex.split('');\\n                hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2]+hex[3]+hex[3];\\n            }\\n            var u$1 = parseInt(hex, 16);\\n            var r$1 = u$1 >> 24 & 0xFF;\\n            var g$1 = u$1 >> 16 & 0xFF;\\n            var b$1 = u$1 >> 8 & 0xFF;\\n            var a = Math.round((u$1 & 0xFF) / 0xFF * 100) / 100;\\n            return [r$1,g$1,b$1,a];\\n        }\\n\\n        // we used to check for css colors here\\n        // if _input.css? and rgb = _input.css hex\\n        //     return rgb\\n\\n        throw new Error((\\\"unknown hex color: \\\" + hex));\\n    };\\n\\n    var hex2rgb_1 = hex2rgb;\\n\\n    var type$5 = utils.type;\\n\\n\\n\\n\\n    Color_1.prototype.hex = function(mode) {\\n        return rgb2hex_1(this._rgb, mode);\\n    };\\n\\n    chroma_1.hex = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hex']) ));\\n    };\\n\\n    input.format.hex = hex2rgb_1;\\n    input.autodetect.push({\\n        p: 4,\\n        test: function (h) {\\n            var rest = [], len = arguments.length - 1;\\n            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];\\n\\n            if (!rest.length && type$5(h) === 'string' && [3,4,5,6,7,8,9].indexOf(h.length) >= 0) {\\n                return 'hex';\\n            }\\n        }\\n    });\\n\\n    var unpack$d = utils.unpack;\\n    var TWOPI = utils.TWOPI;\\n    var min = Math.min;\\n    var sqrt = Math.sqrt;\\n    var acos = Math.acos;\\n\\n    var rgb2hsi = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        /*\\n        borrowed from here:\\n        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/rgb2hsi.cpp\\n        */\\n        var ref = unpack$d(args, 'rgb');\\n        var r = ref[0];\\n        var g = ref[1];\\n        var b = ref[2];\\n        r /= 255;\\n        g /= 255;\\n        b /= 255;\\n        var h;\\n        var min_ = min(r,g,b);\\n        var i = (r+g+b) / 3;\\n        var s = i > 0 ? 1 - min_/i : 0;\\n        if (s === 0) {\\n            h = NaN;\\n        } else {\\n            h = ((r-g)+(r-b)) / 2;\\n            h /= sqrt((r-g)*(r-g) + (r-b)*(g-b));\\n            h = acos(h);\\n            if (b > g) {\\n                h = TWOPI - h;\\n            }\\n            h /= TWOPI;\\n        }\\n        return [h*360,s,i];\\n    };\\n\\n    var rgb2hsi_1 = rgb2hsi;\\n\\n    var unpack$e = utils.unpack;\\n    var limit$1 = utils.limit;\\n    var TWOPI$1 = utils.TWOPI;\\n    var PITHIRD = utils.PITHIRD;\\n    var cos = Math.cos;\\n\\n    /*\\n     * hue [0..360]\\n     * saturation [0..1]\\n     * intensity [0..1]\\n     */\\n    var hsi2rgb = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        /*\\n        borrowed from here:\\n        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp\\n        */\\n        args = unpack$e(args, 'hsi');\\n        var h = args[0];\\n        var s = args[1];\\n        var i = args[2];\\n        var r,g,b;\\n\\n        if (isNaN(h)) { h = 0; }\\n        if (isNaN(s)) { s = 0; }\\n        // normalize hue\\n        if (h > 360) { h -= 360; }\\n        if (h < 0) { h += 360; }\\n        h /= 360;\\n        if (h < 1/3) {\\n            b = (1-s)/3;\\n            r = (1+s*cos(TWOPI$1*h)/cos(PITHIRD-TWOPI$1*h))/3;\\n            g = 1 - (b+r);\\n        } else if (h < 2/3) {\\n            h -= 1/3;\\n            r = (1-s)/3;\\n            g = (1+s*cos(TWOPI$1*h)/cos(PITHIRD-TWOPI$1*h))/3;\\n            b = 1 - (r+g);\\n        } else {\\n            h -= 2/3;\\n            g = (1-s)/3;\\n            b = (1+s*cos(TWOPI$1*h)/cos(PITHIRD-TWOPI$1*h))/3;\\n            r = 1 - (g+b);\\n        }\\n        r = limit$1(i*r*3);\\n        g = limit$1(i*g*3);\\n        b = limit$1(i*b*3);\\n        return [r*255, g*255, b*255, args.length > 3 ? args[3] : 1];\\n    };\\n\\n    var hsi2rgb_1 = hsi2rgb;\\n\\n    var unpack$f = utils.unpack;\\n    var type$6 = utils.type;\\n\\n\\n\\n\\n\\n\\n    Color_1.prototype.hsi = function() {\\n        return rgb2hsi_1(this._rgb);\\n    };\\n\\n    chroma_1.hsi = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hsi']) ));\\n    };\\n\\n    input.format.hsi = hsi2rgb_1;\\n\\n    input.autodetect.push({\\n        p: 2,\\n        test: function () {\\n            var args = [], len = arguments.length;\\n            while ( len-- ) args[ len ] = arguments[ len ];\\n\\n            args = unpack$f(args, 'hsi');\\n            if (type$6(args) === 'array' && args.length === 3) {\\n                return 'hsi';\\n            }\\n        }\\n    });\\n\\n    var unpack$g = utils.unpack;\\n    var type$7 = utils.type;\\n\\n\\n\\n\\n\\n\\n    Color_1.prototype.hsl = function() {\\n        return rgb2hsl_1(this._rgb);\\n    };\\n\\n    chroma_1.hsl = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hsl']) ));\\n    };\\n\\n    input.format.hsl = hsl2rgb_1;\\n\\n    input.autodetect.push({\\n        p: 2,\\n        test: function () {\\n            var args = [], len = arguments.length;\\n            while ( len-- ) args[ len ] = arguments[ len ];\\n\\n            args = unpack$g(args, 'hsl');\\n            if (type$7(args) === 'array' && args.length === 3) {\\n                return 'hsl';\\n            }\\n        }\\n    });\\n\\n    var unpack$h = utils.unpack;\\n    var min$1 = Math.min;\\n    var max$1 = Math.max;\\n\\n    /*\\n     * supported arguments:\\n     * - rgb2hsv(r,g,b)\\n     * - rgb2hsv([r,g,b])\\n     * - rgb2hsv({r,g,b})\\n     */\\n    var rgb2hsl$1 = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        args = unpack$h(args, 'rgb');\\n        var r = args[0];\\n        var g = args[1];\\n        var b = args[2];\\n        var min_ = min$1(r, g, b);\\n        var max_ = max$1(r, g, b);\\n        var delta = max_ - min_;\\n        var h,s,v;\\n        v = max_ / 255.0;\\n        if (max_ === 0) {\\n            h = Number.NaN;\\n            s = 0;\\n        } else {\\n            s = delta / max_;\\n            if (r === max_) { h = (g - b) / delta; }\\n            if (g === max_) { h = 2+(b - r) / delta; }\\n            if (b === max_) { h = 4+(r - g) / delta; }\\n            h *= 60;\\n            if (h < 0) { h += 360; }\\n        }\\n        return [h, s, v]\\n    };\\n\\n    var rgb2hsv = rgb2hsl$1;\\n\\n    var unpack$i = utils.unpack;\\n    var floor$1 = Math.floor;\\n\\n    var hsv2rgb = function () {\\n        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;\\n\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n        args = unpack$i(args, 'hsv');\\n        var h = args[0];\\n        var s = args[1];\\n        var v = args[2];\\n        var r,g,b;\\n        v *= 255;\\n        if (s === 0) {\\n            r = g = b = v;\\n        } else {\\n            if (h === 360) { h = 0; }\\n            if (h > 360) { h -= 360; }\\n            if (h < 0) { h += 360; }\\n            h /= 60;\\n\\n            var i = floor$1(h);\\n            var f = h - i;\\n            var p = v * (1 - s);\\n            var q = v * (1 - s * f);\\n            var t = v * (1 - s * (1 - f));\\n\\n            switch (i) {\\n                case 0: (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]); break\\n                case 1: (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]); break\\n                case 2: (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]); break\\n                case 3: (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]); break\\n                case 4: (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]); break\\n                case 5: (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]); break\\n            }\\n        }\\n        return [r,g,b,args.length > 3?args[3]:1];\\n    };\\n\\n    var hsv2rgb_1 = hsv2rgb;\\n\\n    var unpack$j = utils.unpack;\\n    var type$8 = utils.type;\\n\\n\\n\\n\\n\\n\\n    Color_1.prototype.hsv = function() {\\n        return rgb2hsv(this._rgb);\\n    };\\n\\n    chroma_1.hsv = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hsv']) ));\\n    };\\n\\n    input.format.hsv = hsv2rgb_1;\\n\\n    input.autodetect.push({\\n        p: 2,\\n        test: function () {\\n            var args = [], len = arguments.length;\\n            while ( len-- ) args[ len ] = arguments[ len ];\\n\\n            args = unpack$j(args, 'hsv');\\n            if (type$8(args) === 'array' && args.length === 3) {\\n                return 'hsv';\\n            }\\n        }\\n    });\\n\\n    var labConstants = {\\n        // Corresponds roughly to RGB brighter/darker\\n        Kn: 18,\\n\\n        // D65 standard referent\\n        Xn: 0.950470,\\n        Yn: 1,\\n        Zn: 1.088830,\\n\\n        t0: 0.137931034,  // 4 / 29\\n        t1: 0.206896552,  // 6 / 29\\n        t2: 0.12841855,   // 3 * t1 * t1\\n        t3: 0.008856452,  // t1 * t1 * t1\\n    };\\n\\n    var unpack$k = utils.unpack;\\n    var pow = Math.pow;\\n\\n    var rgb2lab = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        var ref = unpack$k(args, 'rgb');\\n        var r = ref[0];\\n        var g = ref[1];\\n        var b = ref[2];\\n        var ref$1 = rgb2xyz(r,g,b);\\n        var x = ref$1[0];\\n        var y = ref$1[1];\\n        var z = ref$1[2];\\n        var l = 116 * y - 16;\\n        return [l < 0 ? 0 : l, 500 * (x - y), 200 * (y - z)];\\n    };\\n\\n    var rgb_xyz = function (r) {\\n        if ((r /= 255) <= 0.04045) { return r / 12.92; }\\n        return pow((r + 0.055) / 1.055, 2.4);\\n    };\\n\\n    var xyz_lab = function (t) {\\n        if (t > labConstants.t3) { return pow(t, 1 / 3); }\\n        return t / labConstants.t2 + labConstants.t0;\\n    };\\n\\n    var rgb2xyz = function (r,g,b) {\\n        r = rgb_xyz(r);\\n        g = rgb_xyz(g);\\n        b = rgb_xyz(b);\\n        var x = xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / labConstants.Xn);\\n        var y = xyz_lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / labConstants.Yn);\\n        var z = xyz_lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / labConstants.Zn);\\n        return [x,y,z];\\n    };\\n\\n    var rgb2lab_1 = rgb2lab;\\n\\n    var unpack$l = utils.unpack;\\n    var pow$1 = Math.pow;\\n\\n    /*\\n     * L* [0..100]\\n     * a [-100..100]\\n     * b [-100..100]\\n     */\\n    var lab2rgb = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        args = unpack$l(args, 'lab');\\n        var l = args[0];\\n        var a = args[1];\\n        var b = args[2];\\n        var x,y,z, r,g,b_;\\n\\n        y = (l + 16) / 116;\\n        x = isNaN(a) ? y : y + a / 500;\\n        z = isNaN(b) ? y : y - b / 200;\\n\\n        y = labConstants.Yn * lab_xyz(y);\\n        x = labConstants.Xn * lab_xyz(x);\\n        z = labConstants.Zn * lab_xyz(z);\\n\\n        r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z);  // D65 -> sRGB\\n        g = xyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z);\\n        b_ = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);\\n\\n        return [r,g,b_,args.length > 3 ? args[3] : 1];\\n    };\\n\\n    var xyz_rgb = function (r) {\\n        return 255 * (r <= 0.00304 ? 12.92 * r : 1.055 * pow$1(r, 1 / 2.4) - 0.055)\\n    };\\n\\n    var lab_xyz = function (t) {\\n        return t > labConstants.t1 ? t * t * t : labConstants.t2 * (t - labConstants.t0)\\n    };\\n\\n    var lab2rgb_1 = lab2rgb;\\n\\n    var unpack$m = utils.unpack;\\n    var type$9 = utils.type;\\n\\n\\n\\n\\n\\n\\n    Color_1.prototype.lab = function() {\\n        return rgb2lab_1(this._rgb);\\n    };\\n\\n    chroma_1.lab = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['lab']) ));\\n    };\\n\\n    input.format.lab = lab2rgb_1;\\n\\n    input.autodetect.push({\\n        p: 2,\\n        test: function () {\\n            var args = [], len = arguments.length;\\n            while ( len-- ) args[ len ] = arguments[ len ];\\n\\n            args = unpack$m(args, 'lab');\\n            if (type$9(args) === 'array' && args.length === 3) {\\n                return 'lab';\\n            }\\n        }\\n    });\\n\\n    var unpack$n = utils.unpack;\\n    var RAD2DEG = utils.RAD2DEG;\\n    var sqrt$1 = Math.sqrt;\\n    var atan2 = Math.atan2;\\n    var round$4 = Math.round;\\n\\n    var lab2lch = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        var ref = unpack$n(args, 'lab');\\n        var l = ref[0];\\n        var a = ref[1];\\n        var b = ref[2];\\n        var c = sqrt$1(a * a + b * b);\\n        var h = (atan2(b, a) * RAD2DEG + 360) % 360;\\n        if (round$4(c*10000) === 0) { h = Number.NaN; }\\n        return [l, c, h];\\n    };\\n\\n    var lab2lch_1 = lab2lch;\\n\\n    var unpack$o = utils.unpack;\\n\\n\\n\\n    var rgb2lch = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        var ref = unpack$o(args, 'rgb');\\n        var r = ref[0];\\n        var g = ref[1];\\n        var b = ref[2];\\n        var ref$1 = rgb2lab_1(r,g,b);\\n        var l = ref$1[0];\\n        var a = ref$1[1];\\n        var b_ = ref$1[2];\\n        return lab2lch_1(l,a,b_);\\n    };\\n\\n    var rgb2lch_1 = rgb2lch;\\n\\n    var unpack$p = utils.unpack;\\n    var DEG2RAD = utils.DEG2RAD;\\n    var sin = Math.sin;\\n    var cos$1 = Math.cos;\\n\\n    var lch2lab = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        /*\\n        Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel.\\n        These formulas were invented by David Dalrymple to obtain maximum contrast without going\\n        out of gamut if the parameters are in the range 0-1.\\n\\n        A saturation multiplier was added by Gregor Aisch\\n        */\\n        var ref = unpack$p(args, 'lch');\\n        var l = ref[0];\\n        var c = ref[1];\\n        var h = ref[2];\\n        if (isNaN(h)) { h = 0; }\\n        h = h * DEG2RAD;\\n        return [l, cos$1(h) * c, sin(h) * c]\\n    };\\n\\n    var lch2lab_1 = lch2lab;\\n\\n    var unpack$q = utils.unpack;\\n\\n\\n\\n    var lch2rgb = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        args = unpack$q(args, 'lch');\\n        var l = args[0];\\n        var c = args[1];\\n        var h = args[2];\\n        var ref = lch2lab_1 (l,c,h);\\n        var L = ref[0];\\n        var a = ref[1];\\n        var b_ = ref[2];\\n        var ref$1 = lab2rgb_1 (L,a,b_);\\n        var r = ref$1[0];\\n        var g = ref$1[1];\\n        var b = ref$1[2];\\n        return [r, g, b, args.length > 3 ? args[3] : 1];\\n    };\\n\\n    var lch2rgb_1 = lch2rgb;\\n\\n    var unpack$r = utils.unpack;\\n\\n\\n    var hcl2rgb = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        var hcl = unpack$r(args, 'hcl').reverse();\\n        return lch2rgb_1.apply(void 0, hcl);\\n    };\\n\\n    var hcl2rgb_1 = hcl2rgb;\\n\\n    var unpack$s = utils.unpack;\\n    var type$a = utils.type;\\n\\n\\n\\n\\n\\n\\n    Color_1.prototype.lch = function() { return rgb2lch_1(this._rgb); };\\n    Color_1.prototype.hcl = function() { return rgb2lch_1(this._rgb).reverse(); };\\n\\n    chroma_1.lch = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['lch']) ));\\n    };\\n    chroma_1.hcl = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['hcl']) ));\\n    };\\n\\n    input.format.lch = lch2rgb_1;\\n    input.format.hcl = hcl2rgb_1;\\n\\n    ['lch','hcl'].forEach(function (m) { return input.autodetect.push({\\n        p: 2,\\n        test: function () {\\n            var args = [], len = arguments.length;\\n            while ( len-- ) args[ len ] = arguments[ len ];\\n\\n            args = unpack$s(args, m);\\n            if (type$a(args) === 'array' && args.length === 3) {\\n                return m;\\n            }\\n        }\\n    }); });\\n\\n    /**\\n    \\tX11 color names\\n\\n    \\thttp://www.w3.org/TR/css3-color/#svg-color\\n    */\\n\\n    var w3cx11 = {\\n        aliceblue: '#f0f8ff',\\n        antiquewhite: '#faebd7',\\n        aqua: '#00ffff',\\n        aquamarine: '#7fffd4',\\n        azure: '#f0ffff',\\n        beige: '#f5f5dc',\\n        bisque: '#ffe4c4',\\n        black: '#000000',\\n        blanchedalmond: '#ffebcd',\\n        blue: '#0000ff',\\n        blueviolet: '#8a2be2',\\n        brown: '#a52a2a',\\n        burlywood: '#deb887',\\n        cadetblue: '#5f9ea0',\\n        chartreuse: '#7fff00',\\n        chocolate: '#d2691e',\\n        coral: '#ff7f50',\\n        cornflower: '#6495ed',\\n        cornflowerblue: '#6495ed',\\n        cornsilk: '#fff8dc',\\n        crimson: '#dc143c',\\n        cyan: '#00ffff',\\n        darkblue: '#00008b',\\n        darkcyan: '#008b8b',\\n        darkgoldenrod: '#b8860b',\\n        darkgray: '#a9a9a9',\\n        darkgreen: '#006400',\\n        darkgrey: '#a9a9a9',\\n        darkkhaki: '#bdb76b',\\n        darkmagenta: '#8b008b',\\n        darkolivegreen: '#556b2f',\\n        darkorange: '#ff8c00',\\n        darkorchid: '#9932cc',\\n        darkred: '#8b0000',\\n        darksalmon: '#e9967a',\\n        darkseagreen: '#8fbc8f',\\n        darkslateblue: '#483d8b',\\n        darkslategray: '#2f4f4f',\\n        darkslategrey: '#2f4f4f',\\n        darkturquoise: '#00ced1',\\n        darkviolet: '#9400d3',\\n        deeppink: '#ff1493',\\n        deepskyblue: '#00bfff',\\n        dimgray: '#696969',\\n        dimgrey: '#696969',\\n        dodgerblue: '#1e90ff',\\n        firebrick: '#b22222',\\n        floralwhite: '#fffaf0',\\n        forestgreen: '#228b22',\\n        fuchsia: '#ff00ff',\\n        gainsboro: '#dcdcdc',\\n        ghostwhite: '#f8f8ff',\\n        gold: '#ffd700',\\n        goldenrod: '#daa520',\\n        gray: '#808080',\\n        green: '#008000',\\n        greenyellow: '#adff2f',\\n        grey: '#808080',\\n        honeydew: '#f0fff0',\\n        hotpink: '#ff69b4',\\n        indianred: '#cd5c5c',\\n        indigo: '#4b0082',\\n        ivory: '#fffff0',\\n        khaki: '#f0e68c',\\n        laserlemon: '#ffff54',\\n        lavender: '#e6e6fa',\\n        lavenderblush: '#fff0f5',\\n        lawngreen: '#7cfc00',\\n        lemonchiffon: '#fffacd',\\n        lightblue: '#add8e6',\\n        lightcoral: '#f08080',\\n        lightcyan: '#e0ffff',\\n        lightgoldenrod: '#fafad2',\\n        lightgoldenrodyellow: '#fafad2',\\n        lightgray: '#d3d3d3',\\n        lightgreen: '#90ee90',\\n        lightgrey: '#d3d3d3',\\n        lightpink: '#ffb6c1',\\n        lightsalmon: '#ffa07a',\\n        lightseagreen: '#20b2aa',\\n        lightskyblue: '#87cefa',\\n        lightslategray: '#778899',\\n        lightslategrey: '#778899',\\n        lightsteelblue: '#b0c4de',\\n        lightyellow: '#ffffe0',\\n        lime: '#00ff00',\\n        limegreen: '#32cd32',\\n        linen: '#faf0e6',\\n        magenta: '#ff00ff',\\n        maroon: '#800000',\\n        maroon2: '#7f0000',\\n        maroon3: '#b03060',\\n        mediumaquamarine: '#66cdaa',\\n        mediumblue: '#0000cd',\\n        mediumorchid: '#ba55d3',\\n        mediumpurple: '#9370db',\\n        mediumseagreen: '#3cb371',\\n        mediumslateblue: '#7b68ee',\\n        mediumspringgreen: '#00fa9a',\\n        mediumturquoise: '#48d1cc',\\n        mediumvioletred: '#c71585',\\n        midnightblue: '#191970',\\n        mintcream: '#f5fffa',\\n        mistyrose: '#ffe4e1',\\n        moccasin: '#ffe4b5',\\n        navajowhite: '#ffdead',\\n        navy: '#000080',\\n        oldlace: '#fdf5e6',\\n        olive: '#808000',\\n        olivedrab: '#6b8e23',\\n        orange: '#ffa500',\\n        orangered: '#ff4500',\\n        orchid: '#da70d6',\\n        palegoldenrod: '#eee8aa',\\n        palegreen: '#98fb98',\\n        paleturquoise: '#afeeee',\\n        palevioletred: '#db7093',\\n        papayawhip: '#ffefd5',\\n        peachpuff: '#ffdab9',\\n        peru: '#cd853f',\\n        pink: '#ffc0cb',\\n        plum: '#dda0dd',\\n        powderblue: '#b0e0e6',\\n        purple: '#800080',\\n        purple2: '#7f007f',\\n        purple3: '#a020f0',\\n        rebeccapurple: '#663399',\\n        red: '#ff0000',\\n        rosybrown: '#bc8f8f',\\n        royalblue: '#4169e1',\\n        saddlebrown: '#8b4513',\\n        salmon: '#fa8072',\\n        sandybrown: '#f4a460',\\n        seagreen: '#2e8b57',\\n        seashell: '#fff5ee',\\n        sienna: '#a0522d',\\n        silver: '#c0c0c0',\\n        skyblue: '#87ceeb',\\n        slateblue: '#6a5acd',\\n        slategray: '#708090',\\n        slategrey: '#708090',\\n        snow: '#fffafa',\\n        springgreen: '#00ff7f',\\n        steelblue: '#4682b4',\\n        tan: '#d2b48c',\\n        teal: '#008080',\\n        thistle: '#d8bfd8',\\n        tomato: '#ff6347',\\n        turquoise: '#40e0d0',\\n        violet: '#ee82ee',\\n        wheat: '#f5deb3',\\n        white: '#ffffff',\\n        whitesmoke: '#f5f5f5',\\n        yellow: '#ffff00',\\n        yellowgreen: '#9acd32'\\n    };\\n\\n    var w3cx11_1 = w3cx11;\\n\\n    var type$b = utils.type;\\n\\n\\n\\n\\n\\n    Color_1.prototype.name = function() {\\n        var hex = rgb2hex_1(this._rgb, 'rgb');\\n        for (var i = 0, list = Object.keys(w3cx11_1); i < list.length; i += 1) {\\n            var n = list[i];\\n\\n            if (w3cx11_1[n] === hex) { return n.toLowerCase(); }\\n        }\\n        return hex;\\n    };\\n\\n    input.format.named = function (name) {\\n        name = name.toLowerCase();\\n        if (w3cx11_1[name]) { return hex2rgb_1(w3cx11_1[name]); }\\n        throw new Error('unknown color name: '+name);\\n    };\\n\\n    input.autodetect.push({\\n        p: 5,\\n        test: function (h) {\\n            var rest = [], len = arguments.length - 1;\\n            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];\\n\\n            if (!rest.length && type$b(h) === 'string' && w3cx11_1[h.toLowerCase()]) {\\n                return 'named';\\n            }\\n        }\\n    });\\n\\n    var unpack$t = utils.unpack;\\n\\n    var rgb2num = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        var ref = unpack$t(args, 'rgb');\\n        var r = ref[0];\\n        var g = ref[1];\\n        var b = ref[2];\\n        return (r << 16) + (g << 8) + b;\\n    };\\n\\n    var rgb2num_1 = rgb2num;\\n\\n    var type$c = utils.type;\\n\\n    var num2rgb = function (num) {\\n        if (type$c(num) == \\\"number\\\" && num >= 0 && num <= 0xFFFFFF) {\\n            var r = num >> 16;\\n            var g = (num >> 8) & 0xFF;\\n            var b = num & 0xFF;\\n            return [r,g,b,1];\\n        }\\n        throw new Error(\\\"unknown num color: \\\"+num);\\n    };\\n\\n    var num2rgb_1 = num2rgb;\\n\\n    var type$d = utils.type;\\n\\n\\n\\n    Color_1.prototype.num = function() {\\n        return rgb2num_1(this._rgb);\\n    };\\n\\n    chroma_1.num = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['num']) ));\\n    };\\n\\n    input.format.num = num2rgb_1;\\n\\n    input.autodetect.push({\\n        p: 5,\\n        test: function () {\\n            var args = [], len = arguments.length;\\n            while ( len-- ) args[ len ] = arguments[ len ];\\n\\n            if (args.length === 1 && type$d(args[0]) === 'number' && args[0] >= 0 && args[0] <= 0xFFFFFF) {\\n                return 'num';\\n            }\\n        }\\n    });\\n\\n    var unpack$u = utils.unpack;\\n    var type$e = utils.type;\\n    var round$5 = Math.round;\\n\\n    Color_1.prototype.rgb = function(rnd) {\\n        if ( rnd === void 0 ) rnd=true;\\n\\n        if (rnd === false) { return this._rgb.slice(0,3); }\\n        return this._rgb.slice(0,3).map(round$5);\\n    };\\n\\n    Color_1.prototype.rgba = function(rnd) {\\n        if ( rnd === void 0 ) rnd=true;\\n\\n        return this._rgb.slice(0,4).map(function (v,i) {\\n            return i<3 ? (rnd === false ? v : round$5(v)) : v;\\n        });\\n    };\\n\\n    chroma_1.rgb = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['rgb']) ));\\n    };\\n\\n    input.format.rgb = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        var rgba = unpack$u(args, 'rgba');\\n        if (rgba[3] === undefined) { rgba[3] = 1; }\\n        return rgba;\\n    };\\n\\n    input.autodetect.push({\\n        p: 3,\\n        test: function () {\\n            var args = [], len = arguments.length;\\n            while ( len-- ) args[ len ] = arguments[ len ];\\n\\n            args = unpack$u(args, 'rgba');\\n            if (type$e(args) === 'array' && (args.length === 3 ||\\n                args.length === 4 && type$e(args[3]) == 'number' && args[3] >= 0 && args[3] <= 1)) {\\n                return 'rgb';\\n            }\\n        }\\n    });\\n\\n    /*\\n     * Based on implementation by Neil Bartlett\\n     * https://github.com/neilbartlett/color-temperature\\n     */\\n\\n    var log = Math.log;\\n\\n    var temperature2rgb = function (kelvin) {\\n        var temp = kelvin / 100;\\n        var r,g,b;\\n        if (temp < 66) {\\n            r = 255;\\n            g = -155.25485562709179 - 0.44596950469579133 * (g = temp-2) + 104.49216199393888 * log(g);\\n            b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp-10) + 115.67994401066147 * log(b);\\n        } else {\\n            r = 351.97690566805693 + 0.114206453784165 * (r = temp-55) - 40.25366309332127 * log(r);\\n            g = 325.4494125711974 + 0.07943456536662342 * (g = temp-50) - 28.0852963507957 * log(g);\\n            b = 255;\\n        }\\n        return [r,g,b,1];\\n    };\\n\\n    var temperature2rgb_1 = temperature2rgb;\\n\\n    /*\\n     * Based on implementation by Neil Bartlett\\n     * https://github.com/neilbartlett/color-temperature\\n     **/\\n\\n\\n    var unpack$v = utils.unpack;\\n    var round$6 = Math.round;\\n\\n    var rgb2temperature = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        var rgb = unpack$v(args, 'rgb');\\n        var r = rgb[0], b = rgb[2];\\n        var minTemp = 1000;\\n        var maxTemp = 40000;\\n        var eps = 0.4;\\n        var temp;\\n        while (maxTemp - minTemp > eps) {\\n            temp = (maxTemp + minTemp) * 0.5;\\n            var rgb$1 = temperature2rgb_1(temp);\\n            if ((rgb$1[2] / rgb$1[0]) >= (b / r)) {\\n                maxTemp = temp;\\n            } else {\\n                minTemp = temp;\\n            }\\n        }\\n        return round$6(temp);\\n    };\\n\\n    var rgb2temperature_1 = rgb2temperature;\\n\\n    Color_1.prototype.temp =\\n    Color_1.prototype.kelvin =\\n    Color_1.prototype.temperature = function() {\\n        return rgb2temperature_1(this._rgb);\\n    };\\n\\n    chroma_1.temp =\\n    chroma_1.kelvin =\\n    chroma_1.temperature = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        return new (Function.prototype.bind.apply( Color_1, [ null ].concat( args, ['temp']) ));\\n    };\\n\\n    input.format.temp =\\n    input.format.kelvin =\\n    input.format.temperature = temperature2rgb_1;\\n\\n    var type$f = utils.type;\\n\\n    Color_1.prototype.alpha = function(a, mutate) {\\n        if ( mutate === void 0 ) mutate=false;\\n\\n        if (a !== undefined && type$f(a) === 'number') {\\n            if (mutate) {\\n                this._rgb[3] = a;\\n                return this;\\n            }\\n            return new Color_1([this._rgb[0], this._rgb[1], this._rgb[2], a], 'rgb');\\n        }\\n        return this._rgb[3];\\n    };\\n\\n    Color_1.prototype.clipped = function() {\\n        return this._rgb._clipped || false;\\n    };\\n\\n    Color_1.prototype.darken = function(amount) {\\n    \\tif ( amount === void 0 ) amount=1;\\n\\n    \\tvar me = this;\\n    \\tvar lab = me.lab();\\n    \\tlab[0] -= labConstants.Kn * amount;\\n    \\treturn new Color_1(lab, 'lab').alpha(me.alpha(), true);\\n    };\\n\\n    Color_1.prototype.brighten = function(amount) {\\n    \\tif ( amount === void 0 ) amount=1;\\n\\n    \\treturn this.darken(-amount);\\n    };\\n\\n    Color_1.prototype.darker = Color_1.prototype.darken;\\n    Color_1.prototype.brighter = Color_1.prototype.brighten;\\n\\n    Color_1.prototype.get = function(mc) {\\n        var ref = mc.split('.');\\n        var mode = ref[0];\\n        var channel = ref[1];\\n        var src = this[mode]();\\n        if (channel) {\\n            var i = mode.indexOf(channel);\\n            if (i > -1) { return src[i]; }\\n            throw new Error((\\\"unknown channel \\\" + channel + \\\" in mode \\\" + mode));\\n        } else {\\n            return src;\\n        }\\n    };\\n\\n    var type$g = utils.type;\\n    var pow$2 = Math.pow;\\n\\n    var EPS = 1e-7;\\n    var MAX_ITER = 20;\\n\\n    Color_1.prototype.luminance = function(lum) {\\n        if (lum !== undefined && type$g(lum) === 'number') {\\n            if (lum === 0) {\\n                // return pure black\\n                return new Color_1([0,0,0,this._rgb[3]], 'rgb');\\n            }\\n            if (lum === 1) {\\n                // return pure white\\n                return new Color_1([255,255,255,this._rgb[3]], 'rgb');\\n            }\\n            // compute new color using...\\n            var cur_lum = this.luminance();\\n            var mode = 'rgb';\\n            var max_iter = MAX_ITER;\\n\\n            var test = function (low, high) {\\n                var mid = low.interpolate(high, 0.5, mode);\\n                var lm = mid.luminance();\\n                if (Math.abs(lum - lm) < EPS || !max_iter--) {\\n                    // close enough\\n                    return mid;\\n                }\\n                return lm > lum ? test(low, mid) : test(mid, high);\\n            };\\n\\n            var rgb = (cur_lum > lum ? test(new Color_1([0,0,0]), this) : test(this, new Color_1([255,255,255]))).rgb();\\n            return new Color_1(rgb.concat( [this._rgb[3]]));\\n        }\\n        return rgb2luminance.apply(void 0, (this._rgb).slice(0,3));\\n    };\\n\\n\\n    var rgb2luminance = function (r,g,b) {\\n        // relative luminance\\n        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\\n        r = luminance_x(r);\\n        g = luminance_x(g);\\n        b = luminance_x(b);\\n        return 0.2126 * r + 0.7152 * g + 0.0722 * b;\\n    };\\n\\n    var luminance_x = function (x) {\\n        x /= 255;\\n        return x <= 0.03928 ? x/12.92 : pow$2((x+0.055)/1.055, 2.4);\\n    };\\n\\n    var interpolator = {};\\n\\n    var type$h = utils.type;\\n\\n\\n    var mix = function (col1, col2, f) {\\n        if ( f === void 0 ) f=0.5;\\n        var rest = [], len = arguments.length - 3;\\n        while ( len-- > 0 ) rest[ len ] = arguments[ len + 3 ];\\n\\n        var mode = rest[0] || 'lrgb';\\n        if (!interpolator[mode] && !rest.length) {\\n            // fall back to the first supported mode\\n            mode = Object.keys(interpolator)[0];\\n        }\\n        if (!interpolator[mode]) {\\n            throw new Error((\\\"interpolation mode \\\" + mode + \\\" is not defined\\\"));\\n        }\\n        if (type$h(col1) !== 'object') { col1 = new Color_1(col1); }\\n        if (type$h(col2) !== 'object') { col2 = new Color_1(col2); }\\n        return interpolator[mode](col1, col2, f)\\n            .alpha(col1.alpha() + f * (col2.alpha() - col1.alpha()));\\n    };\\n\\n    Color_1.prototype.mix =\\n    Color_1.prototype.interpolate = function(col2, f) {\\n    \\tif ( f === void 0 ) f=0.5;\\n    \\tvar rest = [], len = arguments.length - 2;\\n    \\twhile ( len-- > 0 ) rest[ len ] = arguments[ len + 2 ];\\n\\n    \\treturn mix.apply(void 0, [ this, col2, f ].concat( rest ));\\n    };\\n\\n    Color_1.prototype.premultiply = function(mutate) {\\n    \\tif ( mutate === void 0 ) mutate=false;\\n\\n    \\tvar rgb = this._rgb;\\n    \\tvar a = rgb[3];\\n    \\tif (mutate) {\\n    \\t\\tthis._rgb = [rgb[0]*a, rgb[1]*a, rgb[2]*a, a];\\n    \\t\\treturn this;\\n    \\t} else {\\n    \\t\\treturn new Color_1([rgb[0]*a, rgb[1]*a, rgb[2]*a, a], 'rgb');\\n    \\t}\\n    };\\n\\n    Color_1.prototype.saturate = function(amount) {\\n    \\tif ( amount === void 0 ) amount=1;\\n\\n    \\tvar me = this;\\n    \\tvar lch = me.lch();\\n    \\tlch[1] += labConstants.Kn * amount;\\n    \\tif (lch[1] < 0) { lch[1] = 0; }\\n    \\treturn new Color_1(lch, 'lch').alpha(me.alpha(), true);\\n    };\\n\\n    Color_1.prototype.desaturate = function(amount) {\\n    \\tif ( amount === void 0 ) amount=1;\\n\\n    \\treturn this.saturate(-amount);\\n    };\\n\\n    var type$i = utils.type;\\n\\n    Color_1.prototype.set = function(mc, value, mutate) {\\n        if ( mutate === void 0 ) mutate=false;\\n\\n        var ref = mc.split('.');\\n        var mode = ref[0];\\n        var channel = ref[1];\\n        var src = this[mode]();\\n        if (channel) {\\n            var i = mode.indexOf(channel);\\n            if (i > -1) {\\n                if (type$i(value) == 'string') {\\n                    switch(value.charAt(0)) {\\n                        case '+': src[i] += +value; break;\\n                        case '-': src[i] += +value; break;\\n                        case '*': src[i] *= +(value.substr(1)); break;\\n                        case '/': src[i] /= +(value.substr(1)); break;\\n                        default: src[i] = +value;\\n                    }\\n                } else if (type$i(value) === 'number') {\\n                    src[i] = value;\\n                } else {\\n                    throw new Error(\\\"unsupported value for Color.set\\\");\\n                }\\n                var out = new Color_1(src, mode);\\n                if (mutate) {\\n                    this._rgb = out._rgb;\\n                    return this;\\n                }\\n                return out;\\n            }\\n            throw new Error((\\\"unknown channel \\\" + channel + \\\" in mode \\\" + mode));\\n        } else {\\n            return src;\\n        }\\n    };\\n\\n    var rgb$1 = function (col1, col2, f) {\\n        var xyz0 = col1._rgb;\\n        var xyz1 = col2._rgb;\\n        return new Color_1(\\n            xyz0[0] + f * (xyz1[0]-xyz0[0]),\\n            xyz0[1] + f * (xyz1[1]-xyz0[1]),\\n            xyz0[2] + f * (xyz1[2]-xyz0[2]),\\n            'rgb'\\n        )\\n    };\\n\\n    // register interpolator\\n    interpolator.rgb = rgb$1;\\n\\n    var sqrt$2 = Math.sqrt;\\n    var pow$3 = Math.pow;\\n\\n    var lrgb = function (col1, col2, f) {\\n        var ref = col1._rgb;\\n        var x1 = ref[0];\\n        var y1 = ref[1];\\n        var z1 = ref[2];\\n        var ref$1 = col2._rgb;\\n        var x2 = ref$1[0];\\n        var y2 = ref$1[1];\\n        var z2 = ref$1[2];\\n        return new Color_1(\\n            sqrt$2(pow$3(x1,2) * (1-f) + pow$3(x2,2) * f),\\n            sqrt$2(pow$3(y1,2) * (1-f) + pow$3(y2,2) * f),\\n            sqrt$2(pow$3(z1,2) * (1-f) + pow$3(z2,2) * f),\\n            'rgb'\\n        )\\n    };\\n\\n    // register interpolator\\n    interpolator.lrgb = lrgb;\\n\\n    var lab$1 = function (col1, col2, f) {\\n        var xyz0 = col1.lab();\\n        var xyz1 = col2.lab();\\n        return new Color_1(\\n            xyz0[0] + f * (xyz1[0]-xyz0[0]),\\n            xyz0[1] + f * (xyz1[1]-xyz0[1]),\\n            xyz0[2] + f * (xyz1[2]-xyz0[2]),\\n            'lab'\\n        )\\n    };\\n\\n    // register interpolator\\n    interpolator.lab = lab$1;\\n\\n    var _hsx = function (col1, col2, f, m) {\\n        var assign, assign$1;\\n\\n        var xyz0, xyz1;\\n        if (m === 'hsl') {\\n            xyz0 = col1.hsl();\\n            xyz1 = col2.hsl();\\n        } else if (m === 'hsv') {\\n            xyz0 = col1.hsv();\\n            xyz1 = col2.hsv();\\n        } else if (m === 'hcg') {\\n            xyz0 = col1.hcg();\\n            xyz1 = col2.hcg();\\n        } else if (m === 'hsi') {\\n            xyz0 = col1.hsi();\\n            xyz1 = col2.hsi();\\n        } else if (m === 'lch' || m === 'hcl') {\\n            m = 'hcl';\\n            xyz0 = col1.hcl();\\n            xyz1 = col2.hcl();\\n        }\\n\\n        var hue0, hue1, sat0, sat1, lbv0, lbv1;\\n        if (m.substr(0, 1) === 'h') {\\n            (assign = xyz0, hue0 = assign[0], sat0 = assign[1], lbv0 = assign[2]);\\n            (assign$1 = xyz1, hue1 = assign$1[0], sat1 = assign$1[1], lbv1 = assign$1[2]);\\n        }\\n\\n        var sat, hue, lbv, dh;\\n\\n        if (!isNaN(hue0) && !isNaN(hue1)) {\\n            // both colors have hue\\n            if (hue1 > hue0 && hue1 - hue0 > 180) {\\n                dh = hue1-(hue0+360);\\n            } else if (hue1 < hue0 && hue0 - hue1 > 180) {\\n                dh = hue1+360-hue0;\\n            } else{\\n                dh = hue1 - hue0;\\n            }\\n            hue = hue0 + f * dh;\\n        } else if (!isNaN(hue0)) {\\n            hue = hue0;\\n            if ((lbv1 == 1 || lbv1 == 0) && m != 'hsv') { sat = sat0; }\\n        } else if (!isNaN(hue1)) {\\n            hue = hue1;\\n            if ((lbv0 == 1 || lbv0 == 0) && m != 'hsv') { sat = sat1; }\\n        } else {\\n            hue = Number.NaN;\\n        }\\n\\n        if (sat === undefined) { sat = sat0 + f * (sat1 - sat0); }\\n        lbv = lbv0 + f * (lbv1-lbv0);\\n        return new Color_1([hue, sat, lbv], m);\\n    };\\n\\n    var lch$1 = function (col1, col2, f) {\\n    \\treturn _hsx(col1, col2, f, 'lch');\\n    };\\n\\n    // register interpolator\\n    interpolator.lch = lch$1;\\n    interpolator.hcl = lch$1;\\n\\n    var num$1 = function (col1, col2, f) {\\n        var c1 = col1.num();\\n        var c2 = col2.num();\\n        return new Color_1(c1 + f * (c2-c1), 'num')\\n    };\\n\\n    // register interpolator\\n    interpolator.num = num$1;\\n\\n    var hcg$1 = function (col1, col2, f) {\\n    \\treturn _hsx(col1, col2, f, 'hcg');\\n    };\\n\\n    // register interpolator\\n    interpolator.hcg = hcg$1;\\n\\n    var hsi$1 = function (col1, col2, f) {\\n    \\treturn _hsx(col1, col2, f, 'hsi');\\n    };\\n\\n    // register interpolator\\n    interpolator.hsi = hsi$1;\\n\\n    var hsl$1 = function (col1, col2, f) {\\n    \\treturn _hsx(col1, col2, f, 'hsl');\\n    };\\n\\n    // register interpolator\\n    interpolator.hsl = hsl$1;\\n\\n    var hsv$1 = function (col1, col2, f) {\\n    \\treturn _hsx(col1, col2, f, 'hsv');\\n    };\\n\\n    // register interpolator\\n    interpolator.hsv = hsv$1;\\n\\n    var clip_rgb$2 = utils.clip_rgb;\\n    var pow$4 = Math.pow;\\n    var sqrt$3 = Math.sqrt;\\n    var PI$1 = Math.PI;\\n    var cos$2 = Math.cos;\\n    var sin$1 = Math.sin;\\n    var atan2$1 = Math.atan2;\\n\\n    var average = function (colors, mode, weights) {\\n        if ( mode === void 0 ) mode='lrgb';\\n        if ( weights === void 0 ) weights=null;\\n\\n        var l = colors.length;\\n        if (!weights) { weights = Array.from(new Array(l)).map(function () { return 1; }); }\\n        // normalize weights\\n        var k = l / weights.reduce(function(a, b) { return a + b; });\\n        weights.forEach(function (w,i) { weights[i] *= k; });\\n        // convert colors to Color objects\\n        colors = colors.map(function (c) { return new Color_1(c); });\\n        if (mode === 'lrgb') {\\n            return _average_lrgb(colors, weights)\\n        }\\n        var first = colors.shift();\\n        var xyz = first.get(mode);\\n        var cnt = [];\\n        var dx = 0;\\n        var dy = 0;\\n        // initial color\\n        for (var i=0; i<xyz.length; i++) {\\n            xyz[i] = (xyz[i] || 0) * weights[0];\\n            cnt.push(isNaN(xyz[i]) ? 0 : weights[0]);\\n            if (mode.charAt(i) === 'h' && !isNaN(xyz[i])) {\\n                var A = xyz[i] / 180 * PI$1;\\n                dx += cos$2(A) * weights[0];\\n                dy += sin$1(A) * weights[0];\\n            }\\n        }\\n\\n        var alpha = first.alpha() * weights[0];\\n        colors.forEach(function (c,ci) {\\n            var xyz2 = c.get(mode);\\n            alpha += c.alpha() * weights[ci+1];\\n            for (var i=0; i<xyz.length; i++) {\\n                if (!isNaN(xyz2[i])) {\\n                    cnt[i] += weights[ci+1];\\n                    if (mode.charAt(i) === 'h') {\\n                        var A = xyz2[i] / 180 * PI$1;\\n                        dx += cos$2(A) * weights[ci+1];\\n                        dy += sin$1(A) * weights[ci+1];\\n                    } else {\\n                        xyz[i] += xyz2[i] * weights[ci+1];\\n                    }\\n                }\\n            }\\n        });\\n\\n        for (var i$1=0; i$1<xyz.length; i$1++) {\\n            if (mode.charAt(i$1) === 'h') {\\n                var A$1 = atan2$1(dy / cnt[i$1], dx / cnt[i$1]) / PI$1 * 180;\\n                while (A$1 < 0) { A$1 += 360; }\\n                while (A$1 >= 360) { A$1 -= 360; }\\n                xyz[i$1] = A$1;\\n            } else {\\n                xyz[i$1] = xyz[i$1]/cnt[i$1];\\n            }\\n        }\\n        alpha /= l;\\n        return (new Color_1(xyz, mode)).alpha(alpha > 0.99999 ? 1 : alpha, true);\\n    };\\n\\n\\n    var _average_lrgb = function (colors, weights) {\\n        var l = colors.length;\\n        var xyz = [0,0,0,0];\\n        for (var i=0; i < colors.length; i++) {\\n            var col = colors[i];\\n            var f = weights[i] / l;\\n            var rgb = col._rgb;\\n            xyz[0] += pow$4(rgb[0],2) * f;\\n            xyz[1] += pow$4(rgb[1],2) * f;\\n            xyz[2] += pow$4(rgb[2],2) * f;\\n            xyz[3] += rgb[3] * f;\\n        }\\n        xyz[0] = sqrt$3(xyz[0]);\\n        xyz[1] = sqrt$3(xyz[1]);\\n        xyz[2] = sqrt$3(xyz[2]);\\n        if (xyz[3] > 0.9999999) { xyz[3] = 1; }\\n        return new Color_1(clip_rgb$2(xyz));\\n    };\\n\\n    // minimal multi-purpose interface\\n\\n    // @requires utils color analyze\\n\\n\\n    var type$j = utils.type;\\n\\n    var pow$5 = Math.pow;\\n\\n    var scale = function(colors) {\\n\\n        // constructor\\n        var _mode = 'rgb';\\n        var _nacol = chroma_1('#ccc');\\n        var _spread = 0;\\n        // const _fixed = false;\\n        var _domain = [0, 1];\\n        var _pos = [];\\n        var _padding = [0,0];\\n        var _classes = false;\\n        var _colors = [];\\n        var _out = false;\\n        var _min = 0;\\n        var _max = 1;\\n        var _correctLightness = false;\\n        var _colorCache = {};\\n        var _useCache = true;\\n        var _gamma = 1;\\n\\n        // private methods\\n\\n        var setColors = function(colors) {\\n            colors = colors || ['#fff', '#000'];\\n            if (colors && type$j(colors) === 'string' && chroma_1.brewer &&\\n                chroma_1.brewer[colors.toLowerCase()]) {\\n                colors = chroma_1.brewer[colors.toLowerCase()];\\n            }\\n            if (type$j(colors) === 'array') {\\n                // handle single color\\n                if (colors.length === 1) {\\n                    colors = [colors[0], colors[0]];\\n                }\\n                // make a copy of the colors\\n                colors = colors.slice(0);\\n                // convert to chroma classes\\n                for (var c=0; c<colors.length; c++) {\\n                    colors[c] = chroma_1(colors[c]);\\n                }\\n                // auto-fill color position\\n                _pos.length = 0;\\n                for (var c$1=0; c$1<colors.length; c$1++) {\\n                    _pos.push(c$1/(colors.length-1));\\n                }\\n            }\\n            resetCache();\\n            return _colors = colors;\\n        };\\n\\n        var getClass = function(value) {\\n            if (_classes != null) {\\n                var n = _classes.length-1;\\n                var i = 0;\\n                while (i < n && value >= _classes[i]) {\\n                    i++;\\n                }\\n                return i-1;\\n            }\\n            return 0;\\n        };\\n\\n        var tMapLightness = function (t) { return t; };\\n        var tMapDomain = function (t) { return t; };\\n\\n        // const classifyValue = function(value) {\\n        //     let val = value;\\n        //     if (_classes.length > 2) {\\n        //         const n = _classes.length-1;\\n        //         const i = getClass(value);\\n        //         const minc = _classes[0] + ((_classes[1]-_classes[0]) * (0 + (_spread * 0.5)));  // center of 1st class\\n        //         const maxc = _classes[n-1] + ((_classes[n]-_classes[n-1]) * (1 - (_spread * 0.5)));  // center of last class\\n        //         val = _min + ((((_classes[i] + ((_classes[i+1] - _classes[i]) * 0.5)) - minc) / (maxc-minc)) * (_max - _min));\\n        //     }\\n        //     return val;\\n        // };\\n\\n        var getColor = function(val, bypassMap) {\\n            var col, t;\\n            if (bypassMap == null) { bypassMap = false; }\\n            if (isNaN(val) || (val === null)) { return _nacol; }\\n            if (!bypassMap) {\\n                if (_classes && (_classes.length > 2)) {\\n                    // find the class\\n                    var c = getClass(val);\\n                    t = c / (_classes.length-2);\\n                } else if (_max !== _min) {\\n                    // just interpolate between min/max\\n                    t = (val - _min) / (_max - _min);\\n                } else {\\n                    t = 1;\\n                }\\n            } else {\\n                t = val;\\n            }\\n\\n            // domain map\\n            t = tMapDomain(t);\\n\\n            if (!bypassMap) {\\n                t = tMapLightness(t);  // lightness correction\\n            }\\n\\n            if (_gamma !== 1) { t = pow$5(t, _gamma); }\\n\\n            t = _padding[0] + (t * (1 - _padding[0] - _padding[1]));\\n\\n            t = Math.min(1, Math.max(0, t));\\n\\n            var k = Math.floor(t * 10000);\\n\\n            if (_useCache && _colorCache[k]) {\\n                col = _colorCache[k];\\n            } else {\\n                if (type$j(_colors) === 'array') {\\n                    //for i in [0.._pos.length-1]\\n                    for (var i=0; i<_pos.length; i++) {\\n                        var p = _pos[i];\\n                        if (t <= p) {\\n                            col = _colors[i];\\n                            break;\\n                        }\\n                        if ((t >= p) && (i === (_pos.length-1))) {\\n                            col = _colors[i];\\n                            break;\\n                        }\\n                        if (t > p && t < _pos[i+1]) {\\n                            t = (t-p)/(_pos[i+1]-p);\\n                            col = chroma_1.interpolate(_colors[i], _colors[i+1], t, _mode);\\n                            break;\\n                        }\\n                    }\\n                } else if (type$j(_colors) === 'function') {\\n                    col = _colors(t);\\n                }\\n                if (_useCache) { _colorCache[k] = col; }\\n            }\\n            return col;\\n        };\\n\\n        var resetCache = function () { return _colorCache = {}; };\\n\\n        setColors(colors);\\n\\n        // public interface\\n\\n        var f = function(v) {\\n            var c = chroma_1(getColor(v));\\n            if (_out && c[_out]) { return c[_out](); } else { return c; }\\n        };\\n\\n        f.classes = function(classes) {\\n            if (classes != null) {\\n                if (type$j(classes) === 'array') {\\n                    _classes = classes;\\n                    _domain = [classes[0], classes[classes.length-1]];\\n                } else {\\n                    var d = chroma_1.analyze(_domain);\\n                    if (classes === 0) {\\n                        _classes = [d.min, d.max];\\n                    } else {\\n                        _classes = chroma_1.limits(d, 'e', classes);\\n                    }\\n                }\\n                return f;\\n            }\\n            return _classes;\\n        };\\n\\n\\n        f.domain = function(domain) {\\n            if (!arguments.length) {\\n                return _domain;\\n            }\\n            _min = domain[0];\\n            _max = domain[domain.length-1];\\n            _pos = [];\\n            var k = _colors.length;\\n            if ((domain.length === k) && (_min !== _max)) {\\n                // update positions\\n                for (var i = 0, list = Array.from(domain); i < list.length; i += 1) {\\n                    var d = list[i];\\n\\n                  _pos.push((d-_min) / (_max-_min));\\n                }\\n            } else {\\n                for (var c=0; c<k; c++) {\\n                    _pos.push(c/(k-1));\\n                }\\n                if (domain.length > 2) {\\n                    // set domain map\\n                    var tOut = domain.map(function (d,i) { return i/(domain.length-1); });\\n                    var tBreaks = domain.map(function (d) { return (d - _min) / (_max - _min); });\\n                    if (!tBreaks.every(function (val, i) { return tOut[i] === val; })) {\\n                        tMapDomain = function (t) {\\n                            if (t <= 0 || t >= 1) { return t; }\\n                            var i = 0;\\n                            while (t >= tBreaks[i+1]) { i++; }\\n                            var f = (t - tBreaks[i]) / (tBreaks[i+1] - tBreaks[i]);\\n                            var out = tOut[i] + f * (tOut[i+1] - tOut[i]);\\n                            return out;\\n                        };\\n                    }\\n\\n                }\\n            }\\n            _domain = [_min, _max];\\n            return f;\\n        };\\n\\n        f.mode = function(_m) {\\n            if (!arguments.length) {\\n                return _mode;\\n            }\\n            _mode = _m;\\n            resetCache();\\n            return f;\\n        };\\n\\n        f.range = function(colors, _pos) {\\n            setColors(colors, _pos);\\n            return f;\\n        };\\n\\n        f.out = function(_o) {\\n            _out = _o;\\n            return f;\\n        };\\n\\n        f.spread = function(val) {\\n            if (!arguments.length) {\\n                return _spread;\\n            }\\n            _spread = val;\\n            return f;\\n        };\\n\\n        f.correctLightness = function(v) {\\n            if (v == null) { v = true; }\\n            _correctLightness = v;\\n            resetCache();\\n            if (_correctLightness) {\\n                tMapLightness = function(t) {\\n                    var L0 = getColor(0, true).lab()[0];\\n                    var L1 = getColor(1, true).lab()[0];\\n                    var pol = L0 > L1;\\n                    var L_actual = getColor(t, true).lab()[0];\\n                    var L_ideal = L0 + ((L1 - L0) * t);\\n                    var L_diff = L_actual - L_ideal;\\n                    var t0 = 0;\\n                    var t1 = 1;\\n                    var max_iter = 20;\\n                    while ((Math.abs(L_diff) > 1e-2) && (max_iter-- > 0)) {\\n                        (function() {\\n                            if (pol) { L_diff *= -1; }\\n                            if (L_diff < 0) {\\n                                t0 = t;\\n                                t += (t1 - t) * 0.5;\\n                            } else {\\n                                t1 = t;\\n                                t += (t0 - t) * 0.5;\\n                            }\\n                            L_actual = getColor(t, true).lab()[0];\\n                            return L_diff = L_actual - L_ideal;\\n                        })();\\n                    }\\n                    return t;\\n                };\\n            } else {\\n                tMapLightness = function (t) { return t; };\\n            }\\n            return f;\\n        };\\n\\n        f.padding = function(p) {\\n            if (p != null) {\\n                if (type$j(p) === 'number') {\\n                    p = [p,p];\\n                }\\n                _padding = p;\\n                return f;\\n            } else {\\n                return _padding;\\n            }\\n        };\\n\\n        f.colors = function(numColors, out) {\\n            // If no arguments are given, return the original colors that were provided\\n            if (arguments.length < 2) { out = 'hex'; }\\n            var result = [];\\n\\n            if (arguments.length === 0) {\\n                result = _colors.slice(0);\\n\\n            } else if (numColors === 1) {\\n                result = [f(0.5)];\\n\\n            } else if (numColors > 1) {\\n                var dm = _domain[0];\\n                var dd = _domain[1] - dm;\\n                result = __range__(0, numColors, false).map(function (i) { return f( dm + ((i/(numColors-1)) * dd) ); });\\n\\n            } else { // returns all colors based on the defined classes\\n                colors = [];\\n                var samples = [];\\n                if (_classes && (_classes.length > 2)) {\\n                    for (var i = 1, end = _classes.length, asc = 1 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\\n                        samples.push((_classes[i-1]+_classes[i])*0.5);\\n                    }\\n                } else {\\n                    samples = _domain;\\n                }\\n                result = samples.map(function (v) { return f(v); });\\n            }\\n\\n            if (chroma_1[out]) {\\n                result = result.map(function (c) { return c[out](); });\\n            }\\n            return result;\\n        };\\n\\n        f.cache = function(c) {\\n            if (c != null) {\\n                _useCache = c;\\n                return f;\\n            } else {\\n                return _useCache;\\n            }\\n        };\\n\\n        f.gamma = function(g) {\\n            if (g != null) {\\n                _gamma = g;\\n                return f;\\n            } else {\\n                return _gamma;\\n            }\\n        };\\n\\n        f.nodata = function(d) {\\n            if (d != null) {\\n                _nacol = chroma_1(d);\\n                return f;\\n            } else {\\n                return _nacol;\\n            }\\n        };\\n\\n        return f;\\n    };\\n\\n    function __range__(left, right, inclusive) {\\n      var range = [];\\n      var ascending = left < right;\\n      var end = !inclusive ? right : ascending ? right + 1 : right - 1;\\n      for (var i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {\\n        range.push(i);\\n      }\\n      return range;\\n    }\\n\\n    //\\n    // interpolates between a set of colors uzing a bezier spline\\n    //\\n\\n    // @requires utils lab\\n\\n\\n\\n\\n    var bezier = function(colors) {\\n        var assign, assign$1, assign$2;\\n\\n        var I, lab0, lab1, lab2;\\n        colors = colors.map(function (c) { return new Color_1(c); });\\n        if (colors.length === 2) {\\n            // linear interpolation\\n            (assign = colors.map(function (c) { return c.lab(); }), lab0 = assign[0], lab1 = assign[1]);\\n            I = function(t) {\\n                var lab = ([0, 1, 2].map(function (i) { return lab0[i] + (t * (lab1[i] - lab0[i])); }));\\n                return new Color_1(lab, 'lab');\\n            };\\n        } else if (colors.length === 3) {\\n            // quadratic bezier interpolation\\n            (assign$1 = colors.map(function (c) { return c.lab(); }), lab0 = assign$1[0], lab1 = assign$1[1], lab2 = assign$1[2]);\\n            I = function(t) {\\n                var lab = ([0, 1, 2].map(function (i) { return ((1-t)*(1-t) * lab0[i]) + (2 * (1-t) * t * lab1[i]) + (t * t * lab2[i]); }));\\n                return new Color_1(lab, 'lab');\\n            };\\n        } else if (colors.length === 4) {\\n            // cubic bezier interpolation\\n            var lab3;\\n            (assign$2 = colors.map(function (c) { return c.lab(); }), lab0 = assign$2[0], lab1 = assign$2[1], lab2 = assign$2[2], lab3 = assign$2[3]);\\n            I = function(t) {\\n                var lab = ([0, 1, 2].map(function (i) { return ((1-t)*(1-t)*(1-t) * lab0[i]) + (3 * (1-t) * (1-t) * t * lab1[i]) + (3 * (1-t) * t * t * lab2[i]) + (t*t*t * lab3[i]); }));\\n                return new Color_1(lab, 'lab');\\n            };\\n        } else if (colors.length === 5) {\\n            var I0 = bezier(colors.slice(0, 3));\\n            var I1 = bezier(colors.slice(2, 5));\\n            I = function(t) {\\n                if (t < 0.5) {\\n                    return I0(t*2);\\n                } else {\\n                    return I1((t-0.5)*2);\\n                }\\n            };\\n        }\\n        return I;\\n    };\\n\\n    var bezier_1 = function (colors) {\\n        var f = bezier(colors);\\n        f.scale = function () { return scale(f); };\\n        return f;\\n    };\\n\\n    /*\\n     * interpolates between a set of colors uzing a bezier spline\\n     * blend mode formulas taken from http://www.venture-ware.com/kevin/coding/lets-learn-math-photoshop-blend-modes/\\n     */\\n\\n\\n\\n\\n    var blend = function (bottom, top, mode) {\\n        if (!blend[mode]) {\\n            throw new Error('unknown blend mode ' + mode);\\n        }\\n        return blend[mode](bottom, top);\\n    };\\n\\n    var blend_f = function (f) { return function (bottom,top) {\\n            var c0 = chroma_1(top).rgb();\\n            var c1 = chroma_1(bottom).rgb();\\n            return chroma_1.rgb(f(c0, c1));\\n        }; };\\n\\n    var each = function (f) { return function (c0, c1) {\\n            var out = [];\\n            out[0] = f(c0[0], c1[0]);\\n            out[1] = f(c0[1], c1[1]);\\n            out[2] = f(c0[2], c1[2]);\\n            return out;\\n        }; };\\n\\n    var normal = function (a) { return a; };\\n    var multiply = function (a,b) { return a * b / 255; };\\n    var darken$1 = function (a,b) { return a > b ? b : a; };\\n    var lighten = function (a,b) { return a > b ? a : b; };\\n    var screen = function (a,b) { return 255 * (1 - (1-a/255) * (1-b/255)); };\\n    var overlay = function (a,b) { return b < 128 ? 2 * a * b / 255 : 255 * (1 - 2 * (1 - a / 255 ) * ( 1 - b / 255 )); };\\n    var burn = function (a,b) { return 255 * (1 - (1 - b / 255) / (a/255)); };\\n    var dodge = function (a,b) {\\n        if (a === 255) { return 255; }\\n        a = 255 * (b / 255) / (1 - a / 255);\\n        return a > 255 ? 255 : a\\n    };\\n\\n    // # add = (a,b) ->\\n    // #     if (a + b > 255) then 255 else a + b\\n\\n    blend.normal = blend_f(each(normal));\\n    blend.multiply = blend_f(each(multiply));\\n    blend.screen = blend_f(each(screen));\\n    blend.overlay = blend_f(each(overlay));\\n    blend.darken = blend_f(each(darken$1));\\n    blend.lighten = blend_f(each(lighten));\\n    blend.dodge = blend_f(each(dodge));\\n    blend.burn = blend_f(each(burn));\\n    // blend.add = blend_f(each(add));\\n\\n    var blend_1 = blend;\\n\\n    // cubehelix interpolation\\n    // based on D.A. Green \\\"A colour scheme for the display of astronomical intensity images\\\"\\n    // http://astron-soc.in/bulletin/11June/289392011.pdf\\n\\n    var type$k = utils.type;\\n    var clip_rgb$3 = utils.clip_rgb;\\n    var TWOPI$2 = utils.TWOPI;\\n    var pow$6 = Math.pow;\\n    var sin$2 = Math.sin;\\n    var cos$3 = Math.cos;\\n\\n\\n    var cubehelix = function(start, rotations, hue, gamma, lightness) {\\n        if ( start === void 0 ) start=300;\\n        if ( rotations === void 0 ) rotations=-1.5;\\n        if ( hue === void 0 ) hue=1;\\n        if ( gamma === void 0 ) gamma=1;\\n        if ( lightness === void 0 ) lightness=[0,1];\\n\\n        var dh = 0, dl;\\n        if (type$k(lightness) === 'array') {\\n            dl = lightness[1] - lightness[0];\\n        } else {\\n            dl = 0;\\n            lightness = [lightness, lightness];\\n        }\\n\\n        var f = function(fract) {\\n            var a = TWOPI$2 * (((start+120)/360) + (rotations * fract));\\n            var l = pow$6(lightness[0] + (dl * fract), gamma);\\n            var h = dh !== 0 ? hue[0] + (fract * dh) : hue;\\n            var amp = (h * l * (1-l)) / 2;\\n            var cos_a = cos$3(a);\\n            var sin_a = sin$2(a);\\n            var r = l + (amp * ((-0.14861 * cos_a) + (1.78277* sin_a)));\\n            var g = l + (amp * ((-0.29227 * cos_a) - (0.90649* sin_a)));\\n            var b = l + (amp * (+1.97294 * cos_a));\\n            return chroma_1(clip_rgb$3([r*255,g*255,b*255,1]));\\n        };\\n\\n        f.start = function(s) {\\n            if ((s == null)) { return start; }\\n            start = s;\\n            return f;\\n        };\\n\\n        f.rotations = function(r) {\\n            if ((r == null)) { return rotations; }\\n            rotations = r;\\n            return f;\\n        };\\n\\n        f.gamma = function(g) {\\n            if ((g == null)) { return gamma; }\\n            gamma = g;\\n            return f;\\n        };\\n\\n        f.hue = function(h) {\\n            if ((h == null)) { return hue; }\\n            hue = h;\\n            if (type$k(hue) === 'array') {\\n                dh = hue[1] - hue[0];\\n                if (dh === 0) { hue = hue[1]; }\\n            } else {\\n                dh = 0;\\n            }\\n            return f;\\n        };\\n\\n        f.lightness = function(h) {\\n            if ((h == null)) { return lightness; }\\n            if (type$k(h) === 'array') {\\n                lightness = h;\\n                dl = h[1] - h[0];\\n            } else {\\n                lightness = [h,h];\\n                dl = 0;\\n            }\\n            return f;\\n        };\\n\\n        f.scale = function () { return chroma_1.scale(f); };\\n\\n        f.hue(hue);\\n\\n        return f;\\n    };\\n\\n    var digits = '0123456789abcdef';\\n\\n    var floor$2 = Math.floor;\\n    var random = Math.random;\\n\\n    var random_1 = function () {\\n        var code = '#';\\n        for (var i=0; i<6; i++) {\\n            code += digits.charAt(floor$2(random() * 16));\\n        }\\n        return new Color_1(code, 'hex');\\n    };\\n\\n    var log$1 = Math.log;\\n    var pow$7 = Math.pow;\\n    var floor$3 = Math.floor;\\n    var abs = Math.abs;\\n\\n\\n    var analyze = function (data, key) {\\n        if ( key === void 0 ) key=null;\\n\\n        var r = {\\n            min: Number.MAX_VALUE,\\n            max: Number.MAX_VALUE*-1,\\n            sum: 0,\\n            values: [],\\n            count: 0\\n        };\\n        if (type(data) === 'object') {\\n            data = Object.values(data);\\n        }\\n        data.forEach(function (val) {\\n            if (key && type(val) === 'object') { val = val[key]; }\\n            if (val !== undefined && val !== null && !isNaN(val)) {\\n                r.values.push(val);\\n                r.sum += val;\\n                if (val < r.min) { r.min = val; }\\n                if (val > r.max) { r.max = val; }\\n                r.count += 1;\\n            }\\n        });\\n\\n        r.domain = [r.min, r.max];\\n\\n        r.limits = function (mode, num) { return limits(r, mode, num); };\\n\\n        return r;\\n    };\\n\\n\\n    var limits = function (data, mode, num) {\\n        if ( mode === void 0 ) mode='equal';\\n        if ( num === void 0 ) num=7;\\n\\n        if (type(data) == 'array') {\\n            data = analyze(data);\\n        }\\n        var min = data.min;\\n        var max = data.max;\\n        var values = data.values.sort(function (a,b) { return a-b; });\\n\\n        if (num === 1) { return [min,max]; }\\n\\n        var limits = [];\\n\\n        if (mode.substr(0,1) === 'c') { // continuous\\n            limits.push(min);\\n            limits.push(max);\\n        }\\n\\n        if (mode.substr(0,1) === 'e') { // equal interval\\n            limits.push(min);\\n            for (var i=1; i<num; i++) {\\n                limits.push(min+((i/num)*(max-min)));\\n            }\\n            limits.push(max);\\n        }\\n\\n        else if (mode.substr(0,1) === 'l') { // log scale\\n            if (min <= 0) {\\n                throw new Error('Logarithmic scales are only possible for values > 0');\\n            }\\n            var min_log = Math.LOG10E * log$1(min);\\n            var max_log = Math.LOG10E * log$1(max);\\n            limits.push(min);\\n            for (var i$1=1; i$1<num; i$1++) {\\n                limits.push(pow$7(10, min_log + ((i$1/num) * (max_log - min_log))));\\n            }\\n            limits.push(max);\\n        }\\n\\n        else if (mode.substr(0,1) === 'q') { // quantile scale\\n            limits.push(min);\\n            for (var i$2=1; i$2<num; i$2++) {\\n                var p = ((values.length-1) * i$2)/num;\\n                var pb = floor$3(p);\\n                if (pb === p) {\\n                    limits.push(values[pb]);\\n                } else { // p > pb\\n                    var pr = p - pb;\\n                    limits.push((values[pb]*(1-pr)) + (values[pb+1]*pr));\\n                }\\n            }\\n            limits.push(max);\\n\\n        }\\n\\n        else if (mode.substr(0,1) === 'k') { // k-means clustering\\n            /*\\n            implementation based on\\n            http://code.google.com/p/figue/source/browse/trunk/figue.js#336\\n            simplified for 1-d input values\\n            */\\n            var cluster;\\n            var n = values.length;\\n            var assignments = new Array(n);\\n            var clusterSizes = new Array(num);\\n            var repeat = true;\\n            var nb_iters = 0;\\n            var centroids = null;\\n\\n            // get seed values\\n            centroids = [];\\n            centroids.push(min);\\n            for (var i$3=1; i$3<num; i$3++) {\\n                centroids.push(min + ((i$3/num) * (max-min)));\\n            }\\n            centroids.push(max);\\n\\n            while (repeat) {\\n                // assignment step\\n                for (var j=0; j<num; j++) {\\n                    clusterSizes[j] = 0;\\n                }\\n                for (var i$4=0; i$4<n; i$4++) {\\n                    var value = values[i$4];\\n                    var mindist = Number.MAX_VALUE;\\n                    var best = (void 0);\\n                    for (var j$1=0; j$1<num; j$1++) {\\n                        var dist = abs(centroids[j$1]-value);\\n                        if (dist < mindist) {\\n                            mindist = dist;\\n                            best = j$1;\\n                        }\\n                        clusterSizes[best]++;\\n                        assignments[i$4] = best;\\n                    }\\n                }\\n\\n                // update centroids step\\n                var newCentroids = new Array(num);\\n                for (var j$2=0; j$2<num; j$2++) {\\n                    newCentroids[j$2] = null;\\n                }\\n                for (var i$5=0; i$5<n; i$5++) {\\n                    cluster = assignments[i$5];\\n                    if (newCentroids[cluster] === null) {\\n                        newCentroids[cluster] = values[i$5];\\n                    } else {\\n                        newCentroids[cluster] += values[i$5];\\n                    }\\n                }\\n                for (var j$3=0; j$3<num; j$3++) {\\n                    newCentroids[j$3] *= 1/clusterSizes[j$3];\\n                }\\n\\n                // check convergence\\n                repeat = false;\\n                for (var j$4=0; j$4<num; j$4++) {\\n                    if (newCentroids[j$4] !== centroids[j$4]) {\\n                        repeat = true;\\n                        break;\\n                    }\\n                }\\n\\n                centroids = newCentroids;\\n                nb_iters++;\\n\\n                if (nb_iters > 200) {\\n                    repeat = false;\\n                }\\n            }\\n\\n            // finished k-means clustering\\n            // the next part is borrowed from gabrielflor.it\\n            var kClusters = {};\\n            for (var j$5=0; j$5<num; j$5++) {\\n                kClusters[j$5] = [];\\n            }\\n            for (var i$6=0; i$6<n; i$6++) {\\n                cluster = assignments[i$6];\\n                kClusters[cluster].push(values[i$6]);\\n            }\\n            var tmpKMeansBreaks = [];\\n            for (var j$6=0; j$6<num; j$6++) {\\n                tmpKMeansBreaks.push(kClusters[j$6][0]);\\n                tmpKMeansBreaks.push(kClusters[j$6][kClusters[j$6].length-1]);\\n            }\\n            tmpKMeansBreaks = tmpKMeansBreaks.sort(function (a,b){ return a-b; });\\n            limits.push(tmpKMeansBreaks[0]);\\n            for (var i$7=1; i$7 < tmpKMeansBreaks.length; i$7+= 2) {\\n                var v = tmpKMeansBreaks[i$7];\\n                if (!isNaN(v) && (limits.indexOf(v) === -1)) {\\n                    limits.push(v);\\n                }\\n            }\\n        }\\n        return limits;\\n    };\\n\\n    var analyze_1 = {analyze: analyze, limits: limits};\\n\\n    var contrast = function (a, b) {\\n        // WCAG contrast ratio\\n        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef\\n        a = new Color_1(a);\\n        b = new Color_1(b);\\n        var l1 = a.luminance();\\n        var l2 = b.luminance();\\n        return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);\\n    };\\n\\n    var sqrt$4 = Math.sqrt;\\n    var atan2$2 = Math.atan2;\\n    var abs$1 = Math.abs;\\n    var cos$4 = Math.cos;\\n    var PI$2 = Math.PI;\\n\\n    var deltaE = function(a, b, L, C) {\\n        if ( L === void 0 ) L=1;\\n        if ( C === void 0 ) C=1;\\n\\n        // Delta E (CMC)\\n        // see http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CMC.html\\n        a = new Color_1(a);\\n        b = new Color_1(b);\\n        var ref = Array.from(a.lab());\\n        var L1 = ref[0];\\n        var a1 = ref[1];\\n        var b1 = ref[2];\\n        var ref$1 = Array.from(b.lab());\\n        var L2 = ref$1[0];\\n        var a2 = ref$1[1];\\n        var b2 = ref$1[2];\\n        var c1 = sqrt$4((a1 * a1) + (b1 * b1));\\n        var c2 = sqrt$4((a2 * a2) + (b2 * b2));\\n        var sl = L1 < 16.0 ? 0.511 : (0.040975 * L1) / (1.0 + (0.01765 * L1));\\n        var sc = ((0.0638 * c1) / (1.0 + (0.0131 * c1))) + 0.638;\\n        var h1 = c1 < 0.000001 ? 0.0 : (atan2$2(b1, a1) * 180.0) / PI$2;\\n        while (h1 < 0) { h1 += 360; }\\n        while (h1 >= 360) { h1 -= 360; }\\n        var t = (h1 >= 164.0) && (h1 <= 345.0) ? (0.56 + abs$1(0.2 * cos$4((PI$2 * (h1 + 168.0)) / 180.0))) : (0.36 + abs$1(0.4 * cos$4((PI$2 * (h1 + 35.0)) / 180.0)));\\n        var c4 = c1 * c1 * c1 * c1;\\n        var f = sqrt$4(c4 / (c4 + 1900.0));\\n        var sh = sc * (((f * t) + 1.0) - f);\\n        var delL = L1 - L2;\\n        var delC = c1 - c2;\\n        var delA = a1 - a2;\\n        var delB = b1 - b2;\\n        var dH2 = ((delA * delA) + (delB * delB)) - (delC * delC);\\n        var v1 = delL / (L * sl);\\n        var v2 = delC / (C * sc);\\n        var v3 = sh;\\n        return sqrt$4((v1 * v1) + (v2 * v2) + (dH2 / (v3 * v3)));\\n    };\\n\\n    // simple Euclidean distance\\n    var distance = function(a, b, mode) {\\n        if ( mode === void 0 ) mode='lab';\\n\\n        // Delta E (CIE 1976)\\n        // see http://www.brucelindbloom.com/index.html?Equations.html\\n        a = new Color_1(a);\\n        b = new Color_1(b);\\n        var l1 = a.get(mode);\\n        var l2 = b.get(mode);\\n        var sum_sq = 0;\\n        for (var i in l1) {\\n            var d = (l1[i] || 0) - (l2[i] || 0);\\n            sum_sq += d*d;\\n        }\\n        return Math.sqrt(sum_sq);\\n    };\\n\\n    var valid = function () {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n        try {\\n            new (Function.prototype.bind.apply( Color_1, [ null ].concat( args) ));\\n            return true;\\n        } catch (e) {\\n            return false;\\n        }\\n    };\\n\\n    // some pre-defined color scales:\\n\\n\\n\\n\\n    var scales = {\\n    \\tcool: function cool() { return scale([chroma_1.hsl(180,1,.9), chroma_1.hsl(250,.7,.4)]) },\\n    \\thot: function hot() { return scale(['#000','#f00','#ff0','#fff'], [0,.25,.75,1]).mode('rgb') }\\n    };\\n\\n    /**\\n        ColorBrewer colors for chroma.js\\n\\n        Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The\\n        Pennsylvania State University.\\n\\n        Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n        you may not use this file except in compliance with the License.\\n        You may obtain a copy of the License at\\n        http://www.apache.org/licenses/LICENSE-2.0\\n\\n        Unless required by applicable law or agreed to in writing, software distributed\\n        under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n        CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n        specific language governing permissions and limitations under the License.\\n    */\\n\\n    var colorbrewer = {\\n        // sequential\\n        OrRd: ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000'],\\n        PuBu: ['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858'],\\n        BuPu: ['#f7fcfd', '#e0ecf4', '#bfd3e6', '#9ebcda', '#8c96c6', '#8c6bb1', '#88419d', '#810f7c', '#4d004b'],\\n        Oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],\\n        BuGn: ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b'],\\n        YlOrBr: ['#ffffe5', '#fff7bc', '#fee391', '#fec44f', '#fe9929', '#ec7014', '#cc4c02', '#993404', '#662506'],\\n        YlGn: ['#ffffe5', '#f7fcb9', '#d9f0a3', '#addd8e', '#78c679', '#41ab5d', '#238443', '#006837', '#004529'],\\n        Reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],\\n        RdPu: ['#fff7f3', '#fde0dd', '#fcc5c0', '#fa9fb5', '#f768a1', '#dd3497', '#ae017e', '#7a0177', '#49006a'],\\n        Greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],\\n        YlGnBu: ['#ffffd9', '#edf8b1', '#c7e9b4', '#7fcdbb', '#41b6c4', '#1d91c0', '#225ea8', '#253494', '#081d58'],\\n        Purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],\\n        GnBu: ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'],\\n        Greys: ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525', '#000000'],\\n        YlOrRd: ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026'],\\n        PuRd: ['#f7f4f9', '#e7e1ef', '#d4b9da', '#c994c7', '#df65b0', '#e7298a', '#ce1256', '#980043', '#67001f'],\\n        Blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],\\n        PuBuGn: ['#fff7fb', '#ece2f0', '#d0d1e6', '#a6bddb', '#67a9cf', '#3690c0', '#02818a', '#016c59', '#014636'],\\n        Viridis: ['#440154', '#482777', '#3f4a8a', '#31678e', '#26838f', '#1f9d8a', '#6cce5a', '#b6de2b', '#fee825'],\\n\\n        // diverging\\n\\n        Spectral: ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],\\n        RdYlGn: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],\\n        RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],\\n        PiYG: ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],\\n        PRGn: ['#40004b', '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],\\n        RdYlBu: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],\\n        BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],\\n        RdGy: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#ffffff', '#e0e0e0', '#bababa', '#878787', '#4d4d4d', '#1a1a1a'],\\n        PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],\\n\\n        // qualitative\\n\\n        Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],\\n        Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],\\n        Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],\\n        Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],\\n        Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],\\n        Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'],\\n        Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],\\n        Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2'],\\n    };\\n\\n    // add lowercase aliases for case-insensitive matches\\n    for (var i$1 = 0, list$1 = Object.keys(colorbrewer); i$1 < list$1.length; i$1 += 1) {\\n        var key = list$1[i$1];\\n\\n        colorbrewer[key.toLowerCase()] = colorbrewer[key];\\n    }\\n\\n    var colorbrewer_1 = colorbrewer;\\n\\n    // feel free to comment out anything to rollup\\n    // a smaller chroma.js built\\n\\n    // io --\\x3e convert colors\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    // operators --\\x3e modify existing Colors\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    // interpolators\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    // generators -- > create new colors\\n    chroma_1.average = average;\\n    chroma_1.bezier = bezier_1;\\n    chroma_1.blend = blend_1;\\n    chroma_1.cubehelix = cubehelix;\\n    chroma_1.mix = chroma_1.interpolate = mix;\\n    chroma_1.random = random_1;\\n    chroma_1.scale = scale;\\n\\n    // other utility methods\\n    chroma_1.analyze = analyze_1.analyze;\\n    chroma_1.contrast = contrast;\\n    chroma_1.deltaE = deltaE;\\n    chroma_1.distance = distance;\\n    chroma_1.limits = analyze_1.limits;\\n    chroma_1.valid = valid;\\n\\n    // scale\\n    chroma_1.scales = scales;\\n\\n    // colors\\n    chroma_1.colors = w3cx11_1;\\n    chroma_1.brewer = colorbrewer_1;\\n\\n    var chroma_js = chroma_1;\\n\\n    return chroma_js;\\n\\n})));\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0NBQWtDLEVBQUUsYUFBYSxFQUFFO0FBQ25ELG1DQUFtQyxFQUFFLGFBQWEsRUFBRTs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEI7QUFDQSx1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDZCQUE2QjtBQUM3QiwyQkFBMkI7QUFDM0IseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyRkFBMkY7QUFDM0YsbUdBQW1HO0FBQ25HLG1HQUFtRztBQUNuRyxtR0FBbUc7QUFDbkcsbUdBQW1HO0FBQ25HLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUVBQXFFO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7Ozs7QUFPQSx5Q0FBeUM7QUFDekMseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0Esc0RBQXNELGlCQUFpQjtBQUN2RTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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cUJBQXFCO0FBQzlFOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTs7Ozs7Ozs7Ozs7QUFXQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdmctdG8tZXhjYWxpZHJhdy8uL25vZGVfbW9kdWxlcy9jaHJvbWEtanMvY2hyb21hLmpzPzYxNDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBjaHJvbWEuanMgLSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGNvbG9yIGNvbnZlcnNpb25zXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTksIEdyZWdvciBBaXNjaFxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICogbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICogYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogMy4gVGhlIG5hbWUgR3JlZ29yIEFpc2NoIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcbiAqIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbiAqIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEdSRUdPUiBBSVNDSCBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULFxuICogSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsXG4gKiBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuICogREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWVxuICogT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSxcbiAqIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIGNocm9tYS5qcyBpbmNsdWRlcyBjb2xvcnMgZnJvbSBjb2xvcmJyZXdlcjIub3JnLCB3aGljaCBhcmUgcmVsZWFzZWQgdW5kZXJcbiAqIHRoZSBmb2xsb3dpbmcgbGljZW5zZTpcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDIgQ3ludGhpYSBCcmV3ZXIsIE1hcmsgSGFycm93ZXIsXG4gKiBhbmQgVGhlIFBlbm5zeWx2YW5pYSBTdGF0ZSBVbml2ZXJzaXR5LlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELFxuICogZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWNcbiAqIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogTmFtZWQgY29sb3JzIGFyZSB0YWtlbiBmcm9tIFgxMSBDb2xvciBOYW1lcy5cbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvI3N2Zy1jb2xvclxuICpcbiAqIEBwcmVzZXJ2ZVxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgKGdsb2JhbC5jaHJvbWEgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgbGltaXQgPSBmdW5jdGlvbiAoeCwgbWluLCBtYXgpIHtcbiAgICAgICAgaWYgKCBtaW4gPT09IHZvaWQgMCApIG1pbj0wO1xuICAgICAgICBpZiAoIG1heCA9PT0gdm9pZCAwICkgbWF4PTE7XG5cbiAgICAgICAgcmV0dXJuIHggPCBtaW4gPyBtaW4gOiB4ID4gbWF4ID8gbWF4IDogeDtcbiAgICB9O1xuXG4gICAgdmFyIGNsaXBfcmdiID0gZnVuY3Rpb24gKHJnYikge1xuICAgICAgICByZ2IuX2NsaXBwZWQgPSBmYWxzZTtcbiAgICAgICAgcmdiLl91bmNsaXBwZWQgPSByZ2Iuc2xpY2UoMCk7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTw9MzsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA8IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmdiW2ldIDwgMCB8fCByZ2JbaV0gPiAyNTUpIHsgcmdiLl9jbGlwcGVkID0gdHJ1ZTsgfVxuICAgICAgICAgICAgICAgIHJnYltpXSA9IGxpbWl0KHJnYltpXSwgMCwgMjU1KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJnYltpXSA9IGxpbWl0KHJnYltpXSwgMCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJnYjtcbiAgICB9O1xuXG4gICAgLy8gcG9ydGVkIGZyb20galF1ZXJ5J3MgJC50eXBlXG4gICAgdmFyIGNsYXNzVG9UeXBlID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBbJ0Jvb2xlYW4nLCAnTnVtYmVyJywgJ1N0cmluZycsICdGdW5jdGlvbicsICdBcnJheScsICdEYXRlJywgJ1JlZ0V4cCcsICdVbmRlZmluZWQnLCAnTnVsbCddOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbmFtZSA9IGxpc3RbaV07XG5cbiAgICAgICAgY2xhc3NUb1R5cGVbKFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIildID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICB2YXIgdHlwZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gY2xhc3NUb1R5cGVbT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaildIHx8IFwib2JqZWN0XCI7XG4gICAgfTtcblxuICAgIHZhciB1bnBhY2sgPSBmdW5jdGlvbiAoYXJncywga2V5T3JkZXIpIHtcbiAgICAgICAgaWYgKCBrZXlPcmRlciA9PT0gdm9pZCAwICkga2V5T3JkZXI9bnVsbDtcblxuICAgIFx0Ly8gaWYgY2FsbGVkIHdpdGggbW9yZSB0aGFuIDMgYXJndW1lbnRzLCB3ZSByZXR1cm4gdGhlIGFyZ3VtZW50c1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPj0gMykgeyByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7IH1cbiAgICAgICAgLy8gd2l0aCBsZXNzIHRoYW4gMyBhcmdzIHdlIGNoZWNrIGlmIGZpcnN0IGFyZyBpcyBvYmplY3RcbiAgICAgICAgLy8gYW5kIHVzZSB0aGUga2V5T3JkZXIgc3RyaW5nIHRvIGV4dHJhY3QgYW5kIHNvcnQgcHJvcGVydGllc1xuICAgIFx0aWYgKHR5cGUoYXJnc1swXSkgPT0gJ29iamVjdCcgJiYga2V5T3JkZXIpIHtcbiAgICBcdFx0cmV0dXJuIGtleU9yZGVyLnNwbGl0KCcnKVxuICAgIFx0XHRcdC5maWx0ZXIoZnVuY3Rpb24gKGspIHsgcmV0dXJuIGFyZ3NbMF1ba10gIT09IHVuZGVmaW5lZDsgfSlcbiAgICBcdFx0XHQubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBhcmdzWzBdW2tdOyB9KTtcbiAgICBcdH1cbiAgICBcdC8vIG90aGVyd2lzZSB3ZSBqdXN0IHJldHVybiB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICBcdC8vICh3aGljaCB3ZSBzdXBwb3NlIGlzIGFuIGFycmF5IG9mIGFyZ3MpXG4gICAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgIH07XG5cbiAgICB2YXIgbGFzdCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgdmFyIGwgPSBhcmdzLmxlbmd0aC0xO1xuICAgICAgICBpZiAodHlwZShhcmdzW2xdKSA9PSAnc3RyaW5nJykgeyByZXR1cm4gYXJnc1tsXS50b0xvd2VyQ2FzZSgpOyB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgUEkgPSBNYXRoLlBJO1xuXG4gICAgdmFyIHV0aWxzID0ge1xuICAgIFx0Y2xpcF9yZ2I6IGNsaXBfcmdiLFxuICAgIFx0bGltaXQ6IGxpbWl0LFxuICAgIFx0dHlwZTogdHlwZSxcbiAgICBcdHVucGFjazogdW5wYWNrLFxuICAgIFx0bGFzdDogbGFzdCxcbiAgICBcdFBJOiBQSSxcbiAgICBcdFRXT1BJOiBQSSoyLFxuICAgIFx0UElUSElSRDogUEkvMyxcbiAgICBcdERFRzJSQUQ6IFBJIC8gMTgwLFxuICAgIFx0UkFEMkRFRzogMTgwIC8gUElcbiAgICB9O1xuXG4gICAgdmFyIGlucHV0ID0ge1xuICAgIFx0Zm9ybWF0OiB7fSxcbiAgICBcdGF1dG9kZXRlY3Q6IFtdXG4gICAgfTtcblxuICAgIHZhciBsYXN0JDEgPSB1dGlscy5sYXN0O1xuICAgIHZhciBjbGlwX3JnYiQxID0gdXRpbHMuY2xpcF9yZ2I7XG4gICAgdmFyIHR5cGUkMSA9IHV0aWxzLnR5cGU7XG5cblxuICAgIHZhciBDb2xvciA9IGZ1bmN0aW9uIENvbG9yKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlJDEoYXJnc1swXSkgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBhcmdzWzBdLmNvbnN0cnVjdG9yICYmXG4gICAgICAgICAgICBhcmdzWzBdLmNvbnN0cnVjdG9yID09PSB0aGlzLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAvLyB0aGUgYXJndW1lbnQgaXMgYWxyZWFkeSBhIENvbG9yIGluc3RhbmNlXG4gICAgICAgICAgICByZXR1cm4gYXJnc1swXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxhc3QgYXJndW1lbnQgY291bGQgYmUgdGhlIG1vZGVcbiAgICAgICAgdmFyIG1vZGUgPSBsYXN0JDEoYXJncyk7XG4gICAgICAgIHZhciBhdXRvZGV0ZWN0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFtb2RlKSB7XG4gICAgICAgICAgICBhdXRvZGV0ZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghaW5wdXQuc29ydGVkKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuYXV0b2RldGVjdCA9IGlucHV0LmF1dG9kZXRlY3Quc29ydChmdW5jdGlvbiAoYSxiKSB7IHJldHVybiBiLnAgLSBhLnA7IH0pO1xuICAgICAgICAgICAgICAgIGlucHV0LnNvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhdXRvLWRldGVjdCBmb3JtYXRcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gaW5wdXQuYXV0b2RldGVjdDsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hrID0gbGlzdFtpXTtcblxuICAgICAgICAgICAgICAgIG1vZGUgPSBjaGsudGVzdC5hcHBseShjaGssIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmIChtb2RlKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5wdXQuZm9ybWF0W21vZGVdKSB7XG4gICAgICAgICAgICB2YXIgcmdiID0gaW5wdXQuZm9ybWF0W21vZGVdLmFwcGx5KG51bGwsIGF1dG9kZXRlY3QgPyBhcmdzIDogYXJncy5zbGljZSgwLC0xKSk7XG4gICAgICAgICAgICBtZS5fcmdiID0gY2xpcF9yZ2IkMShyZ2IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGZvcm1hdDogJythcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBhbHBoYSBjaGFubmVsXG4gICAgICAgIGlmIChtZS5fcmdiLmxlbmd0aCA9PT0gMykgeyBtZS5fcmdiLnB1c2goMSk7IH1cbiAgICB9O1xuXG4gICAgQ29sb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgICAgICBpZiAodHlwZSQxKHRoaXMuaGV4KSA9PSAnZnVuY3Rpb24nKSB7IHJldHVybiB0aGlzLmhleCgpOyB9XG4gICAgICAgIHJldHVybiAoXCJbXCIgKyAodGhpcy5fcmdiLmpvaW4oJywnKSkgKyBcIl1cIik7XG4gICAgfTtcblxuICAgIHZhciBDb2xvcl8xID0gQ29sb3I7XG5cbiAgICB2YXIgY2hyb21hID0gZnVuY3Rpb24gKCkge1xuICAgIFx0dmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBcdHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICBcdHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBjaHJvbWEuQ29sb3IsIFsgbnVsbCBdLmNvbmNhdCggYXJncykgKSk7XG4gICAgfTtcblxuICAgIGNocm9tYS5Db2xvciA9IENvbG9yXzE7XG4gICAgY2hyb21hLnZlcnNpb24gPSAnMi4xLjInO1xuXG4gICAgdmFyIGNocm9tYV8xID0gY2hyb21hO1xuXG4gICAgdmFyIHVucGFjayQxID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBtYXggPSBNYXRoLm1heDtcblxuICAgIHZhciByZ2IyY215ayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgcmVmID0gdW5wYWNrJDEoYXJncywgJ3JnYicpO1xuICAgICAgICB2YXIgciA9IHJlZlswXTtcbiAgICAgICAgdmFyIGcgPSByZWZbMV07XG4gICAgICAgIHZhciBiID0gcmVmWzJdO1xuICAgICAgICByID0gciAvIDI1NTtcbiAgICAgICAgZyA9IGcgLyAyNTU7XG4gICAgICAgIGIgPSBiIC8gMjU1O1xuICAgICAgICB2YXIgayA9IDEgLSBtYXgocixtYXgoZyxiKSk7XG4gICAgICAgIHZhciBmID0gayA8IDEgPyAxIC8gKDEtaykgOiAwO1xuICAgICAgICB2YXIgYyA9ICgxLXItaykgKiBmO1xuICAgICAgICB2YXIgbSA9ICgxLWctaykgKiBmO1xuICAgICAgICB2YXIgeSA9ICgxLWItaykgKiBmO1xuICAgICAgICByZXR1cm4gW2MsbSx5LGtdO1xuICAgIH07XG5cbiAgICB2YXIgcmdiMmNteWtfMSA9IHJnYjJjbXlrO1xuXG4gICAgdmFyIHVucGFjayQyID0gdXRpbHMudW5wYWNrO1xuXG4gICAgdmFyIGNteWsycmdiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIGFyZ3MgPSB1bnBhY2skMihhcmdzLCAnY215aycpO1xuICAgICAgICB2YXIgYyA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBtID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIHkgPSBhcmdzWzJdO1xuICAgICAgICB2YXIgayA9IGFyZ3NbM107XG4gICAgICAgIHZhciBhbHBoYSA9IGFyZ3MubGVuZ3RoID4gNCA/IGFyZ3NbNF0gOiAxO1xuICAgICAgICBpZiAoayA9PT0gMSkgeyByZXR1cm4gWzAsMCwwLGFscGhhXTsgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgYyA+PSAxID8gMCA6IDI1NSAqICgxLWMpICogKDEtayksIC8vIHJcbiAgICAgICAgICAgIG0gPj0gMSA/IDAgOiAyNTUgKiAoMS1tKSAqICgxLWspLCAvLyBnXG4gICAgICAgICAgICB5ID49IDEgPyAwIDogMjU1ICogKDEteSkgKiAoMS1rKSwgLy8gYlxuICAgICAgICAgICAgYWxwaGFcbiAgICAgICAgXTtcbiAgICB9O1xuXG4gICAgdmFyIGNteWsycmdiXzEgPSBjbXlrMnJnYjtcblxuICAgIHZhciB1bnBhY2skMyA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgdHlwZSQyID0gdXRpbHMudHlwZTtcblxuXG5cbiAgICBDb2xvcl8xLnByb3RvdHlwZS5jbXlrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZ2IyY215a18xKHRoaXMuX3JnYik7XG4gICAgfTtcblxuICAgIGNocm9tYV8xLmNteWsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yXzEsIFsgbnVsbCBdLmNvbmNhdCggYXJncywgWydjbXlrJ10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dC5mb3JtYXQuY215ayA9IGNteWsycmdiXzE7XG5cbiAgICBpbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICBwOiAyLFxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICAgICAgYXJncyA9IHVucGFjayQzKGFyZ3MsICdjbXlrJyk7XG4gICAgICAgICAgICBpZiAodHlwZSQyKGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdjbXlrJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHVucGFjayQ0ID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBsYXN0JDIgPSB1dGlscy5sYXN0O1xuICAgIHZhciBybmQgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gTWF0aC5yb3VuZChhKjEwMCkvMTAwOyB9O1xuXG4gICAgLypcbiAgICAgKiBzdXBwb3J0ZWQgYXJndW1lbnRzOlxuICAgICAqIC0gaHNsMmNzcyhoLHMsbClcbiAgICAgKiAtIGhzbDJjc3MoaCxzLGwsYSlcbiAgICAgKiAtIGhzbDJjc3MoW2gscyxsXSwgbW9kZSlcbiAgICAgKiAtIGhzbDJjc3MoW2gscyxsLGFdLCBtb2RlKVxuICAgICAqIC0gaHNsMmNzcyh7aCxzLGwsYX0sIG1vZGUpXG4gICAgICovXG4gICAgdmFyIGhzbDJjc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIGhzbGEgPSB1bnBhY2skNChhcmdzLCAnaHNsYScpO1xuICAgICAgICB2YXIgbW9kZSA9IGxhc3QkMihhcmdzKSB8fCAnbHNhJztcbiAgICAgICAgaHNsYVswXSA9IHJuZChoc2xhWzBdIHx8IDApO1xuICAgICAgICBoc2xhWzFdID0gcm5kKGhzbGFbMV0qMTAwKSArICclJztcbiAgICAgICAgaHNsYVsyXSA9IHJuZChoc2xhWzJdKjEwMCkgKyAnJSc7XG4gICAgICAgIGlmIChtb2RlID09PSAnaHNsYScgfHwgKGhzbGEubGVuZ3RoID4gMyAmJiBoc2xhWzNdPDEpKSB7XG4gICAgICAgICAgICBoc2xhWzNdID0gaHNsYS5sZW5ndGggPiAzID8gaHNsYVszXSA6IDE7XG4gICAgICAgICAgICBtb2RlID0gJ2hzbGEnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHNsYS5sZW5ndGggPSAzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobW9kZSArIFwiKFwiICsgKGhzbGEuam9pbignLCcpKSArIFwiKVwiKTtcbiAgICB9O1xuXG4gICAgdmFyIGhzbDJjc3NfMSA9IGhzbDJjc3M7XG5cbiAgICB2YXIgdW5wYWNrJDUgPSB1dGlscy51bnBhY2s7XG5cbiAgICAvKlxuICAgICAqIHN1cHBvcnRlZCBhcmd1bWVudHM6XG4gICAgICogLSByZ2IyaHNsKHIsZyxiKVxuICAgICAqIC0gcmdiMmhzbChyLGcsYixhKVxuICAgICAqIC0gcmdiMmhzbChbcixnLGJdKVxuICAgICAqIC0gcmdiMmhzbChbcixnLGIsYV0pXG4gICAgICogLSByZ2IyaHNsKHtyLGcsYixhfSlcbiAgICAgKi9cbiAgICB2YXIgcmdiMmhzbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICBhcmdzID0gdW5wYWNrJDUoYXJncywgJ3JnYmEnKTtcbiAgICAgICAgdmFyIHIgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgZyA9IGFyZ3NbMV07XG4gICAgICAgIHZhciBiID0gYXJnc1syXTtcblxuICAgICAgICByIC89IDI1NTtcbiAgICAgICAgZyAvPSAyNTU7XG4gICAgICAgIGIgLz0gMjU1O1xuXG4gICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuXG4gICAgICAgIHZhciBsID0gKG1heCArIG1pbikgLyAyO1xuICAgICAgICB2YXIgcywgaDtcblxuICAgICAgICBpZiAobWF4ID09PSBtaW4pe1xuICAgICAgICAgICAgcyA9IDA7XG4gICAgICAgICAgICBoID0gTnVtYmVyLk5hTjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMgPSBsIDwgMC41ID8gKG1heCAtIG1pbikgLyAobWF4ICsgbWluKSA6IChtYXggLSBtaW4pIC8gKDIgLSBtYXggLSBtaW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHIgPT0gbWF4KSB7IGggPSAoZyAtIGIpIC8gKG1heCAtIG1pbik7IH1cbiAgICAgICAgZWxzZSBpZiAoZyA9PSBtYXgpIHsgaCA9IDIgKyAoYiAtIHIpIC8gKG1heCAtIG1pbik7IH1cbiAgICAgICAgZWxzZSBpZiAoYiA9PSBtYXgpIHsgaCA9IDQgKyAociAtIGcpIC8gKG1heCAtIG1pbik7IH1cblxuICAgICAgICBoICo9IDYwO1xuICAgICAgICBpZiAoaCA8IDApIHsgaCArPSAzNjA7IH1cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoPjMgJiYgYXJnc1szXSE9PXVuZGVmaW5lZCkgeyByZXR1cm4gW2gscyxsLGFyZ3NbM11dOyB9XG4gICAgICAgIHJldHVybiBbaCxzLGxdO1xuICAgIH07XG5cbiAgICB2YXIgcmdiMmhzbF8xID0gcmdiMmhzbDtcblxuICAgIHZhciB1bnBhY2skNiA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgbGFzdCQzID0gdXRpbHMubGFzdDtcblxuXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcblxuICAgIC8qXG4gICAgICogc3VwcG9ydGVkIGFyZ3VtZW50czpcbiAgICAgKiAtIHJnYjJjc3MocixnLGIpXG4gICAgICogLSByZ2IyY3NzKHIsZyxiLGEpXG4gICAgICogLSByZ2IyY3NzKFtyLGcsYl0sIG1vZGUpXG4gICAgICogLSByZ2IyY3NzKFtyLGcsYixhXSwgbW9kZSlcbiAgICAgKiAtIHJnYjJjc3Moe3IsZyxiLGF9LCBtb2RlKVxuICAgICAqL1xuICAgIHZhciByZ2IyY3NzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciByZ2JhID0gdW5wYWNrJDYoYXJncywgJ3JnYmEnKTtcbiAgICAgICAgdmFyIG1vZGUgPSBsYXN0JDMoYXJncykgfHwgJ3JnYic7XG4gICAgICAgIGlmIChtb2RlLnN1YnN0cigwLDMpID09ICdoc2wnKSB7XG4gICAgICAgICAgICByZXR1cm4gaHNsMmNzc18xKHJnYjJoc2xfMShyZ2JhKSwgbW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmdiYVswXSA9IHJvdW5kKHJnYmFbMF0pO1xuICAgICAgICByZ2JhWzFdID0gcm91bmQocmdiYVsxXSk7XG4gICAgICAgIHJnYmFbMl0gPSByb3VuZChyZ2JhWzJdKTtcbiAgICAgICAgaWYgKG1vZGUgPT09ICdyZ2JhJyB8fCAocmdiYS5sZW5ndGggPiAzICYmIHJnYmFbM108MSkpIHtcbiAgICAgICAgICAgIHJnYmFbM10gPSByZ2JhLmxlbmd0aCA+IDMgPyByZ2JhWzNdIDogMTtcbiAgICAgICAgICAgIG1vZGUgPSAncmdiYSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChtb2RlICsgXCIoXCIgKyAocmdiYS5zbGljZSgwLG1vZGU9PT0ncmdiJz8zOjQpLmpvaW4oJywnKSkgKyBcIilcIik7XG4gICAgfTtcblxuICAgIHZhciByZ2IyY3NzXzEgPSByZ2IyY3NzO1xuXG4gICAgdmFyIHVucGFjayQ3ID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciByb3VuZCQxID0gTWF0aC5yb3VuZDtcblxuICAgIHZhciBoc2wycmdiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXNzaWduO1xuXG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG4gICAgICAgIGFyZ3MgPSB1bnBhY2skNyhhcmdzLCAnaHNsJyk7XG4gICAgICAgIHZhciBoID0gYXJnc1swXTtcbiAgICAgICAgdmFyIHMgPSBhcmdzWzFdO1xuICAgICAgICB2YXIgbCA9IGFyZ3NbMl07XG4gICAgICAgIHZhciByLGcsYjtcbiAgICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgICAgIHIgPSBnID0gYiA9IGwqMjU1O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHQzID0gWzAsMCwwXTtcbiAgICAgICAgICAgIHZhciBjID0gWzAsMCwwXTtcbiAgICAgICAgICAgIHZhciB0MiA9IGwgPCAwLjUgPyBsICogKDErcykgOiBsK3MtbCpzO1xuICAgICAgICAgICAgdmFyIHQxID0gMiAqIGwgLSB0MjtcbiAgICAgICAgICAgIHZhciBoXyA9IGggLyAzNjA7XG4gICAgICAgICAgICB0M1swXSA9IGhfICsgMS8zO1xuICAgICAgICAgICAgdDNbMV0gPSBoXztcbiAgICAgICAgICAgIHQzWzJdID0gaF8gLSAxLzM7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8MzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHQzW2ldIDwgMCkgeyB0M1tpXSArPSAxOyB9XG4gICAgICAgICAgICAgICAgaWYgKHQzW2ldID4gMSkgeyB0M1tpXSAtPSAxOyB9XG4gICAgICAgICAgICAgICAgaWYgKDYgKiB0M1tpXSA8IDEpXG4gICAgICAgICAgICAgICAgICAgIHsgY1tpXSA9IHQxICsgKHQyIC0gdDEpICogNiAqIHQzW2ldOyB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoMiAqIHQzW2ldIDwgMSlcbiAgICAgICAgICAgICAgICAgICAgeyBjW2ldID0gdDI7IH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgzICogdDNbaV0gPCAyKVxuICAgICAgICAgICAgICAgICAgICB7IGNbaV0gPSB0MSArICh0MiAtIHQxKSAqICgoMiAvIDMpIC0gdDNbaV0pICogNjsgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgeyBjW2ldID0gdDE7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChhc3NpZ24gPSBbcm91bmQkMShjWzBdKjI1NSkscm91bmQkMShjWzFdKjI1NSkscm91bmQkMShjWzJdKjI1NSldLCByID0gYXNzaWduWzBdLCBnID0gYXNzaWduWzFdLCBiID0gYXNzaWduWzJdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICAvLyBrZWVwIGFscGhhIGNoYW5uZWxcbiAgICAgICAgICAgIHJldHVybiBbcixnLGIsYXJnc1szXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtyLGcsYiwxXTtcbiAgICB9O1xuXG4gICAgdmFyIGhzbDJyZ2JfMSA9IGhzbDJyZ2I7XG5cbiAgICB2YXIgUkVfUkdCID0gL15yZ2JcXChcXHMqKC0/XFxkKyksXFxzKigtP1xcZCspXFxzKixcXHMqKC0/XFxkKylcXHMqXFwpJC87XG4gICAgdmFyIFJFX1JHQkEgPSAvXnJnYmFcXChcXHMqKC0/XFxkKyksXFxzKigtP1xcZCspXFxzKixcXHMqKC0/XFxkKylcXHMqLFxccyooWzAxXXxbMDFdP1xcLlxcZCspXFwpJC87XG4gICAgdmFyIFJFX1JHQl9QQ1QgPSAvXnJnYlxcKFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSUsXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccypcXCkkLztcbiAgICB2YXIgUkVfUkdCQV9QQ1QgPSAvXnJnYmFcXChcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklLFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqLFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqLFxccyooWzAxXXxbMDFdP1xcLlxcZCspXFwpJC87XG4gICAgdmFyIFJFX0hTTCA9IC9eaHNsXFwoXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pLFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqLFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqXFwpJC87XG4gICAgdmFyIFJFX0hTTEEgPSAvXmhzbGFcXChcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyksXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKihbMDFdfFswMV0/XFwuXFxkKylcXCkkLztcblxuICAgIHZhciByb3VuZCQyID0gTWF0aC5yb3VuZDtcblxuICAgIHZhciBjc3MycmdiID0gZnVuY3Rpb24gKGNzcykge1xuICAgICAgICBjc3MgPSBjc3MudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICAgIHZhciBtO1xuXG4gICAgICAgIGlmIChpbnB1dC5mb3JtYXQubmFtZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0LmZvcm1hdC5uYW1lZChjc3MpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmdiKDI1MCwyMCwwKVxuICAgICAgICBpZiAoKG0gPSBjc3MubWF0Y2goUkVfUkdCKSkpIHtcbiAgICAgICAgICAgIHZhciByZ2IgPSBtLnNsaWNlKDEsNCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8MzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmdiW2ldID0gK3JnYltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJnYlszXSA9IDE7ICAvLyBkZWZhdWx0IGFscGhhXG4gICAgICAgICAgICByZXR1cm4gcmdiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmdiYSgyNTAsMjAsMCwwLjQpXG4gICAgICAgIGlmICgobSA9IGNzcy5tYXRjaChSRV9SR0JBKSkpIHtcbiAgICAgICAgICAgIHZhciByZ2IkMSA9IG0uc2xpY2UoMSw1KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMT0wOyBpJDE8NDsgaSQxKyspIHtcbiAgICAgICAgICAgICAgICByZ2IkMVtpJDFdID0gK3JnYiQxW2kkMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmdiJDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZ2IoMTAwJSwwJSwwJSlcbiAgICAgICAgaWYgKChtID0gY3NzLm1hdGNoKFJFX1JHQl9QQ1QpKSkge1xuICAgICAgICAgICAgdmFyIHJnYiQyID0gbS5zbGljZSgxLDQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQyPTA7IGkkMjwzOyBpJDIrKykge1xuICAgICAgICAgICAgICAgIHJnYiQyW2kkMl0gPSByb3VuZCQyKHJnYiQyW2kkMl0gKiAyLjU1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJnYiQyWzNdID0gMTsgIC8vIGRlZmF1bHQgYWxwaGFcbiAgICAgICAgICAgIHJldHVybiByZ2IkMjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJnYmEoMTAwJSwwJSwwJSwwLjQpXG4gICAgICAgIGlmICgobSA9IGNzcy5tYXRjaChSRV9SR0JBX1BDVCkpKSB7XG4gICAgICAgICAgICB2YXIgcmdiJDMgPSBtLnNsaWNlKDEsNSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDM9MDsgaSQzPDM7IGkkMysrKSB7XG4gICAgICAgICAgICAgICAgcmdiJDNbaSQzXSA9IHJvdW5kJDIocmdiJDNbaSQzXSAqIDIuNTUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmdiJDNbM10gPSArcmdiJDNbM107XG4gICAgICAgICAgICByZXR1cm4gcmdiJDM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoc2woMCwxMDAlLDUwJSlcbiAgICAgICAgaWYgKChtID0gY3NzLm1hdGNoKFJFX0hTTCkpKSB7XG4gICAgICAgICAgICB2YXIgaHNsID0gbS5zbGljZSgxLDQpO1xuICAgICAgICAgICAgaHNsWzFdICo9IDAuMDE7XG4gICAgICAgICAgICBoc2xbMl0gKj0gMC4wMTtcbiAgICAgICAgICAgIHZhciByZ2IkNCA9IGhzbDJyZ2JfMShoc2wpO1xuICAgICAgICAgICAgcmdiJDRbM10gPSAxO1xuICAgICAgICAgICAgcmV0dXJuIHJnYiQ0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHNsYSgwLDEwMCUsNTAlLDAuNSlcbiAgICAgICAgaWYgKChtID0gY3NzLm1hdGNoKFJFX0hTTEEpKSkge1xuICAgICAgICAgICAgdmFyIGhzbCQxID0gbS5zbGljZSgxLDQpO1xuICAgICAgICAgICAgaHNsJDFbMV0gKj0gMC4wMTtcbiAgICAgICAgICAgIGhzbCQxWzJdICo9IDAuMDE7XG4gICAgICAgICAgICB2YXIgcmdiJDUgPSBoc2wycmdiXzEoaHNsJDEpO1xuICAgICAgICAgICAgcmdiJDVbM10gPSArbVs0XTsgIC8vIGRlZmF1bHQgYWxwaGEgPSAxXG4gICAgICAgICAgICByZXR1cm4gcmdiJDU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY3NzMnJnYi50ZXN0ID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIFJFX1JHQi50ZXN0KHMpIHx8XG4gICAgICAgICAgICBSRV9SR0JBLnRlc3QocykgfHxcbiAgICAgICAgICAgIFJFX1JHQl9QQ1QudGVzdChzKSB8fFxuICAgICAgICAgICAgUkVfUkdCQV9QQ1QudGVzdChzKSB8fFxuICAgICAgICAgICAgUkVfSFNMLnRlc3QocykgfHxcbiAgICAgICAgICAgIFJFX0hTTEEudGVzdChzKTtcbiAgICB9O1xuXG4gICAgdmFyIGNzczJyZ2JfMSA9IGNzczJyZ2I7XG5cbiAgICB2YXIgdHlwZSQzID0gdXRpbHMudHlwZTtcblxuXG5cblxuICAgIENvbG9yXzEucHJvdG90eXBlLmNzcyA9IGZ1bmN0aW9uKG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIHJnYjJjc3NfMSh0aGlzLl9yZ2IsIG1vZGUpO1xuICAgIH07XG5cbiAgICBjaHJvbWFfMS5jc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yXzEsIFsgbnVsbCBdLmNvbmNhdCggYXJncywgWydjc3MnXSkgKSk7XG4gICAgfTtcblxuICAgIGlucHV0LmZvcm1hdC5jc3MgPSBjc3MycmdiXzE7XG5cbiAgICBpbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICBwOiA1LFxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoaCkge1xuICAgICAgICAgICAgdmFyIHJlc3QgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB3aGlsZSAoIGxlbi0tID4gMCApIHJlc3RbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgICAgICAgICAgIGlmICghcmVzdC5sZW5ndGggJiYgdHlwZSQzKGgpID09PSAnc3RyaW5nJyAmJiBjc3MycmdiXzEudGVzdChoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnY3NzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHVucGFjayQ4ID0gdXRpbHMudW5wYWNrO1xuXG4gICAgaW5wdXQuZm9ybWF0LmdsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciByZ2IgPSB1bnBhY2skOChhcmdzLCAncmdiYScpO1xuICAgICAgICByZ2JbMF0gKj0gMjU1O1xuICAgICAgICByZ2JbMV0gKj0gMjU1O1xuICAgICAgICByZ2JbMl0gKj0gMjU1O1xuICAgICAgICByZXR1cm4gcmdiO1xuICAgIH07XG5cbiAgICBjaHJvbWFfMS5nbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3JfMSwgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ2dsJ10pICkpO1xuICAgIH07XG5cbiAgICBDb2xvcl8xLnByb3RvdHlwZS5nbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmdiID0gdGhpcy5fcmdiO1xuICAgICAgICByZXR1cm4gW3JnYlswXS8yNTUsIHJnYlsxXS8yNTUsIHJnYlsyXS8yNTUsIHJnYlszXV07XG4gICAgfTtcblxuICAgIHZhciB1bnBhY2skOSA9IHV0aWxzLnVucGFjaztcblxuICAgIHZhciByZ2IyaGNnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciByZWYgPSB1bnBhY2skOShhcmdzLCAncmdiJyk7XG4gICAgICAgIHZhciByID0gcmVmWzBdO1xuICAgICAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGIgPSByZWZbMl07XG4gICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgICAgICB2YXIgZGVsdGEgPSBtYXggLSBtaW47XG4gICAgICAgIHZhciBjID0gZGVsdGEgKiAxMDAgLyAyNTU7XG4gICAgICAgIHZhciBfZyA9IG1pbiAvICgyNTUgLSBkZWx0YSkgKiAxMDA7XG4gICAgICAgIHZhciBoO1xuICAgICAgICBpZiAoZGVsdGEgPT09IDApIHtcbiAgICAgICAgICAgIGggPSBOdW1iZXIuTmFOO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHIgPT09IG1heCkgeyBoID0gKGcgLSBiKSAvIGRlbHRhOyB9XG4gICAgICAgICAgICBpZiAoZyA9PT0gbWF4KSB7IGggPSAyKyhiIC0gcikgLyBkZWx0YTsgfVxuICAgICAgICAgICAgaWYgKGIgPT09IG1heCkgeyBoID0gNCsociAtIGcpIC8gZGVsdGE7IH1cbiAgICAgICAgICAgIGggKj0gNjA7XG4gICAgICAgICAgICBpZiAoaCA8IDApIHsgaCArPSAzNjA7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2gsIGMsIF9nXTtcbiAgICB9O1xuXG4gICAgdmFyIHJnYjJoY2dfMSA9IHJnYjJoY2c7XG5cbiAgICB2YXIgdW5wYWNrJGEgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblxuICAgIC8qXG4gICAgICogdGhpcyBpcyBiYXNpY2FsbHkganVzdCBIU1Ygd2l0aCBzb21lIG1pbm9yIHR3ZWFrc1xuICAgICAqXG4gICAgICogaHVlLi4gWzAuLjM2MF1cbiAgICAgKiBjaHJvbWEgLi4gWzAuLjFdXG4gICAgICogZ3JheW5lc3MgLi4gWzAuLjFdXG4gICAgICovXG5cbiAgICB2YXIgaGNnMnJnYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFzc2lnbiwgYXNzaWduJDEsIGFzc2lnbiQyLCBhc3NpZ24kMywgYXNzaWduJDQsIGFzc2lnbiQ1O1xuXG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG4gICAgICAgIGFyZ3MgPSB1bnBhY2skYShhcmdzLCAnaGNnJyk7XG4gICAgICAgIHZhciBoID0gYXJnc1swXTtcbiAgICAgICAgdmFyIGMgPSBhcmdzWzFdO1xuICAgICAgICB2YXIgX2cgPSBhcmdzWzJdO1xuICAgICAgICB2YXIgcixnLGI7XG4gICAgICAgIF9nID0gX2cgKiAyNTU7XG4gICAgICAgIHZhciBfYyA9IGMgKiAyNTU7XG4gICAgICAgIGlmIChjID09PSAwKSB7XG4gICAgICAgICAgICByID0gZyA9IGIgPSBfZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoID09PSAzNjApIHsgaCA9IDA7IH1cbiAgICAgICAgICAgIGlmIChoID4gMzYwKSB7IGggLT0gMzYwOyB9XG4gICAgICAgICAgICBpZiAoaCA8IDApIHsgaCArPSAzNjA7IH1cbiAgICAgICAgICAgIGggLz0gNjA7XG4gICAgICAgICAgICB2YXIgaSA9IGZsb29yKGgpO1xuICAgICAgICAgICAgdmFyIGYgPSBoIC0gaTtcbiAgICAgICAgICAgIHZhciBwID0gX2cgKiAoMSAtIGMpO1xuICAgICAgICAgICAgdmFyIHEgPSBwICsgX2MgKiAoMSAtIGYpO1xuICAgICAgICAgICAgdmFyIHQgPSBwICsgX2MgKiBmO1xuICAgICAgICAgICAgdmFyIHYgPSBwICsgX2M7XG4gICAgICAgICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IChhc3NpZ24gPSBbdiwgdCwgcF0sIHIgPSBhc3NpZ25bMF0sIGcgPSBhc3NpZ25bMV0sIGIgPSBhc3NpZ25bMl0pOyBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgMTogKGFzc2lnbiQxID0gW3EsIHYsIHBdLCByID0gYXNzaWduJDFbMF0sIGcgPSBhc3NpZ24kMVsxXSwgYiA9IGFzc2lnbiQxWzJdKTsgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIDI6IChhc3NpZ24kMiA9IFtwLCB2LCB0XSwgciA9IGFzc2lnbiQyWzBdLCBnID0gYXNzaWduJDJbMV0sIGIgPSBhc3NpZ24kMlsyXSk7IGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSAzOiAoYXNzaWduJDMgPSBbcCwgcSwgdl0sIHIgPSBhc3NpZ24kM1swXSwgZyA9IGFzc2lnbiQzWzFdLCBiID0gYXNzaWduJDNbMl0pOyBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgNDogKGFzc2lnbiQ0ID0gW3QsIHAsIHZdLCByID0gYXNzaWduJDRbMF0sIGcgPSBhc3NpZ24kNFsxXSwgYiA9IGFzc2lnbiQ0WzJdKTsgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IChhc3NpZ24kNSA9IFt2LCBwLCBxXSwgciA9IGFzc2lnbiQ1WzBdLCBnID0gYXNzaWduJDVbMV0sIGIgPSBhc3NpZ24kNVsyXSk7IGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtyLCBnLCBiLCBhcmdzLmxlbmd0aCA+IDMgPyBhcmdzWzNdIDogMV07XG4gICAgfTtcblxuICAgIHZhciBoY2cycmdiXzEgPSBoY2cycmdiO1xuXG4gICAgdmFyIHVucGFjayRiID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciB0eXBlJDQgPSB1dGlscy50eXBlO1xuXG5cblxuXG5cblxuICAgIENvbG9yXzEucHJvdG90eXBlLmhjZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmdiMmhjZ18xKHRoaXMuX3JnYik7XG4gICAgfTtcblxuICAgIGNocm9tYV8xLmhjZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3JfMSwgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ2hjZyddKSApKTtcbiAgICB9O1xuXG4gICAgaW5wdXQuZm9ybWF0LmhjZyA9IGhjZzJyZ2JfMTtcblxuICAgIGlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgICAgIHA6IDEsXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgICAgICBhcmdzID0gdW5wYWNrJGIoYXJncywgJ2hjZycpO1xuICAgICAgICAgICAgaWYgKHR5cGUkNChhcmdzKSA9PT0gJ2FycmF5JyAmJiBhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnaGNnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHVucGFjayRjID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBsYXN0JDQgPSB1dGlscy5sYXN0O1xuICAgIHZhciByb3VuZCQzID0gTWF0aC5yb3VuZDtcblxuICAgIHZhciByZ2IyaGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciByZWYgPSB1bnBhY2skYyhhcmdzLCAncmdiYScpO1xuICAgICAgICB2YXIgciA9IHJlZlswXTtcbiAgICAgICAgdmFyIGcgPSByZWZbMV07XG4gICAgICAgIHZhciBiID0gcmVmWzJdO1xuICAgICAgICB2YXIgYSA9IHJlZlszXTtcbiAgICAgICAgdmFyIG1vZGUgPSBsYXN0JDQoYXJncykgfHwgJ2F1dG8nO1xuICAgICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7IGEgPSAxOyB9XG4gICAgICAgIGlmIChtb2RlID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgIG1vZGUgPSBhIDwgMSA/ICdyZ2JhJyA6ICdyZ2InO1xuICAgICAgICB9XG4gICAgICAgIHIgPSByb3VuZCQzKHIpO1xuICAgICAgICBnID0gcm91bmQkMyhnKTtcbiAgICAgICAgYiA9IHJvdW5kJDMoYik7XG4gICAgICAgIHZhciB1ID0gciA8PCAxNiB8IGcgPDwgOCB8IGI7XG4gICAgICAgIHZhciBzdHIgPSBcIjAwMDAwMFwiICsgdS50b1N0cmluZygxNik7IC8vIy50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKHN0ci5sZW5ndGggLSA2KTtcbiAgICAgICAgdmFyIGh4YSA9ICcwJyArIHJvdW5kJDMoYSAqIDI1NSkudG9TdHJpbmcoMTYpO1xuICAgICAgICBoeGEgPSBoeGEuc3Vic3RyKGh4YS5sZW5ndGggLSAyKTtcbiAgICAgICAgc3dpdGNoIChtb2RlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3JnYmEnOiByZXR1cm4gKFwiI1wiICsgc3RyICsgaHhhKTtcbiAgICAgICAgICAgIGNhc2UgJ2FyZ2InOiByZXR1cm4gKFwiI1wiICsgaHhhICsgc3RyKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiAoXCIjXCIgKyBzdHIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZ2IyaGV4XzEgPSByZ2IyaGV4O1xuXG4gICAgdmFyIFJFX0hFWCA9IC9eIz8oW0EtRmEtZjAtOV17Nn18W0EtRmEtZjAtOV17M30pJC87XG4gICAgdmFyIFJFX0hFWEEgPSAvXiM/KFtBLUZhLWYwLTldezh9fFtBLUZhLWYwLTldezR9KSQvO1xuXG4gICAgdmFyIGhleDJyZ2IgPSBmdW5jdGlvbiAoaGV4KSB7XG4gICAgICAgIGlmIChoZXgubWF0Y2goUkVfSEVYKSkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIG9wdGlvbmFsIGxlYWRpbmcgI1xuICAgICAgICAgICAgaWYgKGhleC5sZW5ndGggPT09IDQgfHwgaGV4Lmxlbmd0aCA9PT0gNykge1xuICAgICAgICAgICAgICAgIGhleCA9IGhleC5zdWJzdHIoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBleHBhbmQgc2hvcnQtbm90YXRpb24gdG8gZnVsbCBzaXgtZGlnaXRcbiAgICAgICAgICAgIGlmIChoZXgubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgaGV4ID0gaGV4LnNwbGl0KCcnKTtcbiAgICAgICAgICAgICAgICBoZXggPSBoZXhbMF0raGV4WzBdK2hleFsxXStoZXhbMV0raGV4WzJdK2hleFsyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB1ID0gcGFyc2VJbnQoaGV4LCAxNik7XG4gICAgICAgICAgICB2YXIgciA9IHUgPj4gMTY7XG4gICAgICAgICAgICB2YXIgZyA9IHUgPj4gOCAmIDB4RkY7XG4gICAgICAgICAgICB2YXIgYiA9IHUgJiAweEZGO1xuICAgICAgICAgICAgcmV0dXJuIFtyLGcsYiwxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1hdGNoIHJnYmEgaGV4IGZvcm1hdCwgZWcgI0ZGMDAwMDc3XG4gICAgICAgIGlmIChoZXgubWF0Y2goUkVfSEVYQSkpIHtcbiAgICAgICAgICAgIGlmIChoZXgubGVuZ3RoID09PSA1IHx8IGhleC5sZW5ndGggPT09IDkpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgb3B0aW9uYWwgbGVhZGluZyAjXG4gICAgICAgICAgICAgICAgaGV4ID0gaGV4LnN1YnN0cigxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGV4cGFuZCBzaG9ydC1ub3RhdGlvbiB0byBmdWxsIGVpZ2h0LWRpZ2l0XG4gICAgICAgICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIGhleCA9IGhleC5zcGxpdCgnJyk7XG4gICAgICAgICAgICAgICAgaGV4ID0gaGV4WzBdK2hleFswXStoZXhbMV0raGV4WzFdK2hleFsyXStoZXhbMl0raGV4WzNdK2hleFszXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB1JDEgPSBwYXJzZUludChoZXgsIDE2KTtcbiAgICAgICAgICAgIHZhciByJDEgPSB1JDEgPj4gMjQgJiAweEZGO1xuICAgICAgICAgICAgdmFyIGckMSA9IHUkMSA+PiAxNiAmIDB4RkY7XG4gICAgICAgICAgICB2YXIgYiQxID0gdSQxID4+IDggJiAweEZGO1xuICAgICAgICAgICAgdmFyIGEgPSBNYXRoLnJvdW5kKCh1JDEgJiAweEZGKSAvIDB4RkYgKiAxMDApIC8gMTAwO1xuICAgICAgICAgICAgcmV0dXJuIFtyJDEsZyQxLGIkMSxhXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIHVzZWQgdG8gY2hlY2sgZm9yIGNzcyBjb2xvcnMgaGVyZVxuICAgICAgICAvLyBpZiBfaW5wdXQuY3NzPyBhbmQgcmdiID0gX2lucHV0LmNzcyBoZXhcbiAgICAgICAgLy8gICAgIHJldHVybiByZ2JcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwidW5rbm93biBoZXggY29sb3I6IFwiICsgaGV4KSk7XG4gICAgfTtcblxuICAgIHZhciBoZXgycmdiXzEgPSBoZXgycmdiO1xuXG4gICAgdmFyIHR5cGUkNSA9IHV0aWxzLnR5cGU7XG5cblxuXG5cbiAgICBDb2xvcl8xLnByb3RvdHlwZS5oZXggPSBmdW5jdGlvbihtb2RlKSB7XG4gICAgICAgIHJldHVybiByZ2IyaGV4XzEodGhpcy5fcmdiLCBtb2RlKTtcbiAgICB9O1xuXG4gICAgY2hyb21hXzEuaGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvcl8xLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnaGV4J10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dC5mb3JtYXQuaGV4ID0gaGV4MnJnYl8xO1xuICAgIGlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgICAgIHA6IDQsXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdCA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gPiAwICkgcmVzdFsgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICAgICAgICAgICAgaWYgKCFyZXN0Lmxlbmd0aCAmJiB0eXBlJDUoaCkgPT09ICdzdHJpbmcnICYmIFszLDQsNSw2LDcsOCw5XS5pbmRleE9mKGgubGVuZ3RoKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdoZXgnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgdW5wYWNrJGQgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIFRXT1BJID0gdXRpbHMuVFdPUEk7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluO1xuICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuICAgIHZhciBhY29zID0gTWF0aC5hY29zO1xuXG4gICAgdmFyIHJnYjJoc2kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgLypcbiAgICAgICAgYm9ycm93ZWQgZnJvbSBoZXJlOlxuICAgICAgICBodHRwOi8vaHVtbWVyLnN0YW5mb3JkLmVkdS9tdXNlaW5mby9kb2MvZXhhbXBsZXMvaHVtZHJ1bS9rZXlzY2FwZTIvcmdiMmhzaS5jcHBcbiAgICAgICAgKi9cbiAgICAgICAgdmFyIHJlZiA9IHVucGFjayRkKGFyZ3MsICdyZ2InKTtcbiAgICAgICAgdmFyIHIgPSByZWZbMF07XG4gICAgICAgIHZhciBnID0gcmVmWzFdO1xuICAgICAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICAgICAgciAvPSAyNTU7XG4gICAgICAgIGcgLz0gMjU1O1xuICAgICAgICBiIC89IDI1NTtcbiAgICAgICAgdmFyIGg7XG4gICAgICAgIHZhciBtaW5fID0gbWluKHIsZyxiKTtcbiAgICAgICAgdmFyIGkgPSAocitnK2IpIC8gMztcbiAgICAgICAgdmFyIHMgPSBpID4gMCA/IDEgLSBtaW5fL2kgOiAwO1xuICAgICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICAgICAgaCA9IE5hTjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGggPSAoKHItZykrKHItYikpIC8gMjtcbiAgICAgICAgICAgIGggLz0gc3FydCgoci1nKSooci1nKSArIChyLWIpKihnLWIpKTtcbiAgICAgICAgICAgIGggPSBhY29zKGgpO1xuICAgICAgICAgICAgaWYgKGIgPiBnKSB7XG4gICAgICAgICAgICAgICAgaCA9IFRXT1BJIC0gaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGggLz0gVFdPUEk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtoKjM2MCxzLGldO1xuICAgIH07XG5cbiAgICB2YXIgcmdiMmhzaV8xID0gcmdiMmhzaTtcblxuICAgIHZhciB1bnBhY2skZSA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgbGltaXQkMSA9IHV0aWxzLmxpbWl0O1xuICAgIHZhciBUV09QSSQxID0gdXRpbHMuVFdPUEk7XG4gICAgdmFyIFBJVEhJUkQgPSB1dGlscy5QSVRISVJEO1xuICAgIHZhciBjb3MgPSBNYXRoLmNvcztcblxuICAgIC8qXG4gICAgICogaHVlIFswLi4zNjBdXG4gICAgICogc2F0dXJhdGlvbiBbMC4uMV1cbiAgICAgKiBpbnRlbnNpdHkgWzAuLjFdXG4gICAgICovXG4gICAgdmFyIGhzaTJyZ2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgLypcbiAgICAgICAgYm9ycm93ZWQgZnJvbSBoZXJlOlxuICAgICAgICBodHRwOi8vaHVtbWVyLnN0YW5mb3JkLmVkdS9tdXNlaW5mby9kb2MvZXhhbXBsZXMvaHVtZHJ1bS9rZXlzY2FwZTIvaHNpMnJnYi5jcHBcbiAgICAgICAgKi9cbiAgICAgICAgYXJncyA9IHVucGFjayRlKGFyZ3MsICdoc2knKTtcbiAgICAgICAgdmFyIGggPSBhcmdzWzBdO1xuICAgICAgICB2YXIgcyA9IGFyZ3NbMV07XG4gICAgICAgIHZhciBpID0gYXJnc1syXTtcbiAgICAgICAgdmFyIHIsZyxiO1xuXG4gICAgICAgIGlmIChpc05hTihoKSkgeyBoID0gMDsgfVxuICAgICAgICBpZiAoaXNOYU4ocykpIHsgcyA9IDA7IH1cbiAgICAgICAgLy8gbm9ybWFsaXplIGh1ZVxuICAgICAgICBpZiAoaCA+IDM2MCkgeyBoIC09IDM2MDsgfVxuICAgICAgICBpZiAoaCA8IDApIHsgaCArPSAzNjA7IH1cbiAgICAgICAgaCAvPSAzNjA7XG4gICAgICAgIGlmIChoIDwgMS8zKSB7XG4gICAgICAgICAgICBiID0gKDEtcykvMztcbiAgICAgICAgICAgIHIgPSAoMStzKmNvcyhUV09QSSQxKmgpL2NvcyhQSVRISVJELVRXT1BJJDEqaCkpLzM7XG4gICAgICAgICAgICBnID0gMSAtIChiK3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGggPCAyLzMpIHtcbiAgICAgICAgICAgIGggLT0gMS8zO1xuICAgICAgICAgICAgciA9ICgxLXMpLzM7XG4gICAgICAgICAgICBnID0gKDErcypjb3MoVFdPUEkkMSpoKS9jb3MoUElUSElSRC1UV09QSSQxKmgpKS8zO1xuICAgICAgICAgICAgYiA9IDEgLSAocitnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGggLT0gMi8zO1xuICAgICAgICAgICAgZyA9ICgxLXMpLzM7XG4gICAgICAgICAgICBiID0gKDErcypjb3MoVFdPUEkkMSpoKS9jb3MoUElUSElSRC1UV09QSSQxKmgpKS8zO1xuICAgICAgICAgICAgciA9IDEgLSAoZytiKTtcbiAgICAgICAgfVxuICAgICAgICByID0gbGltaXQkMShpKnIqMyk7XG4gICAgICAgIGcgPSBsaW1pdCQxKGkqZyozKTtcbiAgICAgICAgYiA9IGxpbWl0JDEoaSpiKjMpO1xuICAgICAgICByZXR1cm4gW3IqMjU1LCBnKjI1NSwgYioyNTUsIGFyZ3MubGVuZ3RoID4gMyA/IGFyZ3NbM10gOiAxXTtcbiAgICB9O1xuXG4gICAgdmFyIGhzaTJyZ2JfMSA9IGhzaTJyZ2I7XG5cbiAgICB2YXIgdW5wYWNrJGYgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHR5cGUkNiA9IHV0aWxzLnR5cGU7XG5cblxuXG5cblxuXG4gICAgQ29sb3JfMS5wcm90b3R5cGUuaHNpID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZ2IyaHNpXzEodGhpcy5fcmdiKTtcbiAgICB9O1xuXG4gICAgY2hyb21hXzEuaHNpID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvcl8xLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnaHNpJ10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dC5mb3JtYXQuaHNpID0gaHNpMnJnYl8xO1xuXG4gICAgaW5wdXQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogMixcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgIGFyZ3MgPSB1bnBhY2skZihhcmdzLCAnaHNpJyk7XG4gICAgICAgICAgICBpZiAodHlwZSQ2KGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdoc2knO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgdW5wYWNrJGcgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHR5cGUkNyA9IHV0aWxzLnR5cGU7XG5cblxuXG5cblxuXG4gICAgQ29sb3JfMS5wcm90b3R5cGUuaHNsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZ2IyaHNsXzEodGhpcy5fcmdiKTtcbiAgICB9O1xuXG4gICAgY2hyb21hXzEuaHNsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvcl8xLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnaHNsJ10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dC5mb3JtYXQuaHNsID0gaHNsMnJnYl8xO1xuXG4gICAgaW5wdXQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogMixcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgIGFyZ3MgPSB1bnBhY2skZyhhcmdzLCAnaHNsJyk7XG4gICAgICAgICAgICBpZiAodHlwZSQ3KGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdoc2wnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgdW5wYWNrJGggPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIG1pbiQxID0gTWF0aC5taW47XG4gICAgdmFyIG1heCQxID0gTWF0aC5tYXg7XG5cbiAgICAvKlxuICAgICAqIHN1cHBvcnRlZCBhcmd1bWVudHM6XG4gICAgICogLSByZ2IyaHN2KHIsZyxiKVxuICAgICAqIC0gcmdiMmhzdihbcixnLGJdKVxuICAgICAqIC0gcmdiMmhzdih7cixnLGJ9KVxuICAgICAqL1xuICAgIHZhciByZ2IyaHNsJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgYXJncyA9IHVucGFjayRoKGFyZ3MsICdyZ2InKTtcbiAgICAgICAgdmFyIHIgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgZyA9IGFyZ3NbMV07XG4gICAgICAgIHZhciBiID0gYXJnc1syXTtcbiAgICAgICAgdmFyIG1pbl8gPSBtaW4kMShyLCBnLCBiKTtcbiAgICAgICAgdmFyIG1heF8gPSBtYXgkMShyLCBnLCBiKTtcbiAgICAgICAgdmFyIGRlbHRhID0gbWF4XyAtIG1pbl87XG4gICAgICAgIHZhciBoLHMsdjtcbiAgICAgICAgdiA9IG1heF8gLyAyNTUuMDtcbiAgICAgICAgaWYgKG1heF8gPT09IDApIHtcbiAgICAgICAgICAgIGggPSBOdW1iZXIuTmFOO1xuICAgICAgICAgICAgcyA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzID0gZGVsdGEgLyBtYXhfO1xuICAgICAgICAgICAgaWYgKHIgPT09IG1heF8pIHsgaCA9IChnIC0gYikgLyBkZWx0YTsgfVxuICAgICAgICAgICAgaWYgKGcgPT09IG1heF8pIHsgaCA9IDIrKGIgLSByKSAvIGRlbHRhOyB9XG4gICAgICAgICAgICBpZiAoYiA9PT0gbWF4XykgeyBoID0gNCsociAtIGcpIC8gZGVsdGE7IH1cbiAgICAgICAgICAgIGggKj0gNjA7XG4gICAgICAgICAgICBpZiAoaCA8IDApIHsgaCArPSAzNjA7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2gsIHMsIHZdXG4gICAgfTtcblxuICAgIHZhciByZ2IyaHN2ID0gcmdiMmhzbCQxO1xuXG4gICAgdmFyIHVucGFjayRpID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBmbG9vciQxID0gTWF0aC5mbG9vcjtcblxuICAgIHZhciBoc3YycmdiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXNzaWduLCBhc3NpZ24kMSwgYXNzaWduJDIsIGFzc2lnbiQzLCBhc3NpZ24kNCwgYXNzaWduJDU7XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcbiAgICAgICAgYXJncyA9IHVucGFjayRpKGFyZ3MsICdoc3YnKTtcbiAgICAgICAgdmFyIGggPSBhcmdzWzBdO1xuICAgICAgICB2YXIgcyA9IGFyZ3NbMV07XG4gICAgICAgIHZhciB2ID0gYXJnc1syXTtcbiAgICAgICAgdmFyIHIsZyxiO1xuICAgICAgICB2ICo9IDI1NTtcbiAgICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgICAgIHIgPSBnID0gYiA9IHY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaCA9PT0gMzYwKSB7IGggPSAwOyB9XG4gICAgICAgICAgICBpZiAoaCA+IDM2MCkgeyBoIC09IDM2MDsgfVxuICAgICAgICAgICAgaWYgKGggPCAwKSB7IGggKz0gMzYwOyB9XG4gICAgICAgICAgICBoIC89IDYwO1xuXG4gICAgICAgICAgICB2YXIgaSA9IGZsb29yJDEoaCk7XG4gICAgICAgICAgICB2YXIgZiA9IGggLSBpO1xuICAgICAgICAgICAgdmFyIHAgPSB2ICogKDEgLSBzKTtcbiAgICAgICAgICAgIHZhciBxID0gdiAqICgxIC0gcyAqIGYpO1xuICAgICAgICAgICAgdmFyIHQgPSB2ICogKDEgLSBzICogKDEgLSBmKSk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoaSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogKGFzc2lnbiA9IFt2LCB0LCBwXSwgciA9IGFzc2lnblswXSwgZyA9IGFzc2lnblsxXSwgYiA9IGFzc2lnblsyXSk7IGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSAxOiAoYXNzaWduJDEgPSBbcSwgdiwgcF0sIHIgPSBhc3NpZ24kMVswXSwgZyA9IGFzc2lnbiQxWzFdLCBiID0gYXNzaWduJDFbMl0pOyBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgMjogKGFzc2lnbiQyID0gW3AsIHYsIHRdLCByID0gYXNzaWduJDJbMF0sIGcgPSBhc3NpZ24kMlsxXSwgYiA9IGFzc2lnbiQyWzJdKTsgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIDM6IChhc3NpZ24kMyA9IFtwLCBxLCB2XSwgciA9IGFzc2lnbiQzWzBdLCBnID0gYXNzaWduJDNbMV0sIGIgPSBhc3NpZ24kM1syXSk7IGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSA0OiAoYXNzaWduJDQgPSBbdCwgcCwgdl0sIHIgPSBhc3NpZ24kNFswXSwgZyA9IGFzc2lnbiQ0WzFdLCBiID0gYXNzaWduJDRbMl0pOyBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgNTogKGFzc2lnbiQ1ID0gW3YsIHAsIHFdLCByID0gYXNzaWduJDVbMF0sIGcgPSBhc3NpZ24kNVsxXSwgYiA9IGFzc2lnbiQ1WzJdKTsgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3IsZyxiLGFyZ3MubGVuZ3RoID4gMz9hcmdzWzNdOjFdO1xuICAgIH07XG5cbiAgICB2YXIgaHN2MnJnYl8xID0gaHN2MnJnYjtcblxuICAgIHZhciB1bnBhY2skaiA9IHV0aWxzLnVucGFjaztcbiAgICB2YXIgdHlwZSQ4ID0gdXRpbHMudHlwZTtcblxuXG5cblxuXG5cbiAgICBDb2xvcl8xLnByb3RvdHlwZS5oc3YgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJnYjJoc3YodGhpcy5fcmdiKTtcbiAgICB9O1xuXG4gICAgY2hyb21hXzEuaHN2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvcl8xLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnaHN2J10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dC5mb3JtYXQuaHN2ID0gaHN2MnJnYl8xO1xuXG4gICAgaW5wdXQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogMixcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgIGFyZ3MgPSB1bnBhY2skaihhcmdzLCAnaHN2Jyk7XG4gICAgICAgICAgICBpZiAodHlwZSQ4KGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdoc3YnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgbGFiQ29uc3RhbnRzID0ge1xuICAgICAgICAvLyBDb3JyZXNwb25kcyByb3VnaGx5IHRvIFJHQiBicmlnaHRlci9kYXJrZXJcbiAgICAgICAgS246IDE4LFxuXG4gICAgICAgIC8vIEQ2NSBzdGFuZGFyZCByZWZlcmVudFxuICAgICAgICBYbjogMC45NTA0NzAsXG4gICAgICAgIFluOiAxLFxuICAgICAgICBabjogMS4wODg4MzAsXG5cbiAgICAgICAgdDA6IDAuMTM3OTMxMDM0LCAgLy8gNCAvIDI5XG4gICAgICAgIHQxOiAwLjIwNjg5NjU1MiwgIC8vIDYgLyAyOVxuICAgICAgICB0MjogMC4xMjg0MTg1NSwgICAvLyAzICogdDEgKiB0MVxuICAgICAgICB0MzogMC4wMDg4NTY0NTIsICAvLyB0MSAqIHQxICogdDFcbiAgICB9O1xuXG4gICAgdmFyIHVucGFjayRrID0gdXRpbHMudW5wYWNrO1xuICAgIHZhciBwb3cgPSBNYXRoLnBvdztcblxuICAgIHZhciByZ2IybGFiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciByZWYgPSB1bnBhY2skayhhcmdzLCAncmdiJyk7XG4gICAgICAgIHZhciByID0gcmVmWzBdO1xuICAgICAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGIgPSByZWZbMl07XG4gICAgICAgIHZhciByZWYkMSA9IHJnYjJ4eXoocixnLGIpO1xuICAgICAgICB2YXIgeCA9IHJlZiQxWzBdO1xuICAgICAgICB2YXIgeSA9IHJlZiQxWzFdO1xuICAgICAgICB2YXIgeiA9IHJlZiQxWzJdO1xuICAgICAgICB2YXIgbCA9IDExNiAqIHkgLSAxNjtcbiAgICAgICAgcmV0dXJuIFtsIDwgMCA/IDAgOiBsLCA1MDAgKiAoeCAtIHkpLCAyMDAgKiAoeSAtIHopXTtcbiAgICB9O1xuXG4gICAgdmFyIHJnYl94eXogPSBmdW5jdGlvbiAocikge1xuICAgICAgICBpZiAoKHIgLz0gMjU1KSA8PSAwLjA0MDQ1KSB7IHJldHVybiByIC8gMTIuOTI7IH1cbiAgICAgICAgcmV0dXJuIHBvdygociArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xuICAgIH07XG5cbiAgICB2YXIgeHl6X2xhYiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICh0ID4gbGFiQ29uc3RhbnRzLnQzKSB7IHJldHVybiBwb3codCwgMSAvIDMpOyB9XG4gICAgICAgIHJldHVybiB0IC8gbGFiQ29uc3RhbnRzLnQyICsgbGFiQ29uc3RhbnRzLnQwO1xuICAgIH07XG5cbiAgICB2YXIgcmdiMnh5eiA9IGZ1bmN0aW9uIChyLGcsYikge1xuICAgICAgICByID0gcmdiX3h5eihyKTtcbiAgICAgICAgZyA9IHJnYl94eXooZyk7XG4gICAgICAgIGIgPSByZ2JfeHl6KGIpO1xuICAgICAgICB2YXIgeCA9IHh5el9sYWIoKDAuNDEyNDU2NCAqIHIgKyAwLjM1NzU3NjEgKiBnICsgMC4xODA0Mzc1ICogYikgLyBsYWJDb25zdGFudHMuWG4pO1xuICAgICAgICB2YXIgeSA9IHh5el9sYWIoKDAuMjEyNjcyOSAqIHIgKyAwLjcxNTE1MjIgKiBnICsgMC4wNzIxNzUwICogYikgLyBsYWJDb25zdGFudHMuWW4pO1xuICAgICAgICB2YXIgeiA9IHh5el9sYWIoKDAuMDE5MzMzOSAqIHIgKyAwLjExOTE5MjAgKiBnICsgMC45NTAzMDQxICogYikgLyBsYWJDb25zdGFudHMuWm4pO1xuICAgICAgICByZXR1cm4gW3gseSx6XTtcbiAgICB9O1xuXG4gICAgdmFyIHJnYjJsYWJfMSA9IHJnYjJsYWI7XG5cbiAgICB2YXIgdW5wYWNrJGwgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHBvdyQxID0gTWF0aC5wb3c7XG5cbiAgICAvKlxuICAgICAqIEwqIFswLi4xMDBdXG4gICAgICogYSBbLTEwMC4uMTAwXVxuICAgICAqIGIgWy0xMDAuLjEwMF1cbiAgICAgKi9cbiAgICB2YXIgbGFiMnJnYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICBhcmdzID0gdW5wYWNrJGwoYXJncywgJ2xhYicpO1xuICAgICAgICB2YXIgbCA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBhID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIGIgPSBhcmdzWzJdO1xuICAgICAgICB2YXIgeCx5LHosIHIsZyxiXztcblxuICAgICAgICB5ID0gKGwgKyAxNikgLyAxMTY7XG4gICAgICAgIHggPSBpc05hTihhKSA/IHkgOiB5ICsgYSAvIDUwMDtcbiAgICAgICAgeiA9IGlzTmFOKGIpID8geSA6IHkgLSBiIC8gMjAwO1xuXG4gICAgICAgIHkgPSBsYWJDb25zdGFudHMuWW4gKiBsYWJfeHl6KHkpO1xuICAgICAgICB4ID0gbGFiQ29uc3RhbnRzLlhuICogbGFiX3h5eih4KTtcbiAgICAgICAgeiA9IGxhYkNvbnN0YW50cy5abiAqIGxhYl94eXooeik7XG5cbiAgICAgICAgciA9IHh5el9yZ2IoMy4yNDA0NTQyICogeCAtIDEuNTM3MTM4NSAqIHkgLSAwLjQ5ODUzMTQgKiB6KTsgIC8vIEQ2NSAtPiBzUkdCXG4gICAgICAgIGcgPSB4eXpfcmdiKC0wLjk2OTI2NjAgKiB4ICsgMS44NzYwMTA4ICogeSArIDAuMDQxNTU2MCAqIHopO1xuICAgICAgICBiXyA9IHh5el9yZ2IoMC4wNTU2NDM0ICogeCAtIDAuMjA0MDI1OSAqIHkgKyAxLjA1NzIyNTIgKiB6KTtcblxuICAgICAgICByZXR1cm4gW3IsZyxiXyxhcmdzLmxlbmd0aCA+IDMgPyBhcmdzWzNdIDogMV07XG4gICAgfTtcblxuICAgIHZhciB4eXpfcmdiID0gZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgcmV0dXJuIDI1NSAqIChyIDw9IDAuMDAzMDQgPyAxMi45MiAqIHIgOiAxLjA1NSAqIHBvdyQxKHIsIDEgLyAyLjQpIC0gMC4wNTUpXG4gICAgfTtcblxuICAgIHZhciBsYWJfeHl6ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPiBsYWJDb25zdGFudHMudDEgPyB0ICogdCAqIHQgOiBsYWJDb25zdGFudHMudDIgKiAodCAtIGxhYkNvbnN0YW50cy50MClcbiAgICB9O1xuXG4gICAgdmFyIGxhYjJyZ2JfMSA9IGxhYjJyZ2I7XG5cbiAgICB2YXIgdW5wYWNrJG0gPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHR5cGUkOSA9IHV0aWxzLnR5cGU7XG5cblxuXG5cblxuXG4gICAgQ29sb3JfMS5wcm90b3R5cGUubGFiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZ2IybGFiXzEodGhpcy5fcmdiKTtcbiAgICB9O1xuXG4gICAgY2hyb21hXzEubGFiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvcl8xLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnbGFiJ10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dC5mb3JtYXQubGFiID0gbGFiMnJnYl8xO1xuXG4gICAgaW5wdXQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogMixcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgIGFyZ3MgPSB1bnBhY2skbShhcmdzLCAnbGFiJyk7XG4gICAgICAgICAgICBpZiAodHlwZSQ5KGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdsYWInO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgdW5wYWNrJG4gPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIFJBRDJERUcgPSB1dGlscy5SQUQyREVHO1xuICAgIHZhciBzcXJ0JDEgPSBNYXRoLnNxcnQ7XG4gICAgdmFyIGF0YW4yID0gTWF0aC5hdGFuMjtcbiAgICB2YXIgcm91bmQkNCA9IE1hdGgucm91bmQ7XG5cbiAgICB2YXIgbGFiMmxjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgcmVmID0gdW5wYWNrJG4oYXJncywgJ2xhYicpO1xuICAgICAgICB2YXIgbCA9IHJlZlswXTtcbiAgICAgICAgdmFyIGEgPSByZWZbMV07XG4gICAgICAgIHZhciBiID0gcmVmWzJdO1xuICAgICAgICB2YXIgYyA9IHNxcnQkMShhICogYSArIGIgKiBiKTtcbiAgICAgICAgdmFyIGggPSAoYXRhbjIoYiwgYSkgKiBSQUQyREVHICsgMzYwKSAlIDM2MDtcbiAgICAgICAgaWYgKHJvdW5kJDQoYyoxMDAwMCkgPT09IDApIHsgaCA9IE51bWJlci5OYU47IH1cbiAgICAgICAgcmV0dXJuIFtsLCBjLCBoXTtcbiAgICB9O1xuXG4gICAgdmFyIGxhYjJsY2hfMSA9IGxhYjJsY2g7XG5cbiAgICB2YXIgdW5wYWNrJG8gPSB1dGlscy51bnBhY2s7XG5cblxuXG4gICAgdmFyIHJnYjJsY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIHJlZiA9IHVucGFjayRvKGFyZ3MsICdyZ2InKTtcbiAgICAgICAgdmFyIHIgPSByZWZbMF07XG4gICAgICAgIHZhciBnID0gcmVmWzFdO1xuICAgICAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICAgICAgdmFyIHJlZiQxID0gcmdiMmxhYl8xKHIsZyxiKTtcbiAgICAgICAgdmFyIGwgPSByZWYkMVswXTtcbiAgICAgICAgdmFyIGEgPSByZWYkMVsxXTtcbiAgICAgICAgdmFyIGJfID0gcmVmJDFbMl07XG4gICAgICAgIHJldHVybiBsYWIybGNoXzEobCxhLGJfKTtcbiAgICB9O1xuXG4gICAgdmFyIHJnYjJsY2hfMSA9IHJnYjJsY2g7XG5cbiAgICB2YXIgdW5wYWNrJHAgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIERFRzJSQUQgPSB1dGlscy5ERUcyUkFEO1xuICAgIHZhciBzaW4gPSBNYXRoLnNpbjtcbiAgICB2YXIgY29zJDEgPSBNYXRoLmNvcztcblxuICAgIHZhciBsY2gybGFiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIC8qXG4gICAgICAgIENvbnZlcnQgZnJvbSBhIHF1YWxpdGF0aXZlIHBhcmFtZXRlciBoIGFuZCBhIHF1YW50aXRhdGl2ZSBwYXJhbWV0ZXIgbCB0byBhIDI0LWJpdCBwaXhlbC5cbiAgICAgICAgVGhlc2UgZm9ybXVsYXMgd2VyZSBpbnZlbnRlZCBieSBEYXZpZCBEYWxyeW1wbGUgdG8gb2J0YWluIG1heGltdW0gY29udHJhc3Qgd2l0aG91dCBnb2luZ1xuICAgICAgICBvdXQgb2YgZ2FtdXQgaWYgdGhlIHBhcmFtZXRlcnMgYXJlIGluIHRoZSByYW5nZSAwLTEuXG5cbiAgICAgICAgQSBzYXR1cmF0aW9uIG11bHRpcGxpZXIgd2FzIGFkZGVkIGJ5IEdyZWdvciBBaXNjaFxuICAgICAgICAqL1xuICAgICAgICB2YXIgcmVmID0gdW5wYWNrJHAoYXJncywgJ2xjaCcpO1xuICAgICAgICB2YXIgbCA9IHJlZlswXTtcbiAgICAgICAgdmFyIGMgPSByZWZbMV07XG4gICAgICAgIHZhciBoID0gcmVmWzJdO1xuICAgICAgICBpZiAoaXNOYU4oaCkpIHsgaCA9IDA7IH1cbiAgICAgICAgaCA9IGggKiBERUcyUkFEO1xuICAgICAgICByZXR1cm4gW2wsIGNvcyQxKGgpICogYywgc2luKGgpICogY11cbiAgICB9O1xuXG4gICAgdmFyIGxjaDJsYWJfMSA9IGxjaDJsYWI7XG5cbiAgICB2YXIgdW5wYWNrJHEgPSB1dGlscy51bnBhY2s7XG5cblxuXG4gICAgdmFyIGxjaDJyZ2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgYXJncyA9IHVucGFjayRxKGFyZ3MsICdsY2gnKTtcbiAgICAgICAgdmFyIGwgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgYyA9IGFyZ3NbMV07XG4gICAgICAgIHZhciBoID0gYXJnc1syXTtcbiAgICAgICAgdmFyIHJlZiA9IGxjaDJsYWJfMSAobCxjLGgpO1xuICAgICAgICB2YXIgTCA9IHJlZlswXTtcbiAgICAgICAgdmFyIGEgPSByZWZbMV07XG4gICAgICAgIHZhciBiXyA9IHJlZlsyXTtcbiAgICAgICAgdmFyIHJlZiQxID0gbGFiMnJnYl8xIChMLGEsYl8pO1xuICAgICAgICB2YXIgciA9IHJlZiQxWzBdO1xuICAgICAgICB2YXIgZyA9IHJlZiQxWzFdO1xuICAgICAgICB2YXIgYiA9IHJlZiQxWzJdO1xuICAgICAgICByZXR1cm4gW3IsIGcsIGIsIGFyZ3MubGVuZ3RoID4gMyA/IGFyZ3NbM10gOiAxXTtcbiAgICB9O1xuXG4gICAgdmFyIGxjaDJyZ2JfMSA9IGxjaDJyZ2I7XG5cbiAgICB2YXIgdW5wYWNrJHIgPSB1dGlscy51bnBhY2s7XG5cblxuICAgIHZhciBoY2wycmdiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciBoY2wgPSB1bnBhY2skcihhcmdzLCAnaGNsJykucmV2ZXJzZSgpO1xuICAgICAgICByZXR1cm4gbGNoMnJnYl8xLmFwcGx5KHZvaWQgMCwgaGNsKTtcbiAgICB9O1xuXG4gICAgdmFyIGhjbDJyZ2JfMSA9IGhjbDJyZ2I7XG5cbiAgICB2YXIgdW5wYWNrJHMgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHR5cGUkYSA9IHV0aWxzLnR5cGU7XG5cblxuXG5cblxuXG4gICAgQ29sb3JfMS5wcm90b3R5cGUubGNoID0gZnVuY3Rpb24oKSB7IHJldHVybiByZ2IybGNoXzEodGhpcy5fcmdiKTsgfTtcbiAgICBDb2xvcl8xLnByb3RvdHlwZS5oY2wgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHJnYjJsY2hfMSh0aGlzLl9yZ2IpLnJldmVyc2UoKTsgfTtcblxuICAgIGNocm9tYV8xLmxjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3JfMSwgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ2xjaCddKSApKTtcbiAgICB9O1xuICAgIGNocm9tYV8xLmhjbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3JfMSwgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ2hjbCddKSApKTtcbiAgICB9O1xuXG4gICAgaW5wdXQuZm9ybWF0LmxjaCA9IGxjaDJyZ2JfMTtcbiAgICBpbnB1dC5mb3JtYXQuaGNsID0gaGNsMnJnYl8xO1xuXG4gICAgWydsY2gnLCdoY2wnXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7IHJldHVybiBpbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICBwOiAyLFxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICAgICAgYXJncyA9IHVucGFjayRzKGFyZ3MsIG0pO1xuICAgICAgICAgICAgaWYgKHR5cGUkYShhcmdzKSA9PT0gJ2FycmF5JyAmJiBhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7IH0pO1xuXG4gICAgLyoqXG4gICAgXHRYMTEgY29sb3IgbmFtZXNcblxuICAgIFx0aHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8jc3ZnLWNvbG9yXG4gICAgKi9cblxuICAgIHZhciB3M2N4MTEgPSB7XG4gICAgICAgIGFsaWNlYmx1ZTogJyNmMGY4ZmYnLFxuICAgICAgICBhbnRpcXVld2hpdGU6ICcjZmFlYmQ3JyxcbiAgICAgICAgYXF1YTogJyMwMGZmZmYnLFxuICAgICAgICBhcXVhbWFyaW5lOiAnIzdmZmZkNCcsXG4gICAgICAgIGF6dXJlOiAnI2YwZmZmZicsXG4gICAgICAgIGJlaWdlOiAnI2Y1ZjVkYycsXG4gICAgICAgIGJpc3F1ZTogJyNmZmU0YzQnLFxuICAgICAgICBibGFjazogJyMwMDAwMDAnLFxuICAgICAgICBibGFuY2hlZGFsbW9uZDogJyNmZmViY2QnLFxuICAgICAgICBibHVlOiAnIzAwMDBmZicsXG4gICAgICAgIGJsdWV2aW9sZXQ6ICcjOGEyYmUyJyxcbiAgICAgICAgYnJvd246ICcjYTUyYTJhJyxcbiAgICAgICAgYnVybHl3b29kOiAnI2RlYjg4NycsXG4gICAgICAgIGNhZGV0Ymx1ZTogJyM1ZjllYTAnLFxuICAgICAgICBjaGFydHJldXNlOiAnIzdmZmYwMCcsXG4gICAgICAgIGNob2NvbGF0ZTogJyNkMjY5MWUnLFxuICAgICAgICBjb3JhbDogJyNmZjdmNTAnLFxuICAgICAgICBjb3JuZmxvd2VyOiAnIzY0OTVlZCcsXG4gICAgICAgIGNvcm5mbG93ZXJibHVlOiAnIzY0OTVlZCcsXG4gICAgICAgIGNvcm5zaWxrOiAnI2ZmZjhkYycsXG4gICAgICAgIGNyaW1zb246ICcjZGMxNDNjJyxcbiAgICAgICAgY3lhbjogJyMwMGZmZmYnLFxuICAgICAgICBkYXJrYmx1ZTogJyMwMDAwOGInLFxuICAgICAgICBkYXJrY3lhbjogJyMwMDhiOGInLFxuICAgICAgICBkYXJrZ29sZGVucm9kOiAnI2I4ODYwYicsXG4gICAgICAgIGRhcmtncmF5OiAnI2E5YTlhOScsXG4gICAgICAgIGRhcmtncmVlbjogJyMwMDY0MDAnLFxuICAgICAgICBkYXJrZ3JleTogJyNhOWE5YTknLFxuICAgICAgICBkYXJra2hha2k6ICcjYmRiNzZiJyxcbiAgICAgICAgZGFya21hZ2VudGE6ICcjOGIwMDhiJyxcbiAgICAgICAgZGFya29saXZlZ3JlZW46ICcjNTU2YjJmJyxcbiAgICAgICAgZGFya29yYW5nZTogJyNmZjhjMDAnLFxuICAgICAgICBkYXJrb3JjaGlkOiAnIzk5MzJjYycsXG4gICAgICAgIGRhcmtyZWQ6ICcjOGIwMDAwJyxcbiAgICAgICAgZGFya3NhbG1vbjogJyNlOTk2N2EnLFxuICAgICAgICBkYXJrc2VhZ3JlZW46ICcjOGZiYzhmJyxcbiAgICAgICAgZGFya3NsYXRlYmx1ZTogJyM0ODNkOGInLFxuICAgICAgICBkYXJrc2xhdGVncmF5OiAnIzJmNGY0ZicsXG4gICAgICAgIGRhcmtzbGF0ZWdyZXk6ICcjMmY0ZjRmJyxcbiAgICAgICAgZGFya3R1cnF1b2lzZTogJyMwMGNlZDEnLFxuICAgICAgICBkYXJrdmlvbGV0OiAnIzk0MDBkMycsXG4gICAgICAgIGRlZXBwaW5rOiAnI2ZmMTQ5MycsXG4gICAgICAgIGRlZXBza3libHVlOiAnIzAwYmZmZicsXG4gICAgICAgIGRpbWdyYXk6ICcjNjk2OTY5JyxcbiAgICAgICAgZGltZ3JleTogJyM2OTY5NjknLFxuICAgICAgICBkb2RnZXJibHVlOiAnIzFlOTBmZicsXG4gICAgICAgIGZpcmVicmljazogJyNiMjIyMjInLFxuICAgICAgICBmbG9yYWx3aGl0ZTogJyNmZmZhZjAnLFxuICAgICAgICBmb3Jlc3RncmVlbjogJyMyMjhiMjInLFxuICAgICAgICBmdWNoc2lhOiAnI2ZmMDBmZicsXG4gICAgICAgIGdhaW5zYm9ybzogJyNkY2RjZGMnLFxuICAgICAgICBnaG9zdHdoaXRlOiAnI2Y4ZjhmZicsXG4gICAgICAgIGdvbGQ6ICcjZmZkNzAwJyxcbiAgICAgICAgZ29sZGVucm9kOiAnI2RhYTUyMCcsXG4gICAgICAgIGdyYXk6ICcjODA4MDgwJyxcbiAgICAgICAgZ3JlZW46ICcjMDA4MDAwJyxcbiAgICAgICAgZ3JlZW55ZWxsb3c6ICcjYWRmZjJmJyxcbiAgICAgICAgZ3JleTogJyM4MDgwODAnLFxuICAgICAgICBob25leWRldzogJyNmMGZmZjAnLFxuICAgICAgICBob3RwaW5rOiAnI2ZmNjliNCcsXG4gICAgICAgIGluZGlhbnJlZDogJyNjZDVjNWMnLFxuICAgICAgICBpbmRpZ286ICcjNGIwMDgyJyxcbiAgICAgICAgaXZvcnk6ICcjZmZmZmYwJyxcbiAgICAgICAga2hha2k6ICcjZjBlNjhjJyxcbiAgICAgICAgbGFzZXJsZW1vbjogJyNmZmZmNTQnLFxuICAgICAgICBsYXZlbmRlcjogJyNlNmU2ZmEnLFxuICAgICAgICBsYXZlbmRlcmJsdXNoOiAnI2ZmZjBmNScsXG4gICAgICAgIGxhd25ncmVlbjogJyM3Y2ZjMDAnLFxuICAgICAgICBsZW1vbmNoaWZmb246ICcjZmZmYWNkJyxcbiAgICAgICAgbGlnaHRibHVlOiAnI2FkZDhlNicsXG4gICAgICAgIGxpZ2h0Y29yYWw6ICcjZjA4MDgwJyxcbiAgICAgICAgbGlnaHRjeWFuOiAnI2UwZmZmZicsXG4gICAgICAgIGxpZ2h0Z29sZGVucm9kOiAnI2ZhZmFkMicsXG4gICAgICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiAnI2ZhZmFkMicsXG4gICAgICAgIGxpZ2h0Z3JheTogJyNkM2QzZDMnLFxuICAgICAgICBsaWdodGdyZWVuOiAnIzkwZWU5MCcsXG4gICAgICAgIGxpZ2h0Z3JleTogJyNkM2QzZDMnLFxuICAgICAgICBsaWdodHBpbms6ICcjZmZiNmMxJyxcbiAgICAgICAgbGlnaHRzYWxtb246ICcjZmZhMDdhJyxcbiAgICAgICAgbGlnaHRzZWFncmVlbjogJyMyMGIyYWEnLFxuICAgICAgICBsaWdodHNreWJsdWU6ICcjODdjZWZhJyxcbiAgICAgICAgbGlnaHRzbGF0ZWdyYXk6ICcjNzc4ODk5JyxcbiAgICAgICAgbGlnaHRzbGF0ZWdyZXk6ICcjNzc4ODk5JyxcbiAgICAgICAgbGlnaHRzdGVlbGJsdWU6ICcjYjBjNGRlJyxcbiAgICAgICAgbGlnaHR5ZWxsb3c6ICcjZmZmZmUwJyxcbiAgICAgICAgbGltZTogJyMwMGZmMDAnLFxuICAgICAgICBsaW1lZ3JlZW46ICcjMzJjZDMyJyxcbiAgICAgICAgbGluZW46ICcjZmFmMGU2JyxcbiAgICAgICAgbWFnZW50YTogJyNmZjAwZmYnLFxuICAgICAgICBtYXJvb246ICcjODAwMDAwJyxcbiAgICAgICAgbWFyb29uMjogJyM3ZjAwMDAnLFxuICAgICAgICBtYXJvb24zOiAnI2IwMzA2MCcsXG4gICAgICAgIG1lZGl1bWFxdWFtYXJpbmU6ICcjNjZjZGFhJyxcbiAgICAgICAgbWVkaXVtYmx1ZTogJyMwMDAwY2QnLFxuICAgICAgICBtZWRpdW1vcmNoaWQ6ICcjYmE1NWQzJyxcbiAgICAgICAgbWVkaXVtcHVycGxlOiAnIzkzNzBkYicsXG4gICAgICAgIG1lZGl1bXNlYWdyZWVuOiAnIzNjYjM3MScsXG4gICAgICAgIG1lZGl1bXNsYXRlYmx1ZTogJyM3YjY4ZWUnLFxuICAgICAgICBtZWRpdW1zcHJpbmdncmVlbjogJyMwMGZhOWEnLFxuICAgICAgICBtZWRpdW10dXJxdW9pc2U6ICcjNDhkMWNjJyxcbiAgICAgICAgbWVkaXVtdmlvbGV0cmVkOiAnI2M3MTU4NScsXG4gICAgICAgIG1pZG5pZ2h0Ymx1ZTogJyMxOTE5NzAnLFxuICAgICAgICBtaW50Y3JlYW06ICcjZjVmZmZhJyxcbiAgICAgICAgbWlzdHlyb3NlOiAnI2ZmZTRlMScsXG4gICAgICAgIG1vY2Nhc2luOiAnI2ZmZTRiNScsXG4gICAgICAgIG5hdmFqb3doaXRlOiAnI2ZmZGVhZCcsXG4gICAgICAgIG5hdnk6ICcjMDAwMDgwJyxcbiAgICAgICAgb2xkbGFjZTogJyNmZGY1ZTYnLFxuICAgICAgICBvbGl2ZTogJyM4MDgwMDAnLFxuICAgICAgICBvbGl2ZWRyYWI6ICcjNmI4ZTIzJyxcbiAgICAgICAgb3JhbmdlOiAnI2ZmYTUwMCcsXG4gICAgICAgIG9yYW5nZXJlZDogJyNmZjQ1MDAnLFxuICAgICAgICBvcmNoaWQ6ICcjZGE3MGQ2JyxcbiAgICAgICAgcGFsZWdvbGRlbnJvZDogJyNlZWU4YWEnLFxuICAgICAgICBwYWxlZ3JlZW46ICcjOThmYjk4JyxcbiAgICAgICAgcGFsZXR1cnF1b2lzZTogJyNhZmVlZWUnLFxuICAgICAgICBwYWxldmlvbGV0cmVkOiAnI2RiNzA5MycsXG4gICAgICAgIHBhcGF5YXdoaXA6ICcjZmZlZmQ1JyxcbiAgICAgICAgcGVhY2hwdWZmOiAnI2ZmZGFiOScsXG4gICAgICAgIHBlcnU6ICcjY2Q4NTNmJyxcbiAgICAgICAgcGluazogJyNmZmMwY2InLFxuICAgICAgICBwbHVtOiAnI2RkYTBkZCcsXG4gICAgICAgIHBvd2RlcmJsdWU6ICcjYjBlMGU2JyxcbiAgICAgICAgcHVycGxlOiAnIzgwMDA4MCcsXG4gICAgICAgIHB1cnBsZTI6ICcjN2YwMDdmJyxcbiAgICAgICAgcHVycGxlMzogJyNhMDIwZjAnLFxuICAgICAgICByZWJlY2NhcHVycGxlOiAnIzY2MzM5OScsXG4gICAgICAgIHJlZDogJyNmZjAwMDAnLFxuICAgICAgICByb3N5YnJvd246ICcjYmM4ZjhmJyxcbiAgICAgICAgcm95YWxibHVlOiAnIzQxNjllMScsXG4gICAgICAgIHNhZGRsZWJyb3duOiAnIzhiNDUxMycsXG4gICAgICAgIHNhbG1vbjogJyNmYTgwNzInLFxuICAgICAgICBzYW5keWJyb3duOiAnI2Y0YTQ2MCcsXG4gICAgICAgIHNlYWdyZWVuOiAnIzJlOGI1NycsXG4gICAgICAgIHNlYXNoZWxsOiAnI2ZmZjVlZScsXG4gICAgICAgIHNpZW5uYTogJyNhMDUyMmQnLFxuICAgICAgICBzaWx2ZXI6ICcjYzBjMGMwJyxcbiAgICAgICAgc2t5Ymx1ZTogJyM4N2NlZWInLFxuICAgICAgICBzbGF0ZWJsdWU6ICcjNmE1YWNkJyxcbiAgICAgICAgc2xhdGVncmF5OiAnIzcwODA5MCcsXG4gICAgICAgIHNsYXRlZ3JleTogJyM3MDgwOTAnLFxuICAgICAgICBzbm93OiAnI2ZmZmFmYScsXG4gICAgICAgIHNwcmluZ2dyZWVuOiAnIzAwZmY3ZicsXG4gICAgICAgIHN0ZWVsYmx1ZTogJyM0NjgyYjQnLFxuICAgICAgICB0YW46ICcjZDJiNDhjJyxcbiAgICAgICAgdGVhbDogJyMwMDgwODAnLFxuICAgICAgICB0aGlzdGxlOiAnI2Q4YmZkOCcsXG4gICAgICAgIHRvbWF0bzogJyNmZjYzNDcnLFxuICAgICAgICB0dXJxdW9pc2U6ICcjNDBlMGQwJyxcbiAgICAgICAgdmlvbGV0OiAnI2VlODJlZScsXG4gICAgICAgIHdoZWF0OiAnI2Y1ZGViMycsXG4gICAgICAgIHdoaXRlOiAnI2ZmZmZmZicsXG4gICAgICAgIHdoaXRlc21va2U6ICcjZjVmNWY1JyxcbiAgICAgICAgeWVsbG93OiAnI2ZmZmYwMCcsXG4gICAgICAgIHllbGxvd2dyZWVuOiAnIzlhY2QzMidcbiAgICB9O1xuXG4gICAgdmFyIHczY3gxMV8xID0gdzNjeDExO1xuXG4gICAgdmFyIHR5cGUkYiA9IHV0aWxzLnR5cGU7XG5cblxuXG5cblxuICAgIENvbG9yXzEucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhleCA9IHJnYjJoZXhfMSh0aGlzLl9yZ2IsICdyZ2InKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBPYmplY3Qua2V5cyh3M2N4MTFfMSk7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbiA9IGxpc3RbaV07XG5cbiAgICAgICAgICAgIGlmICh3M2N4MTFfMVtuXSA9PT0gaGV4KSB7IHJldHVybiBuLnRvTG93ZXJDYXNlKCk7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4O1xuICAgIH07XG5cbiAgICBpbnB1dC5mb3JtYXQubmFtZWQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAodzNjeDExXzFbbmFtZV0pIHsgcmV0dXJuIGhleDJyZ2JfMSh3M2N4MTFfMVtuYW1lXSk7IH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGNvbG9yIG5hbWU6ICcrbmFtZSk7XG4gICAgfTtcblxuICAgIGlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgICAgIHA6IDUsXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdCA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gPiAwICkgcmVzdFsgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICAgICAgICAgICAgaWYgKCFyZXN0Lmxlbmd0aCAmJiB0eXBlJGIoaCkgPT09ICdzdHJpbmcnICYmIHczY3gxMV8xW2gudG9Mb3dlckNhc2UoKV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25hbWVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHVucGFjayR0ID0gdXRpbHMudW5wYWNrO1xuXG4gICAgdmFyIHJnYjJudW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIHJlZiA9IHVucGFjayR0KGFyZ3MsICdyZ2InKTtcbiAgICAgICAgdmFyIHIgPSByZWZbMF07XG4gICAgICAgIHZhciBnID0gcmVmWzFdO1xuICAgICAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICAgICAgcmV0dXJuIChyIDw8IDE2KSArIChnIDw8IDgpICsgYjtcbiAgICB9O1xuXG4gICAgdmFyIHJnYjJudW1fMSA9IHJnYjJudW07XG5cbiAgICB2YXIgdHlwZSRjID0gdXRpbHMudHlwZTtcblxuICAgIHZhciBudW0ycmdiID0gZnVuY3Rpb24gKG51bSkge1xuICAgICAgICBpZiAodHlwZSRjKG51bSkgPT0gXCJudW1iZXJcIiAmJiBudW0gPj0gMCAmJiBudW0gPD0gMHhGRkZGRkYpIHtcbiAgICAgICAgICAgIHZhciByID0gbnVtID4+IDE2O1xuICAgICAgICAgICAgdmFyIGcgPSAobnVtID4+IDgpICYgMHhGRjtcbiAgICAgICAgICAgIHZhciBiID0gbnVtICYgMHhGRjtcbiAgICAgICAgICAgIHJldHVybiBbcixnLGIsMV07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBudW0gY29sb3I6IFwiK251bSk7XG4gICAgfTtcblxuICAgIHZhciBudW0ycmdiXzEgPSBudW0ycmdiO1xuXG4gICAgdmFyIHR5cGUkZCA9IHV0aWxzLnR5cGU7XG5cblxuXG4gICAgQ29sb3JfMS5wcm90b3R5cGUubnVtID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZ2IybnVtXzEodGhpcy5fcmdiKTtcbiAgICB9O1xuXG4gICAgY2hyb21hXzEubnVtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvcl8xLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnbnVtJ10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dC5mb3JtYXQubnVtID0gbnVtMnJnYl8xO1xuXG4gICAgaW5wdXQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogNSxcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlJGQoYXJnc1swXSkgPT09ICdudW1iZXInICYmIGFyZ3NbMF0gPj0gMCAmJiBhcmdzWzBdIDw9IDB4RkZGRkZGKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdudW0nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgdW5wYWNrJHUgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHR5cGUkZSA9IHV0aWxzLnR5cGU7XG4gICAgdmFyIHJvdW5kJDUgPSBNYXRoLnJvdW5kO1xuXG4gICAgQ29sb3JfMS5wcm90b3R5cGUucmdiID0gZnVuY3Rpb24ocm5kKSB7XG4gICAgICAgIGlmICggcm5kID09PSB2b2lkIDAgKSBybmQ9dHJ1ZTtcblxuICAgICAgICBpZiAocm5kID09PSBmYWxzZSkgeyByZXR1cm4gdGhpcy5fcmdiLnNsaWNlKDAsMyk7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JnYi5zbGljZSgwLDMpLm1hcChyb3VuZCQ1KTtcbiAgICB9O1xuXG4gICAgQ29sb3JfMS5wcm90b3R5cGUucmdiYSA9IGZ1bmN0aW9uKHJuZCkge1xuICAgICAgICBpZiAoIHJuZCA9PT0gdm9pZCAwICkgcm5kPXRydWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JnYi5zbGljZSgwLDQpLm1hcChmdW5jdGlvbiAodixpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTwzID8gKHJuZCA9PT0gZmFsc2UgPyB2IDogcm91bmQkNSh2KSkgOiB2O1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgY2hyb21hXzEucmdiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvcl8xLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsncmdiJ10pICkpO1xuICAgIH07XG5cbiAgICBpbnB1dC5mb3JtYXQucmdiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciByZ2JhID0gdW5wYWNrJHUoYXJncywgJ3JnYmEnKTtcbiAgICAgICAgaWYgKHJnYmFbM10gPT09IHVuZGVmaW5lZCkgeyByZ2JhWzNdID0gMTsgfVxuICAgICAgICByZXR1cm4gcmdiYTtcbiAgICB9O1xuXG4gICAgaW5wdXQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogMyxcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgIGFyZ3MgPSB1bnBhY2skdShhcmdzLCAncmdiYScpO1xuICAgICAgICAgICAgaWYgKHR5cGUkZShhcmdzKSA9PT0gJ2FycmF5JyAmJiAoYXJncy5sZW5ndGggPT09IDMgfHxcbiAgICAgICAgICAgICAgICBhcmdzLmxlbmd0aCA9PT0gNCAmJiB0eXBlJGUoYXJnc1szXSkgPT0gJ251bWJlcicgJiYgYXJnc1szXSA+PSAwICYmIGFyZ3NbM10gPD0gMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3JnYic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qXG4gICAgICogQmFzZWQgb24gaW1wbGVtZW50YXRpb24gYnkgTmVpbCBCYXJ0bGV0dFxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uZWlsYmFydGxldHQvY29sb3ItdGVtcGVyYXR1cmVcbiAgICAgKi9cblxuICAgIHZhciBsb2cgPSBNYXRoLmxvZztcblxuICAgIHZhciB0ZW1wZXJhdHVyZTJyZ2IgPSBmdW5jdGlvbiAoa2VsdmluKSB7XG4gICAgICAgIHZhciB0ZW1wID0ga2VsdmluIC8gMTAwO1xuICAgICAgICB2YXIgcixnLGI7XG4gICAgICAgIGlmICh0ZW1wIDwgNjYpIHtcbiAgICAgICAgICAgIHIgPSAyNTU7XG4gICAgICAgICAgICBnID0gLTE1NS4yNTQ4NTU2MjcwOTE3OSAtIDAuNDQ1OTY5NTA0Njk1NzkxMzMgKiAoZyA9IHRlbXAtMikgKyAxMDQuNDkyMTYxOTkzOTM4ODggKiBsb2coZyk7XG4gICAgICAgICAgICBiID0gdGVtcCA8IDIwID8gMCA6IC0yNTQuNzY5MzUxODQxMjA5MDIgKyAwLjgyNzQwOTYwNjQwMDczOTUgKiAoYiA9IHRlbXAtMTApICsgMTE1LjY3OTk0NDAxMDY2MTQ3ICogbG9nKGIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgciA9IDM1MS45NzY5MDU2NjgwNTY5MyArIDAuMTE0MjA2NDUzNzg0MTY1ICogKHIgPSB0ZW1wLTU1KSAtIDQwLjI1MzY2MzA5MzMyMTI3ICogbG9nKHIpO1xuICAgICAgICAgICAgZyA9IDMyNS40NDk0MTI1NzExOTc0ICsgMC4wNzk0MzQ1NjUzNjY2MjM0MiAqIChnID0gdGVtcC01MCkgLSAyOC4wODUyOTYzNTA3OTU3ICogbG9nKGcpO1xuICAgICAgICAgICAgYiA9IDI1NTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3IsZyxiLDFdO1xuICAgIH07XG5cbiAgICB2YXIgdGVtcGVyYXR1cmUycmdiXzEgPSB0ZW1wZXJhdHVyZTJyZ2I7XG5cbiAgICAvKlxuICAgICAqIEJhc2VkIG9uIGltcGxlbWVudGF0aW9uIGJ5IE5laWwgQmFydGxldHRcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbmVpbGJhcnRsZXR0L2NvbG9yLXRlbXBlcmF0dXJlXG4gICAgICoqL1xuXG5cbiAgICB2YXIgdW5wYWNrJHYgPSB1dGlscy51bnBhY2s7XG4gICAgdmFyIHJvdW5kJDYgPSBNYXRoLnJvdW5kO1xuXG4gICAgdmFyIHJnYjJ0ZW1wZXJhdHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgcmdiID0gdW5wYWNrJHYoYXJncywgJ3JnYicpO1xuICAgICAgICB2YXIgciA9IHJnYlswXSwgYiA9IHJnYlsyXTtcbiAgICAgICAgdmFyIG1pblRlbXAgPSAxMDAwO1xuICAgICAgICB2YXIgbWF4VGVtcCA9IDQwMDAwO1xuICAgICAgICB2YXIgZXBzID0gMC40O1xuICAgICAgICB2YXIgdGVtcDtcbiAgICAgICAgd2hpbGUgKG1heFRlbXAgLSBtaW5UZW1wID4gZXBzKSB7XG4gICAgICAgICAgICB0ZW1wID0gKG1heFRlbXAgKyBtaW5UZW1wKSAqIDAuNTtcbiAgICAgICAgICAgIHZhciByZ2IkMSA9IHRlbXBlcmF0dXJlMnJnYl8xKHRlbXApO1xuICAgICAgICAgICAgaWYgKChyZ2IkMVsyXSAvIHJnYiQxWzBdKSA+PSAoYiAvIHIpKSB7XG4gICAgICAgICAgICAgICAgbWF4VGVtcCA9IHRlbXA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1pblRlbXAgPSB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3VuZCQ2KHRlbXApO1xuICAgIH07XG5cbiAgICB2YXIgcmdiMnRlbXBlcmF0dXJlXzEgPSByZ2IydGVtcGVyYXR1cmU7XG5cbiAgICBDb2xvcl8xLnByb3RvdHlwZS50ZW1wID1cbiAgICBDb2xvcl8xLnByb3RvdHlwZS5rZWx2aW4gPVxuICAgIENvbG9yXzEucHJvdG90eXBlLnRlbXBlcmF0dXJlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZ2IydGVtcGVyYXR1cmVfMSh0aGlzLl9yZ2IpO1xuICAgIH07XG5cbiAgICBjaHJvbWFfMS50ZW1wID1cbiAgICBjaHJvbWFfMS5rZWx2aW4gPVxuICAgIGNocm9tYV8xLnRlbXBlcmF0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvcl8xLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsndGVtcCddKSApKTtcbiAgICB9O1xuXG4gICAgaW5wdXQuZm9ybWF0LnRlbXAgPVxuICAgIGlucHV0LmZvcm1hdC5rZWx2aW4gPVxuICAgIGlucHV0LmZvcm1hdC50ZW1wZXJhdHVyZSA9IHRlbXBlcmF0dXJlMnJnYl8xO1xuXG4gICAgdmFyIHR5cGUkZiA9IHV0aWxzLnR5cGU7XG5cbiAgICBDb2xvcl8xLnByb3RvdHlwZS5hbHBoYSA9IGZ1bmN0aW9uKGEsIG11dGF0ZSkge1xuICAgICAgICBpZiAoIG11dGF0ZSA9PT0gdm9pZCAwICkgbXV0YXRlPWZhbHNlO1xuXG4gICAgICAgIGlmIChhICE9PSB1bmRlZmluZWQgJiYgdHlwZSRmKGEpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaWYgKG11dGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JnYlszXSA9IGE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yXzEoW3RoaXMuX3JnYlswXSwgdGhpcy5fcmdiWzFdLCB0aGlzLl9yZ2JbMl0sIGFdLCAncmdiJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JnYlszXTtcbiAgICB9O1xuXG4gICAgQ29sb3JfMS5wcm90b3R5cGUuY2xpcHBlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmdiLl9jbGlwcGVkIHx8IGZhbHNlO1xuICAgIH07XG5cbiAgICBDb2xvcl8xLnByb3RvdHlwZS5kYXJrZW4gPSBmdW5jdGlvbihhbW91bnQpIHtcbiAgICBcdGlmICggYW1vdW50ID09PSB2b2lkIDAgKSBhbW91bnQ9MTtcblxuICAgIFx0dmFyIG1lID0gdGhpcztcbiAgICBcdHZhciBsYWIgPSBtZS5sYWIoKTtcbiAgICBcdGxhYlswXSAtPSBsYWJDb25zdGFudHMuS24gKiBhbW91bnQ7XG4gICAgXHRyZXR1cm4gbmV3IENvbG9yXzEobGFiLCAnbGFiJykuYWxwaGEobWUuYWxwaGEoKSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIENvbG9yXzEucHJvdG90eXBlLmJyaWdodGVuID0gZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgXHRpZiAoIGFtb3VudCA9PT0gdm9pZCAwICkgYW1vdW50PTE7XG5cbiAgICBcdHJldHVybiB0aGlzLmRhcmtlbigtYW1vdW50KTtcbiAgICB9O1xuXG4gICAgQ29sb3JfMS5wcm90b3R5cGUuZGFya2VyID0gQ29sb3JfMS5wcm90b3R5cGUuZGFya2VuO1xuICAgIENvbG9yXzEucHJvdG90eXBlLmJyaWdodGVyID0gQ29sb3JfMS5wcm90b3R5cGUuYnJpZ2h0ZW47XG5cbiAgICBDb2xvcl8xLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihtYykge1xuICAgICAgICB2YXIgcmVmID0gbWMuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIG1vZGUgPSByZWZbMF07XG4gICAgICAgIHZhciBjaGFubmVsID0gcmVmWzFdO1xuICAgICAgICB2YXIgc3JjID0gdGhpc1ttb2RlXSgpO1xuICAgICAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICAgICAgdmFyIGkgPSBtb2RlLmluZGV4T2YoY2hhbm5lbCk7XG4gICAgICAgICAgICBpZiAoaSA+IC0xKSB7IHJldHVybiBzcmNbaV07IH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoXCJ1bmtub3duIGNoYW5uZWwgXCIgKyBjaGFubmVsICsgXCIgaW4gbW9kZSBcIiArIG1vZGUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzcmM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHR5cGUkZyA9IHV0aWxzLnR5cGU7XG4gICAgdmFyIHBvdyQyID0gTWF0aC5wb3c7XG5cbiAgICB2YXIgRVBTID0gMWUtNztcbiAgICB2YXIgTUFYX0lURVIgPSAyMDtcblxuICAgIENvbG9yXzEucHJvdG90eXBlLmx1bWluYW5jZSA9IGZ1bmN0aW9uKGx1bSkge1xuICAgICAgICBpZiAobHVtICE9PSB1bmRlZmluZWQgJiYgdHlwZSRnKGx1bSkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAobHVtID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHB1cmUgYmxhY2tcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yXzEoWzAsMCwwLHRoaXMuX3JnYlszXV0sICdyZ2InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsdW0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gcHVyZSB3aGl0ZVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3JfMShbMjU1LDI1NSwyNTUsdGhpcy5fcmdiWzNdXSwgJ3JnYicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29tcHV0ZSBuZXcgY29sb3IgdXNpbmcuLi5cbiAgICAgICAgICAgIHZhciBjdXJfbHVtID0gdGhpcy5sdW1pbmFuY2UoKTtcbiAgICAgICAgICAgIHZhciBtb2RlID0gJ3JnYic7XG4gICAgICAgICAgICB2YXIgbWF4X2l0ZXIgPSBNQVhfSVRFUjtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBmdW5jdGlvbiAobG93LCBoaWdoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pZCA9IGxvdy5pbnRlcnBvbGF0ZShoaWdoLCAwLjUsIG1vZGUpO1xuICAgICAgICAgICAgICAgIHZhciBsbSA9IG1pZC5sdW1pbmFuY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMobHVtIC0gbG0pIDwgRVBTIHx8ICFtYXhfaXRlci0tKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsb3NlIGVub3VnaFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbG0gPiBsdW0gPyB0ZXN0KGxvdywgbWlkKSA6IHRlc3QobWlkLCBoaWdoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciByZ2IgPSAoY3VyX2x1bSA+IGx1bSA/IHRlc3QobmV3IENvbG9yXzEoWzAsMCwwXSksIHRoaXMpIDogdGVzdCh0aGlzLCBuZXcgQ29sb3JfMShbMjU1LDI1NSwyNTVdKSkpLnJnYigpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcl8xKHJnYi5jb25jYXQoIFt0aGlzLl9yZ2JbM11dKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJnYjJsdW1pbmFuY2UuYXBwbHkodm9pZCAwLCAodGhpcy5fcmdiKS5zbGljZSgwLDMpKTtcbiAgICB9O1xuXG5cbiAgICB2YXIgcmdiMmx1bWluYW5jZSA9IGZ1bmN0aW9uIChyLGcsYikge1xuICAgICAgICAvLyByZWxhdGl2ZSBsdW1pbmFuY2VcbiAgICAgICAgLy8gc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLVdDQUcyMC0yMDA4MTIxMS8jcmVsYXRpdmVsdW1pbmFuY2VkZWZcbiAgICAgICAgciA9IGx1bWluYW5jZV94KHIpO1xuICAgICAgICBnID0gbHVtaW5hbmNlX3goZyk7XG4gICAgICAgIGIgPSBsdW1pbmFuY2VfeChiKTtcbiAgICAgICAgcmV0dXJuIDAuMjEyNiAqIHIgKyAwLjcxNTIgKiBnICsgMC4wNzIyICogYjtcbiAgICB9O1xuXG4gICAgdmFyIGx1bWluYW5jZV94ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgeCAvPSAyNTU7XG4gICAgICAgIHJldHVybiB4IDw9IDAuMDM5MjggPyB4LzEyLjkyIDogcG93JDIoKHgrMC4wNTUpLzEuMDU1LCAyLjQpO1xuICAgIH07XG5cbiAgICB2YXIgaW50ZXJwb2xhdG9yID0ge307XG5cbiAgICB2YXIgdHlwZSRoID0gdXRpbHMudHlwZTtcblxuXG4gICAgdmFyIG1peCA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmKSB7XG4gICAgICAgIGlmICggZiA9PT0gdm9pZCAwICkgZj0wLjU7XG4gICAgICAgIHZhciByZXN0ID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAzO1xuICAgICAgICB3aGlsZSAoIGxlbi0tID4gMCApIHJlc3RbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAzIF07XG5cbiAgICAgICAgdmFyIG1vZGUgPSByZXN0WzBdIHx8ICdscmdiJztcbiAgICAgICAgaWYgKCFpbnRlcnBvbGF0b3JbbW9kZV0gJiYgIXJlc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBmYWxsIGJhY2sgdG8gdGhlIGZpcnN0IHN1cHBvcnRlZCBtb2RlXG4gICAgICAgICAgICBtb2RlID0gT2JqZWN0LmtleXMoaW50ZXJwb2xhdG9yKVswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWludGVycG9sYXRvclttb2RlXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcImludGVycG9sYXRpb24gbW9kZSBcIiArIG1vZGUgKyBcIiBpcyBub3QgZGVmaW5lZFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUkaChjb2wxKSAhPT0gJ29iamVjdCcpIHsgY29sMSA9IG5ldyBDb2xvcl8xKGNvbDEpOyB9XG4gICAgICAgIGlmICh0eXBlJGgoY29sMikgIT09ICdvYmplY3QnKSB7IGNvbDIgPSBuZXcgQ29sb3JfMShjb2wyKTsgfVxuICAgICAgICByZXR1cm4gaW50ZXJwb2xhdG9yW21vZGVdKGNvbDEsIGNvbDIsIGYpXG4gICAgICAgICAgICAuYWxwaGEoY29sMS5hbHBoYSgpICsgZiAqIChjb2wyLmFscGhhKCkgLSBjb2wxLmFscGhhKCkpKTtcbiAgICB9O1xuXG4gICAgQ29sb3JfMS5wcm90b3R5cGUubWl4ID1cbiAgICBDb2xvcl8xLnByb3RvdHlwZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKGNvbDIsIGYpIHtcbiAgICBcdGlmICggZiA9PT0gdm9pZCAwICkgZj0wLjU7XG4gICAgXHR2YXIgcmVzdCA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICBcdHdoaWxlICggbGVuLS0gPiAwICkgcmVzdFsgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDIgXTtcblxuICAgIFx0cmV0dXJuIG1peC5hcHBseSh2b2lkIDAsIFsgdGhpcywgY29sMiwgZiBdLmNvbmNhdCggcmVzdCApKTtcbiAgICB9O1xuXG4gICAgQ29sb3JfMS5wcm90b3R5cGUucHJlbXVsdGlwbHkgPSBmdW5jdGlvbihtdXRhdGUpIHtcbiAgICBcdGlmICggbXV0YXRlID09PSB2b2lkIDAgKSBtdXRhdGU9ZmFsc2U7XG5cbiAgICBcdHZhciByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgXHR2YXIgYSA9IHJnYlszXTtcbiAgICBcdGlmIChtdXRhdGUpIHtcbiAgICBcdFx0dGhpcy5fcmdiID0gW3JnYlswXSphLCByZ2JbMV0qYSwgcmdiWzJdKmEsIGFdO1xuICAgIFx0XHRyZXR1cm4gdGhpcztcbiAgICBcdH0gZWxzZSB7XG4gICAgXHRcdHJldHVybiBuZXcgQ29sb3JfMShbcmdiWzBdKmEsIHJnYlsxXSphLCByZ2JbMl0qYSwgYV0sICdyZ2InKTtcbiAgICBcdH1cbiAgICB9O1xuXG4gICAgQ29sb3JfMS5wcm90b3R5cGUuc2F0dXJhdGUgPSBmdW5jdGlvbihhbW91bnQpIHtcbiAgICBcdGlmICggYW1vdW50ID09PSB2b2lkIDAgKSBhbW91bnQ9MTtcblxuICAgIFx0dmFyIG1lID0gdGhpcztcbiAgICBcdHZhciBsY2ggPSBtZS5sY2goKTtcbiAgICBcdGxjaFsxXSArPSBsYWJDb25zdGFudHMuS24gKiBhbW91bnQ7XG4gICAgXHRpZiAobGNoWzFdIDwgMCkgeyBsY2hbMV0gPSAwOyB9XG4gICAgXHRyZXR1cm4gbmV3IENvbG9yXzEobGNoLCAnbGNoJykuYWxwaGEobWUuYWxwaGEoKSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIENvbG9yXzEucHJvdG90eXBlLmRlc2F0dXJhdGUgPSBmdW5jdGlvbihhbW91bnQpIHtcbiAgICBcdGlmICggYW1vdW50ID09PSB2b2lkIDAgKSBhbW91bnQ9MTtcblxuICAgIFx0cmV0dXJuIHRoaXMuc2F0dXJhdGUoLWFtb3VudCk7XG4gICAgfTtcblxuICAgIHZhciB0eXBlJGkgPSB1dGlscy50eXBlO1xuXG4gICAgQ29sb3JfMS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obWMsIHZhbHVlLCBtdXRhdGUpIHtcbiAgICAgICAgaWYgKCBtdXRhdGUgPT09IHZvaWQgMCApIG11dGF0ZT1mYWxzZTtcblxuICAgICAgICB2YXIgcmVmID0gbWMuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIG1vZGUgPSByZWZbMF07XG4gICAgICAgIHZhciBjaGFubmVsID0gcmVmWzFdO1xuICAgICAgICB2YXIgc3JjID0gdGhpc1ttb2RlXSgpO1xuICAgICAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICAgICAgdmFyIGkgPSBtb2RlLmluZGV4T2YoY2hhbm5lbCk7XG4gICAgICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUkaSh2YWx1ZSkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKHZhbHVlLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKyc6IHNyY1tpXSArPSArdmFsdWU7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnLSc6IHNyY1tpXSArPSArdmFsdWU7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKic6IHNyY1tpXSAqPSArKHZhbHVlLnN1YnN0cigxKSk7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnLyc6IHNyY1tpXSAvPSArKHZhbHVlLnN1YnN0cigxKSk7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogc3JjW2ldID0gK3ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlJGkodmFsdWUpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBzcmNbaV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCB2YWx1ZSBmb3IgQ29sb3Iuc2V0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgb3V0ID0gbmV3IENvbG9yXzEoc3JjLCBtb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobXV0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JnYiA9IG91dC5fcmdiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoXCJ1bmtub3duIGNoYW5uZWwgXCIgKyBjaGFubmVsICsgXCIgaW4gbW9kZSBcIiArIG1vZGUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzcmM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJnYiQxID0gZnVuY3Rpb24gKGNvbDEsIGNvbDIsIGYpIHtcbiAgICAgICAgdmFyIHh5ejAgPSBjb2wxLl9yZ2I7XG4gICAgICAgIHZhciB4eXoxID0gY29sMi5fcmdiO1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yXzEoXG4gICAgICAgICAgICB4eXowWzBdICsgZiAqICh4eXoxWzBdLXh5ejBbMF0pLFxuICAgICAgICAgICAgeHl6MFsxXSArIGYgKiAoeHl6MVsxXS14eXowWzFdKSxcbiAgICAgICAgICAgIHh5ejBbMl0gKyBmICogKHh5ejFbMl0teHl6MFsyXSksXG4gICAgICAgICAgICAncmdiJ1xuICAgICAgICApXG4gICAgfTtcblxuICAgIC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuICAgIGludGVycG9sYXRvci5yZ2IgPSByZ2IkMTtcblxuICAgIHZhciBzcXJ0JDIgPSBNYXRoLnNxcnQ7XG4gICAgdmFyIHBvdyQzID0gTWF0aC5wb3c7XG5cbiAgICB2YXIgbHJnYiA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmKSB7XG4gICAgICAgIHZhciByZWYgPSBjb2wxLl9yZ2I7XG4gICAgICAgIHZhciB4MSA9IHJlZlswXTtcbiAgICAgICAgdmFyIHkxID0gcmVmWzFdO1xuICAgICAgICB2YXIgejEgPSByZWZbMl07XG4gICAgICAgIHZhciByZWYkMSA9IGNvbDIuX3JnYjtcbiAgICAgICAgdmFyIHgyID0gcmVmJDFbMF07XG4gICAgICAgIHZhciB5MiA9IHJlZiQxWzFdO1xuICAgICAgICB2YXIgejIgPSByZWYkMVsyXTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcl8xKFxuICAgICAgICAgICAgc3FydCQyKHBvdyQzKHgxLDIpICogKDEtZikgKyBwb3ckMyh4MiwyKSAqIGYpLFxuICAgICAgICAgICAgc3FydCQyKHBvdyQzKHkxLDIpICogKDEtZikgKyBwb3ckMyh5MiwyKSAqIGYpLFxuICAgICAgICAgICAgc3FydCQyKHBvdyQzKHoxLDIpICogKDEtZikgKyBwb3ckMyh6MiwyKSAqIGYpLFxuICAgICAgICAgICAgJ3JnYidcbiAgICAgICAgKVxuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbnRlcnBvbGF0b3IubHJnYiA9IGxyZ2I7XG5cbiAgICB2YXIgbGFiJDEgPSBmdW5jdGlvbiAoY29sMSwgY29sMiwgZikge1xuICAgICAgICB2YXIgeHl6MCA9IGNvbDEubGFiKCk7XG4gICAgICAgIHZhciB4eXoxID0gY29sMi5sYWIoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcl8xKFxuICAgICAgICAgICAgeHl6MFswXSArIGYgKiAoeHl6MVswXS14eXowWzBdKSxcbiAgICAgICAgICAgIHh5ejBbMV0gKyBmICogKHh5ejFbMV0teHl6MFsxXSksXG4gICAgICAgICAgICB4eXowWzJdICsgZiAqICh4eXoxWzJdLXh5ejBbMl0pLFxuICAgICAgICAgICAgJ2xhYidcbiAgICAgICAgKVxuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbnRlcnBvbGF0b3IubGFiID0gbGFiJDE7XG5cbiAgICB2YXIgX2hzeCA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmLCBtKSB7XG4gICAgICAgIHZhciBhc3NpZ24sIGFzc2lnbiQxO1xuXG4gICAgICAgIHZhciB4eXowLCB4eXoxO1xuICAgICAgICBpZiAobSA9PT0gJ2hzbCcpIHtcbiAgICAgICAgICAgIHh5ejAgPSBjb2wxLmhzbCgpO1xuICAgICAgICAgICAgeHl6MSA9IGNvbDIuaHNsKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobSA9PT0gJ2hzdicpIHtcbiAgICAgICAgICAgIHh5ejAgPSBjb2wxLmhzdigpO1xuICAgICAgICAgICAgeHl6MSA9IGNvbDIuaHN2KCk7XG4gICAgICAgIH0gZWxzZSBpZiAobSA9PT0gJ2hjZycpIHtcbiAgICAgICAgICAgIHh5ejAgPSBjb2wxLmhjZygpO1xuICAgICAgICAgICAgeHl6MSA9IGNvbDIuaGNnKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobSA9PT0gJ2hzaScpIHtcbiAgICAgICAgICAgIHh5ejAgPSBjb2wxLmhzaSgpO1xuICAgICAgICAgICAgeHl6MSA9IGNvbDIuaHNpKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobSA9PT0gJ2xjaCcgfHwgbSA9PT0gJ2hjbCcpIHtcbiAgICAgICAgICAgIG0gPSAnaGNsJztcbiAgICAgICAgICAgIHh5ejAgPSBjb2wxLmhjbCgpO1xuICAgICAgICAgICAgeHl6MSA9IGNvbDIuaGNsKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaHVlMCwgaHVlMSwgc2F0MCwgc2F0MSwgbGJ2MCwgbGJ2MTtcbiAgICAgICAgaWYgKG0uc3Vic3RyKDAsIDEpID09PSAnaCcpIHtcbiAgICAgICAgICAgIChhc3NpZ24gPSB4eXowLCBodWUwID0gYXNzaWduWzBdLCBzYXQwID0gYXNzaWduWzFdLCBsYnYwID0gYXNzaWduWzJdKTtcbiAgICAgICAgICAgIChhc3NpZ24kMSA9IHh5ejEsIGh1ZTEgPSBhc3NpZ24kMVswXSwgc2F0MSA9IGFzc2lnbiQxWzFdLCBsYnYxID0gYXNzaWduJDFbMl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNhdCwgaHVlLCBsYnYsIGRoO1xuXG4gICAgICAgIGlmICghaXNOYU4oaHVlMCkgJiYgIWlzTmFOKGh1ZTEpKSB7XG4gICAgICAgICAgICAvLyBib3RoIGNvbG9ycyBoYXZlIGh1ZVxuICAgICAgICAgICAgaWYgKGh1ZTEgPiBodWUwICYmIGh1ZTEgLSBodWUwID4gMTgwKSB7XG4gICAgICAgICAgICAgICAgZGggPSBodWUxLShodWUwKzM2MCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGh1ZTEgPCBodWUwICYmIGh1ZTAgLSBodWUxID4gMTgwKSB7XG4gICAgICAgICAgICAgICAgZGggPSBodWUxKzM2MC1odWUwO1xuICAgICAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgICAgIGRoID0gaHVlMSAtIGh1ZTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBodWUgPSBodWUwICsgZiAqIGRoO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc05hTihodWUwKSkge1xuICAgICAgICAgICAgaHVlID0gaHVlMDtcbiAgICAgICAgICAgIGlmICgobGJ2MSA9PSAxIHx8IGxidjEgPT0gMCkgJiYgbSAhPSAnaHN2JykgeyBzYXQgPSBzYXQwOyB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzTmFOKGh1ZTEpKSB7XG4gICAgICAgICAgICBodWUgPSBodWUxO1xuICAgICAgICAgICAgaWYgKChsYnYwID09IDEgfHwgbGJ2MCA9PSAwKSAmJiBtICE9ICdoc3YnKSB7IHNhdCA9IHNhdDE7IH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh1ZSA9IE51bWJlci5OYU47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2F0ID09PSB1bmRlZmluZWQpIHsgc2F0ID0gc2F0MCArIGYgKiAoc2F0MSAtIHNhdDApOyB9XG4gICAgICAgIGxidiA9IGxidjAgKyBmICogKGxidjEtbGJ2MCk7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3JfMShbaHVlLCBzYXQsIGxidl0sIG0pO1xuICAgIH07XG5cbiAgICB2YXIgbGNoJDEgPSBmdW5jdGlvbiAoY29sMSwgY29sMiwgZikge1xuICAgIFx0cmV0dXJuIF9oc3goY29sMSwgY29sMiwgZiwgJ2xjaCcpO1xuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbnRlcnBvbGF0b3IubGNoID0gbGNoJDE7XG4gICAgaW50ZXJwb2xhdG9yLmhjbCA9IGxjaCQxO1xuXG4gICAgdmFyIG51bSQxID0gZnVuY3Rpb24gKGNvbDEsIGNvbDIsIGYpIHtcbiAgICAgICAgdmFyIGMxID0gY29sMS5udW0oKTtcbiAgICAgICAgdmFyIGMyID0gY29sMi5udW0oKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcl8xKGMxICsgZiAqIChjMi1jMSksICdudW0nKVxuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbnRlcnBvbGF0b3IubnVtID0gbnVtJDE7XG5cbiAgICB2YXIgaGNnJDEgPSBmdW5jdGlvbiAoY29sMSwgY29sMiwgZikge1xuICAgIFx0cmV0dXJuIF9oc3goY29sMSwgY29sMiwgZiwgJ2hjZycpO1xuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbnRlcnBvbGF0b3IuaGNnID0gaGNnJDE7XG5cbiAgICB2YXIgaHNpJDEgPSBmdW5jdGlvbiAoY29sMSwgY29sMiwgZikge1xuICAgIFx0cmV0dXJuIF9oc3goY29sMSwgY29sMiwgZiwgJ2hzaScpO1xuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbnRlcnBvbGF0b3IuaHNpID0gaHNpJDE7XG5cbiAgICB2YXIgaHNsJDEgPSBmdW5jdGlvbiAoY29sMSwgY29sMiwgZikge1xuICAgIFx0cmV0dXJuIF9oc3goY29sMSwgY29sMiwgZiwgJ2hzbCcpO1xuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbnRlcnBvbGF0b3IuaHNsID0gaHNsJDE7XG5cbiAgICB2YXIgaHN2JDEgPSBmdW5jdGlvbiAoY29sMSwgY29sMiwgZikge1xuICAgIFx0cmV0dXJuIF9oc3goY29sMSwgY29sMiwgZiwgJ2hzdicpO1xuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbnRlcnBvbGF0b3IuaHN2ID0gaHN2JDE7XG5cbiAgICB2YXIgY2xpcF9yZ2IkMiA9IHV0aWxzLmNsaXBfcmdiO1xuICAgIHZhciBwb3ckNCA9IE1hdGgucG93O1xuICAgIHZhciBzcXJ0JDMgPSBNYXRoLnNxcnQ7XG4gICAgdmFyIFBJJDEgPSBNYXRoLlBJO1xuICAgIHZhciBjb3MkMiA9IE1hdGguY29zO1xuICAgIHZhciBzaW4kMSA9IE1hdGguc2luO1xuICAgIHZhciBhdGFuMiQxID0gTWF0aC5hdGFuMjtcblxuICAgIHZhciBhdmVyYWdlID0gZnVuY3Rpb24gKGNvbG9ycywgbW9kZSwgd2VpZ2h0cykge1xuICAgICAgICBpZiAoIG1vZGUgPT09IHZvaWQgMCApIG1vZGU9J2xyZ2InO1xuICAgICAgICBpZiAoIHdlaWdodHMgPT09IHZvaWQgMCApIHdlaWdodHM9bnVsbDtcblxuICAgICAgICB2YXIgbCA9IGNvbG9ycy5sZW5ndGg7XG4gICAgICAgIGlmICghd2VpZ2h0cykgeyB3ZWlnaHRzID0gQXJyYXkuZnJvbShuZXcgQXJyYXkobCkpLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiAxOyB9KTsgfVxuICAgICAgICAvLyBub3JtYWxpemUgd2VpZ2h0c1xuICAgICAgICB2YXIgayA9IGwgLyB3ZWlnaHRzLnJlZHVjZShmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhICsgYjsgfSk7XG4gICAgICAgIHdlaWdodHMuZm9yRWFjaChmdW5jdGlvbiAodyxpKSB7IHdlaWdodHNbaV0gKj0gazsgfSk7XG4gICAgICAgIC8vIGNvbnZlcnQgY29sb3JzIHRvIENvbG9yIG9iamVjdHNcbiAgICAgICAgY29sb3JzID0gY29sb3JzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gbmV3IENvbG9yXzEoYyk7IH0pO1xuICAgICAgICBpZiAobW9kZSA9PT0gJ2xyZ2InKSB7XG4gICAgICAgICAgICByZXR1cm4gX2F2ZXJhZ2VfbHJnYihjb2xvcnMsIHdlaWdodHMpXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpcnN0ID0gY29sb3JzLnNoaWZ0KCk7XG4gICAgICAgIHZhciB4eXogPSBmaXJzdC5nZXQobW9kZSk7XG4gICAgICAgIHZhciBjbnQgPSBbXTtcbiAgICAgICAgdmFyIGR4ID0gMDtcbiAgICAgICAgdmFyIGR5ID0gMDtcbiAgICAgICAgLy8gaW5pdGlhbCBjb2xvclxuICAgICAgICBmb3IgKHZhciBpPTA7IGk8eHl6Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB4eXpbaV0gPSAoeHl6W2ldIHx8IDApICogd2VpZ2h0c1swXTtcbiAgICAgICAgICAgIGNudC5wdXNoKGlzTmFOKHh5eltpXSkgPyAwIDogd2VpZ2h0c1swXSk7XG4gICAgICAgICAgICBpZiAobW9kZS5jaGFyQXQoaSkgPT09ICdoJyAmJiAhaXNOYU4oeHl6W2ldKSkge1xuICAgICAgICAgICAgICAgIHZhciBBID0geHl6W2ldIC8gMTgwICogUEkkMTtcbiAgICAgICAgICAgICAgICBkeCArPSBjb3MkMihBKSAqIHdlaWdodHNbMF07XG4gICAgICAgICAgICAgICAgZHkgKz0gc2luJDEoQSkgKiB3ZWlnaHRzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFscGhhID0gZmlyc3QuYWxwaGEoKSAqIHdlaWdodHNbMF07XG4gICAgICAgIGNvbG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChjLGNpKSB7XG4gICAgICAgICAgICB2YXIgeHl6MiA9IGMuZ2V0KG1vZGUpO1xuICAgICAgICAgICAgYWxwaGEgKz0gYy5hbHBoYSgpICogd2VpZ2h0c1tjaSsxXTtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx4eXoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHh5ejJbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNudFtpXSArPSB3ZWlnaHRzW2NpKzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZS5jaGFyQXQoaSkgPT09ICdoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEEgPSB4eXoyW2ldIC8gMTgwICogUEkkMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR4ICs9IGNvcyQyKEEpICogd2VpZ2h0c1tjaSsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5ICs9IHNpbiQxKEEpICogd2VpZ2h0c1tjaSsxXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHh5eltpXSArPSB4eXoyW2ldICogd2VpZ2h0c1tjaSsxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSQxPTA7IGkkMTx4eXoubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgaWYgKG1vZGUuY2hhckF0KGkkMSkgPT09ICdoJykge1xuICAgICAgICAgICAgICAgIHZhciBBJDEgPSBhdGFuMiQxKGR5IC8gY250W2kkMV0sIGR4IC8gY250W2kkMV0pIC8gUEkkMSAqIDE4MDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoQSQxIDwgMCkgeyBBJDEgKz0gMzYwOyB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKEEkMSA+PSAzNjApIHsgQSQxIC09IDM2MDsgfVxuICAgICAgICAgICAgICAgIHh5eltpJDFdID0gQSQxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4eXpbaSQxXSA9IHh5eltpJDFdL2NudFtpJDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFscGhhIC89IGw7XG4gICAgICAgIHJldHVybiAobmV3IENvbG9yXzEoeHl6LCBtb2RlKSkuYWxwaGEoYWxwaGEgPiAwLjk5OTk5ID8gMSA6IGFscGhhLCB0cnVlKTtcbiAgICB9O1xuXG5cbiAgICB2YXIgX2F2ZXJhZ2VfbHJnYiA9IGZ1bmN0aW9uIChjb2xvcnMsIHdlaWdodHMpIHtcbiAgICAgICAgdmFyIGwgPSBjb2xvcnMubGVuZ3RoO1xuICAgICAgICB2YXIgeHl6ID0gWzAsMCwwLDBdO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBjb2xvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjb2wgPSBjb2xvcnNbaV07XG4gICAgICAgICAgICB2YXIgZiA9IHdlaWdodHNbaV0gLyBsO1xuICAgICAgICAgICAgdmFyIHJnYiA9IGNvbC5fcmdiO1xuICAgICAgICAgICAgeHl6WzBdICs9IHBvdyQ0KHJnYlswXSwyKSAqIGY7XG4gICAgICAgICAgICB4eXpbMV0gKz0gcG93JDQocmdiWzFdLDIpICogZjtcbiAgICAgICAgICAgIHh5elsyXSArPSBwb3ckNChyZ2JbMl0sMikgKiBmO1xuICAgICAgICAgICAgeHl6WzNdICs9IHJnYlszXSAqIGY7XG4gICAgICAgIH1cbiAgICAgICAgeHl6WzBdID0gc3FydCQzKHh5elswXSk7XG4gICAgICAgIHh5elsxXSA9IHNxcnQkMyh4eXpbMV0pO1xuICAgICAgICB4eXpbMl0gPSBzcXJ0JDMoeHl6WzJdKTtcbiAgICAgICAgaWYgKHh5elszXSA+IDAuOTk5OTk5OSkgeyB4eXpbM10gPSAxOyB9XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3JfMShjbGlwX3JnYiQyKHh5eikpO1xuICAgIH07XG5cbiAgICAvLyBtaW5pbWFsIG11bHRpLXB1cnBvc2UgaW50ZXJmYWNlXG5cbiAgICAvLyBAcmVxdWlyZXMgdXRpbHMgY29sb3IgYW5hbHl6ZVxuXG5cbiAgICB2YXIgdHlwZSRqID0gdXRpbHMudHlwZTtcblxuICAgIHZhciBwb3ckNSA9IE1hdGgucG93O1xuXG4gICAgdmFyIHNjYWxlID0gZnVuY3Rpb24oY29sb3JzKSB7XG5cbiAgICAgICAgLy8gY29uc3RydWN0b3JcbiAgICAgICAgdmFyIF9tb2RlID0gJ3JnYic7XG4gICAgICAgIHZhciBfbmFjb2wgPSBjaHJvbWFfMSgnI2NjYycpO1xuICAgICAgICB2YXIgX3NwcmVhZCA9IDA7XG4gICAgICAgIC8vIGNvbnN0IF9maXhlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgX2RvbWFpbiA9IFswLCAxXTtcbiAgICAgICAgdmFyIF9wb3MgPSBbXTtcbiAgICAgICAgdmFyIF9wYWRkaW5nID0gWzAsMF07XG4gICAgICAgIHZhciBfY2xhc3NlcyA9IGZhbHNlO1xuICAgICAgICB2YXIgX2NvbG9ycyA9IFtdO1xuICAgICAgICB2YXIgX291dCA9IGZhbHNlO1xuICAgICAgICB2YXIgX21pbiA9IDA7XG4gICAgICAgIHZhciBfbWF4ID0gMTtcbiAgICAgICAgdmFyIF9jb3JyZWN0TGlnaHRuZXNzID0gZmFsc2U7XG4gICAgICAgIHZhciBfY29sb3JDYWNoZSA9IHt9O1xuICAgICAgICB2YXIgX3VzZUNhY2hlID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9nYW1tYSA9IDE7XG5cbiAgICAgICAgLy8gcHJpdmF0ZSBtZXRob2RzXG5cbiAgICAgICAgdmFyIHNldENvbG9ycyA9IGZ1bmN0aW9uKGNvbG9ycykge1xuICAgICAgICAgICAgY29sb3JzID0gY29sb3JzIHx8IFsnI2ZmZicsICcjMDAwJ107XG4gICAgICAgICAgICBpZiAoY29sb3JzICYmIHR5cGUkaihjb2xvcnMpID09PSAnc3RyaW5nJyAmJiBjaHJvbWFfMS5icmV3ZXIgJiZcbiAgICAgICAgICAgICAgICBjaHJvbWFfMS5icmV3ZXJbY29sb3JzLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgICAgICAgICAgICAgY29sb3JzID0gY2hyb21hXzEuYnJld2VyW2NvbG9ycy50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlJGooY29sb3JzKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBzaW5nbGUgY29sb3JcbiAgICAgICAgICAgICAgICBpZiAoY29sb3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcnMgPSBbY29sb3JzWzBdLCBjb2xvcnNbMF1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBtYWtlIGEgY29weSBvZiB0aGUgY29sb3JzXG4gICAgICAgICAgICAgICAgY29sb3JzID0gY29sb3JzLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdG8gY2hyb21hIGNsYXNzZXNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjPTA7IGM8Y29sb3JzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yc1tjXSA9IGNocm9tYV8xKGNvbG9yc1tjXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGF1dG8tZmlsbCBjb2xvciBwb3NpdGlvblxuICAgICAgICAgICAgICAgIF9wb3MubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjJDE9MDsgYyQxPGNvbG9ycy5sZW5ndGg7IGMkMSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIF9wb3MucHVzaChjJDEvKGNvbG9ycy5sZW5ndGgtMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc2V0Q2FjaGUoKTtcbiAgICAgICAgICAgIHJldHVybiBfY29sb3JzID0gY29sb3JzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRDbGFzcyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoX2NsYXNzZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBuID0gX2NsYXNzZXMubGVuZ3RoLTE7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgbiAmJiB2YWx1ZSA+PSBfY2xhc3Nlc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdE1hcExpZ2h0bmVzcyA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0OyB9O1xuICAgICAgICB2YXIgdE1hcERvbWFpbiA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0OyB9O1xuXG4gICAgICAgIC8vIGNvbnN0IGNsYXNzaWZ5VmFsdWUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAvLyAgICAgbGV0IHZhbCA9IHZhbHVlO1xuICAgICAgICAvLyAgICAgaWYgKF9jbGFzc2VzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgLy8gICAgICAgICBjb25zdCBuID0gX2NsYXNzZXMubGVuZ3RoLTE7XG4gICAgICAgIC8vICAgICAgICAgY29uc3QgaSA9IGdldENsYXNzKHZhbHVlKTtcbiAgICAgICAgLy8gICAgICAgICBjb25zdCBtaW5jID0gX2NsYXNzZXNbMF0gKyAoKF9jbGFzc2VzWzFdLV9jbGFzc2VzWzBdKSAqICgwICsgKF9zcHJlYWQgKiAwLjUpKSk7ICAvLyBjZW50ZXIgb2YgMXN0IGNsYXNzXG4gICAgICAgIC8vICAgICAgICAgY29uc3QgbWF4YyA9IF9jbGFzc2VzW24tMV0gKyAoKF9jbGFzc2VzW25dLV9jbGFzc2VzW24tMV0pICogKDEgLSAoX3NwcmVhZCAqIDAuNSkpKTsgIC8vIGNlbnRlciBvZiBsYXN0IGNsYXNzXG4gICAgICAgIC8vICAgICAgICAgdmFsID0gX21pbiArICgoKChfY2xhc3Nlc1tpXSArICgoX2NsYXNzZXNbaSsxXSAtIF9jbGFzc2VzW2ldKSAqIDAuNSkpIC0gbWluYykgLyAobWF4Yy1taW5jKSkgKiAoX21heCAtIF9taW4pKTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gICAgIHJldHVybiB2YWw7XG4gICAgICAgIC8vIH07XG5cbiAgICAgICAgdmFyIGdldENvbG9yID0gZnVuY3Rpb24odmFsLCBieXBhc3NNYXApIHtcbiAgICAgICAgICAgIHZhciBjb2wsIHQ7XG4gICAgICAgICAgICBpZiAoYnlwYXNzTWFwID09IG51bGwpIHsgYnlwYXNzTWFwID0gZmFsc2U7IH1cbiAgICAgICAgICAgIGlmIChpc05hTih2YWwpIHx8ICh2YWwgPT09IG51bGwpKSB7IHJldHVybiBfbmFjb2w7IH1cbiAgICAgICAgICAgIGlmICghYnlwYXNzTWFwKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jbGFzc2VzICYmIChfY2xhc3Nlcy5sZW5ndGggPiAyKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBjbGFzc1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IGdldENsYXNzKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIHQgPSBjIC8gKF9jbGFzc2VzLmxlbmd0aC0yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF9tYXggIT09IF9taW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBpbnRlcnBvbGF0ZSBiZXR3ZWVuIG1pbi9tYXhcbiAgICAgICAgICAgICAgICAgICAgdCA9ICh2YWwgLSBfbWluKSAvIChfbWF4IC0gX21pbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ID0gdmFsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkb21haW4gbWFwXG4gICAgICAgICAgICB0ID0gdE1hcERvbWFpbih0KTtcblxuICAgICAgICAgICAgaWYgKCFieXBhc3NNYXApIHtcbiAgICAgICAgICAgICAgICB0ID0gdE1hcExpZ2h0bmVzcyh0KTsgIC8vIGxpZ2h0bmVzcyBjb3JyZWN0aW9uXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChfZ2FtbWEgIT09IDEpIHsgdCA9IHBvdyQ1KHQsIF9nYW1tYSk7IH1cblxuICAgICAgICAgICAgdCA9IF9wYWRkaW5nWzBdICsgKHQgKiAoMSAtIF9wYWRkaW5nWzBdIC0gX3BhZGRpbmdbMV0pKTtcblxuICAgICAgICAgICAgdCA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIHQpKTtcblxuICAgICAgICAgICAgdmFyIGsgPSBNYXRoLmZsb29yKHQgKiAxMDAwMCk7XG5cbiAgICAgICAgICAgIGlmIChfdXNlQ2FjaGUgJiYgX2NvbG9yQ2FjaGVba10pIHtcbiAgICAgICAgICAgICAgICBjb2wgPSBfY29sb3JDYWNoZVtrXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUkaihfY29sb3JzKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgICAgICAvL2ZvciBpIGluIFswLi5fcG9zLmxlbmd0aC0xXVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8X3Bvcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBfcG9zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgPD0gcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IF9jb2xvcnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHQgPj0gcCkgJiYgKGkgPT09IChfcG9zLmxlbmd0aC0xKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2wgPSBfY29sb3JzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgPiBwICYmIHQgPCBfcG9zW2krMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gKHQtcCkvKF9wb3NbaSsxXS1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2wgPSBjaHJvbWFfMS5pbnRlcnBvbGF0ZShfY29sb3JzW2ldLCBfY29sb3JzW2krMV0sIHQsIF9tb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSRqKF9jb2xvcnMpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbCA9IF9jb2xvcnModCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfdXNlQ2FjaGUpIHsgX2NvbG9yQ2FjaGVba10gPSBjb2w7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb2w7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlc2V0Q2FjaGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfY29sb3JDYWNoZSA9IHt9OyB9O1xuXG4gICAgICAgIHNldENvbG9ycyhjb2xvcnMpO1xuXG4gICAgICAgIC8vIHB1YmxpYyBpbnRlcmZhY2VcblxuICAgICAgICB2YXIgZiA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHZhciBjID0gY2hyb21hXzEoZ2V0Q29sb3IodikpO1xuICAgICAgICAgICAgaWYgKF9vdXQgJiYgY1tfb3V0XSkgeyByZXR1cm4gY1tfb3V0XSgpOyB9IGVsc2UgeyByZXR1cm4gYzsgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGYuY2xhc3NlcyA9IGZ1bmN0aW9uKGNsYXNzZXMpIHtcbiAgICAgICAgICAgIGlmIChjbGFzc2VzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSRqKGNsYXNzZXMpID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc2VzID0gY2xhc3NlcztcbiAgICAgICAgICAgICAgICAgICAgX2RvbWFpbiA9IFtjbGFzc2VzWzBdLCBjbGFzc2VzW2NsYXNzZXMubGVuZ3RoLTFdXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IGNocm9tYV8xLmFuYWx5emUoX2RvbWFpbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc2VzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3NlcyA9IFtkLm1pbiwgZC5tYXhdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzZXMgPSBjaHJvbWFfMS5saW1pdHMoZCwgJ2UnLCBjbGFzc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfY2xhc3NlcztcbiAgICAgICAgfTtcblxuXG4gICAgICAgIGYuZG9tYWluID0gZnVuY3Rpb24oZG9tYWluKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2RvbWFpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9taW4gPSBkb21haW5bMF07XG4gICAgICAgICAgICBfbWF4ID0gZG9tYWluW2RvbWFpbi5sZW5ndGgtMV07XG4gICAgICAgICAgICBfcG9zID0gW107XG4gICAgICAgICAgICB2YXIgayA9IF9jb2xvcnMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKChkb21haW4ubGVuZ3RoID09PSBrKSAmJiAoX21pbiAhPT0gX21heCkpIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb25zXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBBcnJheS5mcm9tKGRvbWFpbik7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gbGlzdFtpXTtcblxuICAgICAgICAgICAgICAgICAgX3Bvcy5wdXNoKChkLV9taW4pIC8gKF9tYXgtX21pbikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYz0wOyBjPGs7IGMrKykge1xuICAgICAgICAgICAgICAgICAgICBfcG9zLnB1c2goYy8oay0xKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkb21haW4ubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgZG9tYWluIG1hcFxuICAgICAgICAgICAgICAgICAgICB2YXIgdE91dCA9IGRvbWFpbi5tYXAoZnVuY3Rpb24gKGQsaSkgeyByZXR1cm4gaS8oZG9tYWluLmxlbmd0aC0xKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0QnJlYWtzID0gZG9tYWluLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gKGQgLSBfbWluKSAvIChfbWF4IC0gX21pbik7IH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRCcmVha3MuZXZlcnkoZnVuY3Rpb24gKHZhbCwgaSkgeyByZXR1cm4gdE91dFtpXSA9PT0gdmFsOyB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdE1hcERvbWFpbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgPD0gMCB8fCB0ID49IDEpIHsgcmV0dXJuIHQ7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHQgPj0gdEJyZWFrc1tpKzFdKSB7IGkrKzsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gKHQgLSB0QnJlYWtzW2ldKSAvICh0QnJlYWtzW2krMV0gLSB0QnJlYWtzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0ID0gdE91dFtpXSArIGYgKiAodE91dFtpKzFdIC0gdE91dFtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9kb21haW4gPSBbX21pbiwgX21heF07XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfTtcblxuICAgICAgICBmLm1vZGUgPSBmdW5jdGlvbihfbSkge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9tb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX21vZGUgPSBfbTtcbiAgICAgICAgICAgIHJlc2V0Q2FjaGUoKTtcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9O1xuXG4gICAgICAgIGYucmFuZ2UgPSBmdW5jdGlvbihjb2xvcnMsIF9wb3MpIHtcbiAgICAgICAgICAgIHNldENvbG9ycyhjb2xvcnMsIF9wb3MpO1xuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5vdXQgPSBmdW5jdGlvbihfbykge1xuICAgICAgICAgICAgX291dCA9IF9vO1xuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5zcHJlYWQgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3ByZWFkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3NwcmVhZCA9IHZhbDtcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9O1xuXG4gICAgICAgIGYuY29ycmVjdExpZ2h0bmVzcyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIGlmICh2ID09IG51bGwpIHsgdiA9IHRydWU7IH1cbiAgICAgICAgICAgIF9jb3JyZWN0TGlnaHRuZXNzID0gdjtcbiAgICAgICAgICAgIHJlc2V0Q2FjaGUoKTtcbiAgICAgICAgICAgIGlmIChfY29ycmVjdExpZ2h0bmVzcykge1xuICAgICAgICAgICAgICAgIHRNYXBMaWdodG5lc3MgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBMMCA9IGdldENvbG9yKDAsIHRydWUpLmxhYigpWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgTDEgPSBnZXRDb2xvcigxLCB0cnVlKS5sYWIoKVswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvbCA9IEwwID4gTDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBMX2FjdHVhbCA9IGdldENvbG9yKHQsIHRydWUpLmxhYigpWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgTF9pZGVhbCA9IEwwICsgKChMMSAtIEwwKSAqIHQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgTF9kaWZmID0gTF9hY3R1YWwgLSBMX2lkZWFsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdDAgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdDEgPSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4X2l0ZXIgPSAyMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChNYXRoLmFicyhMX2RpZmYpID4gMWUtMikgJiYgKG1heF9pdGVyLS0gPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2wpIHsgTF9kaWZmICo9IC0xOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKExfZGlmZiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdDAgPSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ICs9ICh0MSAtIHQpICogMC41O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQxID0gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCArPSAodDAgLSB0KSAqIDAuNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTF9hY3R1YWwgPSBnZXRDb2xvcih0LCB0cnVlKS5sYWIoKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTF9kaWZmID0gTF9hY3R1YWwgLSBMX2lkZWFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0TWFwTGlnaHRuZXNzID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQ7IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfTtcblxuICAgICAgICBmLnBhZGRpbmcgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICBpZiAocCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUkaihwKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IFtwLHBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfcGFkZGluZyA9IHA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcGFkZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmLmNvbG9ycyA9IGZ1bmN0aW9uKG51bUNvbG9ycywgb3V0KSB7XG4gICAgICAgICAgICAvLyBJZiBubyBhcmd1bWVudHMgYXJlIGdpdmVuLCByZXR1cm4gdGhlIG9yaWdpbmFsIGNvbG9ycyB0aGF0IHdlcmUgcHJvdmlkZWRcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgeyBvdXQgPSAnaGV4JzsgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9jb2xvcnMuc2xpY2UoMCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtQ29sb3JzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW2YoMC41KV07XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtQ29sb3JzID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciBkbSA9IF9kb21haW5bMF07XG4gICAgICAgICAgICAgICAgdmFyIGRkID0gX2RvbWFpblsxXSAtIGRtO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9fcmFuZ2VfXygwLCBudW1Db2xvcnMsIGZhbHNlKS5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGYoIGRtICsgKChpLyhudW1Db2xvcnMtMSkpICogZGQpICk7IH0pO1xuXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyByZXR1cm5zIGFsbCBjb2xvcnMgYmFzZWQgb24gdGhlIGRlZmluZWQgY2xhc3Nlc1xuICAgICAgICAgICAgICAgIGNvbG9ycyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBzYW1wbGVzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKF9jbGFzc2VzICYmIChfY2xhc3Nlcy5sZW5ndGggPiAyKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMSwgZW5kID0gX2NsYXNzZXMubGVuZ3RoLCBhc2MgPSAxIDw9IGVuZDsgYXNjID8gaSA8IGVuZCA6IGkgPiBlbmQ7IGFzYyA/IGkrKyA6IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlcy5wdXNoKChfY2xhc3Nlc1tpLTFdK19jbGFzc2VzW2ldKSowLjUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlcyA9IF9kb21haW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNhbXBsZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBmKHYpOyB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNocm9tYV8xW291dF0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjW291dF0oKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGYuY2FjaGUgPSBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICBpZiAoYyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3VzZUNhY2hlID0gYztcbiAgICAgICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF91c2VDYWNoZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmLmdhbW1hID0gZnVuY3Rpb24oZykge1xuICAgICAgICAgICAgaWYgKGcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF9nYW1tYSA9IGc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2FtbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5ub2RhdGEgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBpZiAoZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX25hY29sID0gY2hyb21hXzEoZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBfbmFjb2w7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGY7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9fcmFuZ2VfXyhsZWZ0LCByaWdodCwgaW5jbHVzaXZlKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBbXTtcbiAgICAgIHZhciBhc2NlbmRpbmcgPSBsZWZ0IDwgcmlnaHQ7XG4gICAgICB2YXIgZW5kID0gIWluY2x1c2l2ZSA/IHJpZ2h0IDogYXNjZW5kaW5nID8gcmlnaHQgKyAxIDogcmlnaHQgLSAxO1xuICAgICAgZm9yICh2YXIgaSA9IGxlZnQ7IGFzY2VuZGluZyA/IGkgPCBlbmQgOiBpID4gZW5kOyBhc2NlbmRpbmcgPyBpKysgOiBpLS0pIHtcbiAgICAgICAgcmFuZ2UucHVzaChpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIGludGVycG9sYXRlcyBiZXR3ZWVuIGEgc2V0IG9mIGNvbG9ycyB1emluZyBhIGJlemllciBzcGxpbmVcbiAgICAvL1xuXG4gICAgLy8gQHJlcXVpcmVzIHV0aWxzIGxhYlxuXG5cblxuXG4gICAgdmFyIGJlemllciA9IGZ1bmN0aW9uKGNvbG9ycykge1xuICAgICAgICB2YXIgYXNzaWduLCBhc3NpZ24kMSwgYXNzaWduJDI7XG5cbiAgICAgICAgdmFyIEksIGxhYjAsIGxhYjEsIGxhYjI7XG4gICAgICAgIGNvbG9ycyA9IGNvbG9ycy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5ldyBDb2xvcl8xKGMpOyB9KTtcbiAgICAgICAgaWYgKGNvbG9ycy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIC8vIGxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgICAgICAgICAoYXNzaWduID0gY29sb3JzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5sYWIoKTsgfSksIGxhYjAgPSBhc3NpZ25bMF0sIGxhYjEgPSBhc3NpZ25bMV0pO1xuICAgICAgICAgICAgSSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFiID0gKFswLCAxLCAyXS5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGxhYjBbaV0gKyAodCAqIChsYWIxW2ldIC0gbGFiMFtpXSkpOyB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcl8xKGxhYiwgJ2xhYicpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2xvcnMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAvLyBxdWFkcmF0aWMgYmV6aWVyIGludGVycG9sYXRpb25cbiAgICAgICAgICAgIChhc3NpZ24kMSA9IGNvbG9ycy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMubGFiKCk7IH0pLCBsYWIwID0gYXNzaWduJDFbMF0sIGxhYjEgPSBhc3NpZ24kMVsxXSwgbGFiMiA9IGFzc2lnbiQxWzJdKTtcbiAgICAgICAgICAgIEkgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhYiA9IChbMCwgMSwgMl0ubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiAoKDEtdCkqKDEtdCkgKiBsYWIwW2ldKSArICgyICogKDEtdCkgKiB0ICogbGFiMVtpXSkgKyAodCAqIHQgKiBsYWIyW2ldKTsgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3JfMShsYWIsICdsYWInKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoY29sb3JzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgLy8gY3ViaWMgYmV6aWVyIGludGVycG9sYXRpb25cbiAgICAgICAgICAgIHZhciBsYWIzO1xuICAgICAgICAgICAgKGFzc2lnbiQyID0gY29sb3JzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5sYWIoKTsgfSksIGxhYjAgPSBhc3NpZ24kMlswXSwgbGFiMSA9IGFzc2lnbiQyWzFdLCBsYWIyID0gYXNzaWduJDJbMl0sIGxhYjMgPSBhc3NpZ24kMlszXSk7XG4gICAgICAgICAgICBJID0gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgIHZhciBsYWIgPSAoWzAsIDEsIDJdLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gKCgxLXQpKigxLXQpKigxLXQpICogbGFiMFtpXSkgKyAoMyAqICgxLXQpICogKDEtdCkgKiB0ICogbGFiMVtpXSkgKyAoMyAqICgxLXQpICogdCAqIHQgKiBsYWIyW2ldKSArICh0KnQqdCAqIGxhYjNbaV0pOyB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcl8xKGxhYiwgJ2xhYicpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2xvcnMubGVuZ3RoID09PSA1KSB7XG4gICAgICAgICAgICB2YXIgSTAgPSBiZXppZXIoY29sb3JzLnNsaWNlKDAsIDMpKTtcbiAgICAgICAgICAgIHZhciBJMSA9IGJlemllcihjb2xvcnMuc2xpY2UoMiwgNSkpO1xuICAgICAgICAgICAgSSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodCA8IDAuNSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSTAodCoyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSTEoKHQtMC41KSoyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBJO1xuICAgIH07XG5cbiAgICB2YXIgYmV6aWVyXzEgPSBmdW5jdGlvbiAoY29sb3JzKSB7XG4gICAgICAgIHZhciBmID0gYmV6aWVyKGNvbG9ycyk7XG4gICAgICAgIGYuc2NhbGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzY2FsZShmKTsgfTtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogaW50ZXJwb2xhdGVzIGJldHdlZW4gYSBzZXQgb2YgY29sb3JzIHV6aW5nIGEgYmV6aWVyIHNwbGluZVxuICAgICAqIGJsZW5kIG1vZGUgZm9ybXVsYXMgdGFrZW4gZnJvbSBodHRwOi8vd3d3LnZlbnR1cmUtd2FyZS5jb20va2V2aW4vY29kaW5nL2xldHMtbGVhcm4tbWF0aC1waG90b3Nob3AtYmxlbmQtbW9kZXMvXG4gICAgICovXG5cblxuXG5cbiAgICB2YXIgYmxlbmQgPSBmdW5jdGlvbiAoYm90dG9tLCB0b3AsIG1vZGUpIHtcbiAgICAgICAgaWYgKCFibGVuZFttb2RlXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGJsZW5kIG1vZGUgJyArIG1vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibGVuZFttb2RlXShib3R0b20sIHRvcCk7XG4gICAgfTtcblxuICAgIHZhciBibGVuZF9mID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZ1bmN0aW9uIChib3R0b20sdG9wKSB7XG4gICAgICAgICAgICB2YXIgYzAgPSBjaHJvbWFfMSh0b3ApLnJnYigpO1xuICAgICAgICAgICAgdmFyIGMxID0gY2hyb21hXzEoYm90dG9tKS5yZ2IoKTtcbiAgICAgICAgICAgIHJldHVybiBjaHJvbWFfMS5yZ2IoZihjMCwgYzEpKTtcbiAgICAgICAgfTsgfTtcblxuICAgIHZhciBlYWNoID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZ1bmN0aW9uIChjMCwgYzEpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgICAgIG91dFswXSA9IGYoYzBbMF0sIGMxWzBdKTtcbiAgICAgICAgICAgIG91dFsxXSA9IGYoYzBbMV0sIGMxWzFdKTtcbiAgICAgICAgICAgIG91dFsyXSA9IGYoYzBbMl0sIGMxWzJdKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH07IH07XG5cbiAgICB2YXIgbm9ybWFsID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGE7IH07XG4gICAgdmFyIG11bHRpcGx5ID0gZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gYSAqIGIgLyAyNTU7IH07XG4gICAgdmFyIGRhcmtlbiQxID0gZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gYSA+IGIgPyBiIDogYTsgfTtcbiAgICB2YXIgbGlnaHRlbiA9IGZ1bmN0aW9uIChhLGIpIHsgcmV0dXJuIGEgPiBiID8gYSA6IGI7IH07XG4gICAgdmFyIHNjcmVlbiA9IGZ1bmN0aW9uIChhLGIpIHsgcmV0dXJuIDI1NSAqICgxIC0gKDEtYS8yNTUpICogKDEtYi8yNTUpKTsgfTtcbiAgICB2YXIgb3ZlcmxheSA9IGZ1bmN0aW9uIChhLGIpIHsgcmV0dXJuIGIgPCAxMjggPyAyICogYSAqIGIgLyAyNTUgOiAyNTUgKiAoMSAtIDIgKiAoMSAtIGEgLyAyNTUgKSAqICggMSAtIGIgLyAyNTUgKSk7IH07XG4gICAgdmFyIGJ1cm4gPSBmdW5jdGlvbiAoYSxiKSB7IHJldHVybiAyNTUgKiAoMSAtICgxIC0gYiAvIDI1NSkgLyAoYS8yNTUpKTsgfTtcbiAgICB2YXIgZG9kZ2UgPSBmdW5jdGlvbiAoYSxiKSB7XG4gICAgICAgIGlmIChhID09PSAyNTUpIHsgcmV0dXJuIDI1NTsgfVxuICAgICAgICBhID0gMjU1ICogKGIgLyAyNTUpIC8gKDEgLSBhIC8gMjU1KTtcbiAgICAgICAgcmV0dXJuIGEgPiAyNTUgPyAyNTUgOiBhXG4gICAgfTtcblxuICAgIC8vICMgYWRkID0gKGEsYikgLT5cbiAgICAvLyAjICAgICBpZiAoYSArIGIgPiAyNTUpIHRoZW4gMjU1IGVsc2UgYSArIGJcblxuICAgIGJsZW5kLm5vcm1hbCA9IGJsZW5kX2YoZWFjaChub3JtYWwpKTtcbiAgICBibGVuZC5tdWx0aXBseSA9IGJsZW5kX2YoZWFjaChtdWx0aXBseSkpO1xuICAgIGJsZW5kLnNjcmVlbiA9IGJsZW5kX2YoZWFjaChzY3JlZW4pKTtcbiAgICBibGVuZC5vdmVybGF5ID0gYmxlbmRfZihlYWNoKG92ZXJsYXkpKTtcbiAgICBibGVuZC5kYXJrZW4gPSBibGVuZF9mKGVhY2goZGFya2VuJDEpKTtcbiAgICBibGVuZC5saWdodGVuID0gYmxlbmRfZihlYWNoKGxpZ2h0ZW4pKTtcbiAgICBibGVuZC5kb2RnZSA9IGJsZW5kX2YoZWFjaChkb2RnZSkpO1xuICAgIGJsZW5kLmJ1cm4gPSBibGVuZF9mKGVhY2goYnVybikpO1xuICAgIC8vIGJsZW5kLmFkZCA9IGJsZW5kX2YoZWFjaChhZGQpKTtcblxuICAgIHZhciBibGVuZF8xID0gYmxlbmQ7XG5cbiAgICAvLyBjdWJlaGVsaXggaW50ZXJwb2xhdGlvblxuICAgIC8vIGJhc2VkIG9uIEQuQS4gR3JlZW4gXCJBIGNvbG91ciBzY2hlbWUgZm9yIHRoZSBkaXNwbGF5IG9mIGFzdHJvbm9taWNhbCBpbnRlbnNpdHkgaW1hZ2VzXCJcbiAgICAvLyBodHRwOi8vYXN0cm9uLXNvYy5pbi9idWxsZXRpbi8xMUp1bmUvMjg5MzkyMDExLnBkZlxuXG4gICAgdmFyIHR5cGUkayA9IHV0aWxzLnR5cGU7XG4gICAgdmFyIGNsaXBfcmdiJDMgPSB1dGlscy5jbGlwX3JnYjtcbiAgICB2YXIgVFdPUEkkMiA9IHV0aWxzLlRXT1BJO1xuICAgIHZhciBwb3ckNiA9IE1hdGgucG93O1xuICAgIHZhciBzaW4kMiA9IE1hdGguc2luO1xuICAgIHZhciBjb3MkMyA9IE1hdGguY29zO1xuXG5cbiAgICB2YXIgY3ViZWhlbGl4ID0gZnVuY3Rpb24oc3RhcnQsIHJvdGF0aW9ucywgaHVlLCBnYW1tYSwgbGlnaHRuZXNzKSB7XG4gICAgICAgIGlmICggc3RhcnQgPT09IHZvaWQgMCApIHN0YXJ0PTMwMDtcbiAgICAgICAgaWYgKCByb3RhdGlvbnMgPT09IHZvaWQgMCApIHJvdGF0aW9ucz0tMS41O1xuICAgICAgICBpZiAoIGh1ZSA9PT0gdm9pZCAwICkgaHVlPTE7XG4gICAgICAgIGlmICggZ2FtbWEgPT09IHZvaWQgMCApIGdhbW1hPTE7XG4gICAgICAgIGlmICggbGlnaHRuZXNzID09PSB2b2lkIDAgKSBsaWdodG5lc3M9WzAsMV07XG5cbiAgICAgICAgdmFyIGRoID0gMCwgZGw7XG4gICAgICAgIGlmICh0eXBlJGsobGlnaHRuZXNzKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgZGwgPSBsaWdodG5lc3NbMV0gLSBsaWdodG5lc3NbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkbCA9IDA7XG4gICAgICAgICAgICBsaWdodG5lc3MgPSBbbGlnaHRuZXNzLCBsaWdodG5lc3NdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGYgPSBmdW5jdGlvbihmcmFjdCkge1xuICAgICAgICAgICAgdmFyIGEgPSBUV09QSSQyICogKCgoc3RhcnQrMTIwKS8zNjApICsgKHJvdGF0aW9ucyAqIGZyYWN0KSk7XG4gICAgICAgICAgICB2YXIgbCA9IHBvdyQ2KGxpZ2h0bmVzc1swXSArIChkbCAqIGZyYWN0KSwgZ2FtbWEpO1xuICAgICAgICAgICAgdmFyIGggPSBkaCAhPT0gMCA/IGh1ZVswXSArIChmcmFjdCAqIGRoKSA6IGh1ZTtcbiAgICAgICAgICAgIHZhciBhbXAgPSAoaCAqIGwgKiAoMS1sKSkgLyAyO1xuICAgICAgICAgICAgdmFyIGNvc19hID0gY29zJDMoYSk7XG4gICAgICAgICAgICB2YXIgc2luX2EgPSBzaW4kMihhKTtcbiAgICAgICAgICAgIHZhciByID0gbCArIChhbXAgKiAoKC0wLjE0ODYxICogY29zX2EpICsgKDEuNzgyNzcqIHNpbl9hKSkpO1xuICAgICAgICAgICAgdmFyIGcgPSBsICsgKGFtcCAqICgoLTAuMjkyMjcgKiBjb3NfYSkgLSAoMC45MDY0OSogc2luX2EpKSk7XG4gICAgICAgICAgICB2YXIgYiA9IGwgKyAoYW1wICogKCsxLjk3Mjk0ICogY29zX2EpKTtcbiAgICAgICAgICAgIHJldHVybiBjaHJvbWFfMShjbGlwX3JnYiQzKFtyKjI1NSxnKjI1NSxiKjI1NSwxXSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGYuc3RhcnQgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICBpZiAoKHMgPT0gbnVsbCkpIHsgcmV0dXJuIHN0YXJ0OyB9XG4gICAgICAgICAgICBzdGFydCA9IHM7XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfTtcblxuICAgICAgICBmLnJvdGF0aW9ucyA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgIGlmICgociA9PSBudWxsKSkgeyByZXR1cm4gcm90YXRpb25zOyB9XG4gICAgICAgICAgICByb3RhdGlvbnMgPSByO1xuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5nYW1tYSA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgICAgIGlmICgoZyA9PSBudWxsKSkgeyByZXR1cm4gZ2FtbWE7IH1cbiAgICAgICAgICAgIGdhbW1hID0gZztcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9O1xuXG4gICAgICAgIGYuaHVlID0gZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgaWYgKChoID09IG51bGwpKSB7IHJldHVybiBodWU7IH1cbiAgICAgICAgICAgIGh1ZSA9IGg7XG4gICAgICAgICAgICBpZiAodHlwZSRrKGh1ZSkgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICBkaCA9IGh1ZVsxXSAtIGh1ZVswXTtcbiAgICAgICAgICAgICAgICBpZiAoZGggPT09IDApIHsgaHVlID0gaHVlWzFdOyB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9O1xuXG4gICAgICAgIGYubGlnaHRuZXNzID0gZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgaWYgKChoID09IG51bGwpKSB7IHJldHVybiBsaWdodG5lc3M7IH1cbiAgICAgICAgICAgIGlmICh0eXBlJGsoaCkgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICBsaWdodG5lc3MgPSBoO1xuICAgICAgICAgICAgICAgIGRsID0gaFsxXSAtIGhbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpZ2h0bmVzcyA9IFtoLGhdO1xuICAgICAgICAgICAgICAgIGRsID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9O1xuXG4gICAgICAgIGYuc2NhbGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjaHJvbWFfMS5zY2FsZShmKTsgfTtcblxuICAgICAgICBmLmh1ZShodWUpO1xuXG4gICAgICAgIHJldHVybiBmO1xuICAgIH07XG5cbiAgICB2YXIgZGlnaXRzID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xuXG4gICAgdmFyIGZsb29yJDIgPSBNYXRoLmZsb29yO1xuICAgIHZhciByYW5kb20gPSBNYXRoLnJhbmRvbTtcblxuICAgIHZhciByYW5kb21fMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvZGUgPSAnIyc7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTw2OyBpKyspIHtcbiAgICAgICAgICAgIGNvZGUgKz0gZGlnaXRzLmNoYXJBdChmbG9vciQyKHJhbmRvbSgpICogMTYpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbG9yXzEoY29kZSwgJ2hleCcpO1xuICAgIH07XG5cbiAgICB2YXIgbG9nJDEgPSBNYXRoLmxvZztcbiAgICB2YXIgcG93JDcgPSBNYXRoLnBvdztcbiAgICB2YXIgZmxvb3IkMyA9IE1hdGguZmxvb3I7XG4gICAgdmFyIGFicyA9IE1hdGguYWJzO1xuXG5cbiAgICB2YXIgYW5hbHl6ZSA9IGZ1bmN0aW9uIChkYXRhLCBrZXkpIHtcbiAgICAgICAgaWYgKCBrZXkgPT09IHZvaWQgMCApIGtleT1udWxsO1xuXG4gICAgICAgIHZhciByID0ge1xuICAgICAgICAgICAgbWluOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFKi0xLFxuICAgICAgICAgICAgc3VtOiAwLFxuICAgICAgICAgICAgdmFsdWVzOiBbXSxcbiAgICAgICAgICAgIGNvdW50OiAwXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlKGRhdGEpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZGF0YSA9IE9iamVjdC52YWx1ZXMoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGlmIChrZXkgJiYgdHlwZSh2YWwpID09PSAnb2JqZWN0JykgeyB2YWwgPSB2YWxba2V5XTsgfVxuICAgICAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkICYmIHZhbCAhPT0gbnVsbCAmJiAhaXNOYU4odmFsKSkge1xuICAgICAgICAgICAgICAgIHIudmFsdWVzLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICByLnN1bSArPSB2YWw7XG4gICAgICAgICAgICAgICAgaWYgKHZhbCA8IHIubWluKSB7IHIubWluID0gdmFsOyB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbCA+IHIubWF4KSB7IHIubWF4ID0gdmFsOyB9XG4gICAgICAgICAgICAgICAgci5jb3VudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByLmRvbWFpbiA9IFtyLm1pbiwgci5tYXhdO1xuXG4gICAgICAgIHIubGltaXRzID0gZnVuY3Rpb24gKG1vZGUsIG51bSkgeyByZXR1cm4gbGltaXRzKHIsIG1vZGUsIG51bSk7IH07XG5cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuXG4gICAgdmFyIGxpbWl0cyA9IGZ1bmN0aW9uIChkYXRhLCBtb2RlLCBudW0pIHtcbiAgICAgICAgaWYgKCBtb2RlID09PSB2b2lkIDAgKSBtb2RlPSdlcXVhbCc7XG4gICAgICAgIGlmICggbnVtID09PSB2b2lkIDAgKSBudW09NztcblxuICAgICAgICBpZiAodHlwZShkYXRhKSA9PSAnYXJyYXknKSB7XG4gICAgICAgICAgICBkYXRhID0gYW5hbHl6ZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWluID0gZGF0YS5taW47XG4gICAgICAgIHZhciBtYXggPSBkYXRhLm1heDtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGRhdGEudmFsdWVzLnNvcnQoZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gYS1iOyB9KTtcblxuICAgICAgICBpZiAobnVtID09PSAxKSB7IHJldHVybiBbbWluLG1heF07IH1cblxuICAgICAgICB2YXIgbGltaXRzID0gW107XG5cbiAgICAgICAgaWYgKG1vZGUuc3Vic3RyKDAsMSkgPT09ICdjJykgeyAvLyBjb250aW51b3VzXG4gICAgICAgICAgICBsaW1pdHMucHVzaChtaW4pO1xuICAgICAgICAgICAgbGltaXRzLnB1c2gobWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb2RlLnN1YnN0cigwLDEpID09PSAnZScpIHsgLy8gZXF1YWwgaW50ZXJ2YWxcbiAgICAgICAgICAgIGxpbWl0cy5wdXNoKG1pbik7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTE7IGk8bnVtOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsaW1pdHMucHVzaChtaW4rKChpL251bSkqKG1heC1taW4pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW1pdHMucHVzaChtYXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAobW9kZS5zdWJzdHIoMCwxKSA9PT0gJ2wnKSB7IC8vIGxvZyBzY2FsZVxuICAgICAgICAgICAgaWYgKG1pbiA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2dhcml0aG1pYyBzY2FsZXMgYXJlIG9ubHkgcG9zc2libGUgZm9yIHZhbHVlcyA+IDAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtaW5fbG9nID0gTWF0aC5MT0cxMEUgKiBsb2ckMShtaW4pO1xuICAgICAgICAgICAgdmFyIG1heF9sb2cgPSBNYXRoLkxPRzEwRSAqIGxvZyQxKG1heCk7XG4gICAgICAgICAgICBsaW1pdHMucHVzaChtaW4pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxPTE7IGkkMTxudW07IGkkMSsrKSB7XG4gICAgICAgICAgICAgICAgbGltaXRzLnB1c2gocG93JDcoMTAsIG1pbl9sb2cgKyAoKGkkMS9udW0pICogKG1heF9sb2cgLSBtaW5fbG9nKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbWl0cy5wdXNoKG1heCk7XG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIGlmIChtb2RlLnN1YnN0cigwLDEpID09PSAncScpIHsgLy8gcXVhbnRpbGUgc2NhbGVcbiAgICAgICAgICAgIGxpbWl0cy5wdXNoKG1pbik7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDI9MTsgaSQyPG51bTsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9ICgodmFsdWVzLmxlbmd0aC0xKSAqIGkkMikvbnVtO1xuICAgICAgICAgICAgICAgIHZhciBwYiA9IGZsb29yJDMocCk7XG4gICAgICAgICAgICAgICAgaWYgKHBiID09PSBwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbWl0cy5wdXNoKHZhbHVlc1twYl0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIHAgPiBwYlxuICAgICAgICAgICAgICAgICAgICB2YXIgcHIgPSBwIC0gcGI7XG4gICAgICAgICAgICAgICAgICAgIGxpbWl0cy5wdXNoKCh2YWx1ZXNbcGJdKigxLXByKSkgKyAodmFsdWVzW3BiKzFdKnByKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGltaXRzLnB1c2gobWF4KTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZiAobW9kZS5zdWJzdHIoMCwxKSA9PT0gJ2snKSB7IC8vIGstbWVhbnMgY2x1c3RlcmluZ1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIGJhc2VkIG9uXG4gICAgICAgICAgICBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZmlndWUvc291cmNlL2Jyb3dzZS90cnVuay9maWd1ZS5qcyMzMzZcbiAgICAgICAgICAgIHNpbXBsaWZpZWQgZm9yIDEtZCBpbnB1dCB2YWx1ZXNcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgY2x1c3RlcjtcbiAgICAgICAgICAgIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBhc3NpZ25tZW50cyA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgICAgIHZhciBjbHVzdGVyU2l6ZXMgPSBuZXcgQXJyYXkobnVtKTtcbiAgICAgICAgICAgIHZhciByZXBlYXQgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG5iX2l0ZXJzID0gMDtcbiAgICAgICAgICAgIHZhciBjZW50cm9pZHMgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBnZXQgc2VlZCB2YWx1ZXNcbiAgICAgICAgICAgIGNlbnRyb2lkcyA9IFtdO1xuICAgICAgICAgICAgY2VudHJvaWRzLnB1c2gobWluKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMz0xOyBpJDM8bnVtOyBpJDMrKykge1xuICAgICAgICAgICAgICAgIGNlbnRyb2lkcy5wdXNoKG1pbiArICgoaSQzL251bSkgKiAobWF4LW1pbikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbnRyb2lkcy5wdXNoKG1heCk7XG5cbiAgICAgICAgICAgIHdoaWxlIChyZXBlYXQpIHtcbiAgICAgICAgICAgICAgICAvLyBhc3NpZ25tZW50IHN0ZXBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8bnVtOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2x1c3RlclNpemVzW2pdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQ0PTA7IGkkNDxuOyBpJDQrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaSQ0XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbmRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmVzdCA9ICh2b2lkIDApO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqJDE9MDsgaiQxPG51bTsgaiQxKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXN0ID0gYWJzKGNlbnRyb2lkc1tqJDFdLXZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXN0IDwgbWluZGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmRpc3QgPSBkaXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3QgPSBqJDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbHVzdGVyU2l6ZXNbYmVzdF0rKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lnbm1lbnRzW2kkNF0gPSBiZXN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGNlbnRyb2lkcyBzdGVwXG4gICAgICAgICAgICAgICAgdmFyIG5ld0NlbnRyb2lkcyA9IG5ldyBBcnJheShudW0pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGokMj0wOyBqJDI8bnVtOyBqJDIrKykge1xuICAgICAgICAgICAgICAgICAgICBuZXdDZW50cm9pZHNbaiQyXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkkNT0wOyBpJDU8bjsgaSQ1KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2x1c3RlciA9IGFzc2lnbm1lbnRzW2kkNV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdDZW50cm9pZHNbY2x1c3Rlcl0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NlbnRyb2lkc1tjbHVzdGVyXSA9IHZhbHVlc1tpJDVdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2VudHJvaWRzW2NsdXN0ZXJdICs9IHZhbHVlc1tpJDVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGokMz0wOyBqJDM8bnVtOyBqJDMrKykge1xuICAgICAgICAgICAgICAgICAgICBuZXdDZW50cm9pZHNbaiQzXSAqPSAxL2NsdXN0ZXJTaXplc1tqJDNdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGNvbnZlcmdlbmNlXG4gICAgICAgICAgICAgICAgcmVwZWF0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiQ0PTA7IGokNDxudW07IGokNCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdDZW50cm9pZHNbaiQ0XSAhPT0gY2VudHJvaWRzW2okNF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGVhdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNlbnRyb2lkcyA9IG5ld0NlbnRyb2lkcztcbiAgICAgICAgICAgICAgICBuYl9pdGVycysrO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5iX2l0ZXJzID4gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGVhdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZmluaXNoZWQgay1tZWFucyBjbHVzdGVyaW5nXG4gICAgICAgICAgICAvLyB0aGUgbmV4dCBwYXJ0IGlzIGJvcnJvd2VkIGZyb20gZ2FicmllbGZsb3IuaXRcbiAgICAgICAgICAgIHZhciBrQ2x1c3RlcnMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGokNT0wOyBqJDU8bnVtOyBqJDUrKykge1xuICAgICAgICAgICAgICAgIGtDbHVzdGVyc1tqJDVdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpJDY9MDsgaSQ2PG47IGkkNisrKSB7XG4gICAgICAgICAgICAgICAgY2x1c3RlciA9IGFzc2lnbm1lbnRzW2kkNl07XG4gICAgICAgICAgICAgICAga0NsdXN0ZXJzW2NsdXN0ZXJdLnB1c2godmFsdWVzW2kkNl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRtcEtNZWFuc0JyZWFrcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiQ2PTA7IGokNjxudW07IGokNisrKSB7XG4gICAgICAgICAgICAgICAgdG1wS01lYW5zQnJlYWtzLnB1c2goa0NsdXN0ZXJzW2okNl1bMF0pO1xuICAgICAgICAgICAgICAgIHRtcEtNZWFuc0JyZWFrcy5wdXNoKGtDbHVzdGVyc1tqJDZdW2tDbHVzdGVyc1tqJDZdLmxlbmd0aC0xXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0bXBLTWVhbnNCcmVha3MgPSB0bXBLTWVhbnNCcmVha3Muc29ydChmdW5jdGlvbiAoYSxiKXsgcmV0dXJuIGEtYjsgfSk7XG4gICAgICAgICAgICBsaW1pdHMucHVzaCh0bXBLTWVhbnNCcmVha3NbMF0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQ3PTE7IGkkNyA8IHRtcEtNZWFuc0JyZWFrcy5sZW5ndGg7IGkkNys9IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IHRtcEtNZWFuc0JyZWFrc1tpJDddO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4odikgJiYgKGxpbWl0cy5pbmRleE9mKHYpID09PSAtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGltaXRzLnB1c2godik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW1pdHM7XG4gICAgfTtcblxuICAgIHZhciBhbmFseXplXzEgPSB7YW5hbHl6ZTogYW5hbHl6ZSwgbGltaXRzOiBsaW1pdHN9O1xuXG4gICAgdmFyIGNvbnRyYXN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgLy8gV0NBRyBjb250cmFzdCByYXRpb1xuICAgICAgICAvLyBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOC9SRUMtV0NBRzIwLTIwMDgxMjExLyNjb250cmFzdC1yYXRpb2RlZlxuICAgICAgICBhID0gbmV3IENvbG9yXzEoYSk7XG4gICAgICAgIGIgPSBuZXcgQ29sb3JfMShiKTtcbiAgICAgICAgdmFyIGwxID0gYS5sdW1pbmFuY2UoKTtcbiAgICAgICAgdmFyIGwyID0gYi5sdW1pbmFuY2UoKTtcbiAgICAgICAgcmV0dXJuIGwxID4gbDIgPyAobDEgKyAwLjA1KSAvIChsMiArIDAuMDUpIDogKGwyICsgMC4wNSkgLyAobDEgKyAwLjA1KTtcbiAgICB9O1xuXG4gICAgdmFyIHNxcnQkNCA9IE1hdGguc3FydDtcbiAgICB2YXIgYXRhbjIkMiA9IE1hdGguYXRhbjI7XG4gICAgdmFyIGFicyQxID0gTWF0aC5hYnM7XG4gICAgdmFyIGNvcyQ0ID0gTWF0aC5jb3M7XG4gICAgdmFyIFBJJDIgPSBNYXRoLlBJO1xuXG4gICAgdmFyIGRlbHRhRSA9IGZ1bmN0aW9uKGEsIGIsIEwsIEMpIHtcbiAgICAgICAgaWYgKCBMID09PSB2b2lkIDAgKSBMPTE7XG4gICAgICAgIGlmICggQyA9PT0gdm9pZCAwICkgQz0xO1xuXG4gICAgICAgIC8vIERlbHRhIEUgKENNQylcbiAgICAgICAgLy8gc2VlIGh0dHA6Ly93d3cuYnJ1Y2VsaW5kYmxvb20uY29tL2luZGV4Lmh0bWw/RXFuX0RlbHRhRV9DTUMuaHRtbFxuICAgICAgICBhID0gbmV3IENvbG9yXzEoYSk7XG4gICAgICAgIGIgPSBuZXcgQ29sb3JfMShiKTtcbiAgICAgICAgdmFyIHJlZiA9IEFycmF5LmZyb20oYS5sYWIoKSk7XG4gICAgICAgIHZhciBMMSA9IHJlZlswXTtcbiAgICAgICAgdmFyIGExID0gcmVmWzFdO1xuICAgICAgICB2YXIgYjEgPSByZWZbMl07XG4gICAgICAgIHZhciByZWYkMSA9IEFycmF5LmZyb20oYi5sYWIoKSk7XG4gICAgICAgIHZhciBMMiA9IHJlZiQxWzBdO1xuICAgICAgICB2YXIgYTIgPSByZWYkMVsxXTtcbiAgICAgICAgdmFyIGIyID0gcmVmJDFbMl07XG4gICAgICAgIHZhciBjMSA9IHNxcnQkNCgoYTEgKiBhMSkgKyAoYjEgKiBiMSkpO1xuICAgICAgICB2YXIgYzIgPSBzcXJ0JDQoKGEyICogYTIpICsgKGIyICogYjIpKTtcbiAgICAgICAgdmFyIHNsID0gTDEgPCAxNi4wID8gMC41MTEgOiAoMC4wNDA5NzUgKiBMMSkgLyAoMS4wICsgKDAuMDE3NjUgKiBMMSkpO1xuICAgICAgICB2YXIgc2MgPSAoKDAuMDYzOCAqIGMxKSAvICgxLjAgKyAoMC4wMTMxICogYzEpKSkgKyAwLjYzODtcbiAgICAgICAgdmFyIGgxID0gYzEgPCAwLjAwMDAwMSA/IDAuMCA6IChhdGFuMiQyKGIxLCBhMSkgKiAxODAuMCkgLyBQSSQyO1xuICAgICAgICB3aGlsZSAoaDEgPCAwKSB7IGgxICs9IDM2MDsgfVxuICAgICAgICB3aGlsZSAoaDEgPj0gMzYwKSB7IGgxIC09IDM2MDsgfVxuICAgICAgICB2YXIgdCA9IChoMSA+PSAxNjQuMCkgJiYgKGgxIDw9IDM0NS4wKSA/ICgwLjU2ICsgYWJzJDEoMC4yICogY29zJDQoKFBJJDIgKiAoaDEgKyAxNjguMCkpIC8gMTgwLjApKSkgOiAoMC4zNiArIGFicyQxKDAuNCAqIGNvcyQ0KChQSSQyICogKGgxICsgMzUuMCkpIC8gMTgwLjApKSk7XG4gICAgICAgIHZhciBjNCA9IGMxICogYzEgKiBjMSAqIGMxO1xuICAgICAgICB2YXIgZiA9IHNxcnQkNChjNCAvIChjNCArIDE5MDAuMCkpO1xuICAgICAgICB2YXIgc2ggPSBzYyAqICgoKGYgKiB0KSArIDEuMCkgLSBmKTtcbiAgICAgICAgdmFyIGRlbEwgPSBMMSAtIEwyO1xuICAgICAgICB2YXIgZGVsQyA9IGMxIC0gYzI7XG4gICAgICAgIHZhciBkZWxBID0gYTEgLSBhMjtcbiAgICAgICAgdmFyIGRlbEIgPSBiMSAtIGIyO1xuICAgICAgICB2YXIgZEgyID0gKChkZWxBICogZGVsQSkgKyAoZGVsQiAqIGRlbEIpKSAtIChkZWxDICogZGVsQyk7XG4gICAgICAgIHZhciB2MSA9IGRlbEwgLyAoTCAqIHNsKTtcbiAgICAgICAgdmFyIHYyID0gZGVsQyAvIChDICogc2MpO1xuICAgICAgICB2YXIgdjMgPSBzaDtcbiAgICAgICAgcmV0dXJuIHNxcnQkNCgodjEgKiB2MSkgKyAodjIgKiB2MikgKyAoZEgyIC8gKHYzICogdjMpKSk7XG4gICAgfTtcblxuICAgIC8vIHNpbXBsZSBFdWNsaWRlYW4gZGlzdGFuY2VcbiAgICB2YXIgZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiLCBtb2RlKSB7XG4gICAgICAgIGlmICggbW9kZSA9PT0gdm9pZCAwICkgbW9kZT0nbGFiJztcblxuICAgICAgICAvLyBEZWx0YSBFIChDSUUgMTk3NilcbiAgICAgICAgLy8gc2VlIGh0dHA6Ly93d3cuYnJ1Y2VsaW5kYmxvb20uY29tL2luZGV4Lmh0bWw/RXF1YXRpb25zLmh0bWxcbiAgICAgICAgYSA9IG5ldyBDb2xvcl8xKGEpO1xuICAgICAgICBiID0gbmV3IENvbG9yXzEoYik7XG4gICAgICAgIHZhciBsMSA9IGEuZ2V0KG1vZGUpO1xuICAgICAgICB2YXIgbDIgPSBiLmdldChtb2RlKTtcbiAgICAgICAgdmFyIHN1bV9zcSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgaW4gbDEpIHtcbiAgICAgICAgICAgIHZhciBkID0gKGwxW2ldIHx8IDApIC0gKGwyW2ldIHx8IDApO1xuICAgICAgICAgICAgc3VtX3NxICs9IGQqZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHN1bV9zcSk7XG4gICAgfTtcblxuICAgIHZhciB2YWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3JfMSwgWyBudWxsIF0uY29uY2F0KCBhcmdzKSApKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gc29tZSBwcmUtZGVmaW5lZCBjb2xvciBzY2FsZXM6XG5cblxuXG5cbiAgICB2YXIgc2NhbGVzID0ge1xuICAgIFx0Y29vbDogZnVuY3Rpb24gY29vbCgpIHsgcmV0dXJuIHNjYWxlKFtjaHJvbWFfMS5oc2woMTgwLDEsLjkpLCBjaHJvbWFfMS5oc2woMjUwLC43LC40KV0pIH0sXG4gICAgXHRob3Q6IGZ1bmN0aW9uIGhvdCgpIHsgcmV0dXJuIHNjYWxlKFsnIzAwMCcsJyNmMDAnLCcjZmYwJywnI2ZmZiddLCBbMCwuMjUsLjc1LDFdKS5tb2RlKCdyZ2InKSB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAgICBDb2xvckJyZXdlciBjb2xvcnMgZm9yIGNocm9tYS5qc1xuXG4gICAgICAgIENvcHlyaWdodCAoYykgMjAwMiBDeW50aGlhIEJyZXdlciwgTWFyayBIYXJyb3dlciwgYW5kIFRoZVxuICAgICAgICBQZW5uc3lsdmFuaWEgU3RhdGUgVW5pdmVyc2l0eS5cblxuICAgICAgICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAgICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICAgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICAgICAgICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkXG4gICAgICAgIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SXG4gICAgICAgIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gICAgICAgIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgKi9cblxuICAgIHZhciBjb2xvcmJyZXdlciA9IHtcbiAgICAgICAgLy8gc2VxdWVudGlhbFxuICAgICAgICBPclJkOiBbJyNmZmY3ZWMnLCAnI2ZlZThjOCcsICcjZmRkNDllJywgJyNmZGJiODQnLCAnI2ZjOGQ1OScsICcjZWY2NTQ4JywgJyNkNzMwMWYnLCAnI2IzMDAwMCcsICcjN2YwMDAwJ10sXG4gICAgICAgIFB1QnU6IFsnI2ZmZjdmYicsICcjZWNlN2YyJywgJyNkMGQxZTYnLCAnI2E2YmRkYicsICcjNzRhOWNmJywgJyMzNjkwYzAnLCAnIzA1NzBiMCcsICcjMDQ1YThkJywgJyMwMjM4NTgnXSxcbiAgICAgICAgQnVQdTogWycjZjdmY2ZkJywgJyNlMGVjZjQnLCAnI2JmZDNlNicsICcjOWViY2RhJywgJyM4Yzk2YzYnLCAnIzhjNmJiMScsICcjODg0MTlkJywgJyM4MTBmN2MnLCAnIzRkMDA0YiddLFxuICAgICAgICBPcmFuZ2VzOiBbJyNmZmY1ZWInLCAnI2ZlZTZjZScsICcjZmRkMGEyJywgJyNmZGFlNmInLCAnI2ZkOGQzYycsICcjZjE2OTEzJywgJyNkOTQ4MDEnLCAnI2E2MzYwMycsICcjN2YyNzA0J10sXG4gICAgICAgIEJ1R246IFsnI2Y3ZmNmZCcsICcjZTVmNWY5JywgJyNjY2VjZTYnLCAnIzk5ZDhjOScsICcjNjZjMmE0JywgJyM0MWFlNzYnLCAnIzIzOGI0NScsICcjMDA2ZDJjJywgJyMwMDQ0MWInXSxcbiAgICAgICAgWWxPckJyOiBbJyNmZmZmZTUnLCAnI2ZmZjdiYycsICcjZmVlMzkxJywgJyNmZWM0NGYnLCAnI2ZlOTkyOScsICcjZWM3MDE0JywgJyNjYzRjMDInLCAnIzk5MzQwNCcsICcjNjYyNTA2J10sXG4gICAgICAgIFlsR246IFsnI2ZmZmZlNScsICcjZjdmY2I5JywgJyNkOWYwYTMnLCAnI2FkZGQ4ZScsICcjNzhjNjc5JywgJyM0MWFiNWQnLCAnIzIzODQ0MycsICcjMDA2ODM3JywgJyMwMDQ1MjknXSxcbiAgICAgICAgUmVkczogWycjZmZmNWYwJywgJyNmZWUwZDInLCAnI2ZjYmJhMScsICcjZmM5MjcyJywgJyNmYjZhNGEnLCAnI2VmM2IyYycsICcjY2IxODFkJywgJyNhNTBmMTUnLCAnIzY3MDAwZCddLFxuICAgICAgICBSZFB1OiBbJyNmZmY3ZjMnLCAnI2ZkZTBkZCcsICcjZmNjNWMwJywgJyNmYTlmYjUnLCAnI2Y3NjhhMScsICcjZGQzNDk3JywgJyNhZTAxN2UnLCAnIzdhMDE3NycsICcjNDkwMDZhJ10sXG4gICAgICAgIEdyZWVuczogWycjZjdmY2Y1JywgJyNlNWY1ZTAnLCAnI2M3ZTljMCcsICcjYTFkOTliJywgJyM3NGM0NzYnLCAnIzQxYWI1ZCcsICcjMjM4YjQ1JywgJyMwMDZkMmMnLCAnIzAwNDQxYiddLFxuICAgICAgICBZbEduQnU6IFsnI2ZmZmZkOScsICcjZWRmOGIxJywgJyNjN2U5YjQnLCAnIzdmY2RiYicsICcjNDFiNmM0JywgJyMxZDkxYzAnLCAnIzIyNWVhOCcsICcjMjUzNDk0JywgJyMwODFkNTgnXSxcbiAgICAgICAgUHVycGxlczogWycjZmNmYmZkJywgJyNlZmVkZjUnLCAnI2RhZGFlYicsICcjYmNiZGRjJywgJyM5ZTlhYzgnLCAnIzgwN2RiYScsICcjNmE1MWEzJywgJyM1NDI3OGYnLCAnIzNmMDA3ZCddLFxuICAgICAgICBHbkJ1OiBbJyNmN2ZjZjAnLCAnI2UwZjNkYicsICcjY2NlYmM1JywgJyNhOGRkYjUnLCAnIzdiY2NjNCcsICcjNGViM2QzJywgJyMyYjhjYmUnLCAnIzA4NjhhYycsICcjMDg0MDgxJ10sXG4gICAgICAgIEdyZXlzOiBbJyNmZmZmZmYnLCAnI2YwZjBmMCcsICcjZDlkOWQ5JywgJyNiZGJkYmQnLCAnIzk2OTY5NicsICcjNzM3MzczJywgJyM1MjUyNTInLCAnIzI1MjUyNScsICcjMDAwMDAwJ10sXG4gICAgICAgIFlsT3JSZDogWycjZmZmZmNjJywgJyNmZmVkYTAnLCAnI2ZlZDk3NicsICcjZmViMjRjJywgJyNmZDhkM2MnLCAnI2ZjNGUyYScsICcjZTMxYTFjJywgJyNiZDAwMjYnLCAnIzgwMDAyNiddLFxuICAgICAgICBQdVJkOiBbJyNmN2Y0ZjknLCAnI2U3ZTFlZicsICcjZDRiOWRhJywgJyNjOTk0YzcnLCAnI2RmNjViMCcsICcjZTcyOThhJywgJyNjZTEyNTYnLCAnIzk4MDA0MycsICcjNjcwMDFmJ10sXG4gICAgICAgIEJsdWVzOiBbJyNmN2ZiZmYnLCAnI2RlZWJmNycsICcjYzZkYmVmJywgJyM5ZWNhZTEnLCAnIzZiYWVkNicsICcjNDI5MmM2JywgJyMyMTcxYjUnLCAnIzA4NTE5YycsICcjMDgzMDZiJ10sXG4gICAgICAgIFB1QnVHbjogWycjZmZmN2ZiJywgJyNlY2UyZjAnLCAnI2QwZDFlNicsICcjYTZiZGRiJywgJyM2N2E5Y2YnLCAnIzM2OTBjMCcsICcjMDI4MThhJywgJyMwMTZjNTknLCAnIzAxNDYzNiddLFxuICAgICAgICBWaXJpZGlzOiBbJyM0NDAxNTQnLCAnIzQ4Mjc3NycsICcjM2Y0YThhJywgJyMzMTY3OGUnLCAnIzI2ODM4ZicsICcjMWY5ZDhhJywgJyM2Y2NlNWEnLCAnI2I2ZGUyYicsICcjZmVlODI1J10sXG5cbiAgICAgICAgLy8gZGl2ZXJnaW5nXG5cbiAgICAgICAgU3BlY3RyYWw6IFsnIzllMDE0MicsICcjZDUzZTRmJywgJyNmNDZkNDMnLCAnI2ZkYWU2MScsICcjZmVlMDhiJywgJyNmZmZmYmYnLCAnI2U2ZjU5OCcsICcjYWJkZGE0JywgJyM2NmMyYTUnLCAnIzMyODhiZCcsICcjNWU0ZmEyJ10sXG4gICAgICAgIFJkWWxHbjogWycjYTUwMDI2JywgJyNkNzMwMjcnLCAnI2Y0NmQ0MycsICcjZmRhZTYxJywgJyNmZWUwOGInLCAnI2ZmZmZiZicsICcjZDllZjhiJywgJyNhNmQ5NmEnLCAnIzY2YmQ2MycsICcjMWE5ODUwJywgJyMwMDY4MzcnXSxcbiAgICAgICAgUmRCdTogWycjNjcwMDFmJywgJyNiMjE4MmInLCAnI2Q2NjA0ZCcsICcjZjRhNTgyJywgJyNmZGRiYzcnLCAnI2Y3ZjdmNycsICcjZDFlNWYwJywgJyM5MmM1ZGUnLCAnIzQzOTNjMycsICcjMjE2NmFjJywgJyMwNTMwNjEnXSxcbiAgICAgICAgUGlZRzogWycjOGUwMTUyJywgJyNjNTFiN2QnLCAnI2RlNzdhZScsICcjZjFiNmRhJywgJyNmZGUwZWYnLCAnI2Y3ZjdmNycsICcjZTZmNWQwJywgJyNiOGUxODYnLCAnIzdmYmM0MScsICcjNGQ5MjIxJywgJyMyNzY0MTknXSxcbiAgICAgICAgUFJHbjogWycjNDAwMDRiJywgJyM3NjJhODMnLCAnIzk5NzBhYicsICcjYzJhNWNmJywgJyNlN2Q0ZTgnLCAnI2Y3ZjdmNycsICcjZDlmMGQzJywgJyNhNmRiYTAnLCAnIzVhYWU2MScsICcjMWI3ODM3JywgJyMwMDQ0MWInXSxcbiAgICAgICAgUmRZbEJ1OiBbJyNhNTAwMjYnLCAnI2Q3MzAyNycsICcjZjQ2ZDQzJywgJyNmZGFlNjEnLCAnI2ZlZTA5MCcsICcjZmZmZmJmJywgJyNlMGYzZjgnLCAnI2FiZDllOScsICcjNzRhZGQxJywgJyM0NTc1YjQnLCAnIzMxMzY5NSddLFxuICAgICAgICBCckJHOiBbJyM1NDMwMDUnLCAnIzhjNTEwYScsICcjYmY4MTJkJywgJyNkZmMyN2QnLCAnI2Y2ZThjMycsICcjZjVmNWY1JywgJyNjN2VhZTUnLCAnIzgwY2RjMScsICcjMzU5NzhmJywgJyMwMTY2NWUnLCAnIzAwM2MzMCddLFxuICAgICAgICBSZEd5OiBbJyM2NzAwMWYnLCAnI2IyMTgyYicsICcjZDY2MDRkJywgJyNmNGE1ODInLCAnI2ZkZGJjNycsICcjZmZmZmZmJywgJyNlMGUwZTAnLCAnI2JhYmFiYScsICcjODc4Nzg3JywgJyM0ZDRkNGQnLCAnIzFhMWExYSddLFxuICAgICAgICBQdU9yOiBbJyM3ZjNiMDgnLCAnI2IzNTgwNicsICcjZTA4MjE0JywgJyNmZGI4NjMnLCAnI2ZlZTBiNicsICcjZjdmN2Y3JywgJyNkOGRhZWInLCAnI2IyYWJkMicsICcjODA3M2FjJywgJyM1NDI3ODgnLCAnIzJkMDA0YiddLFxuXG4gICAgICAgIC8vIHF1YWxpdGF0aXZlXG5cbiAgICAgICAgU2V0MjogWycjNjZjMmE1JywgJyNmYzhkNjInLCAnIzhkYTBjYicsICcjZTc4YWMzJywgJyNhNmQ4NTQnLCAnI2ZmZDkyZicsICcjZTVjNDk0JywgJyNiM2IzYjMnXSxcbiAgICAgICAgQWNjZW50OiBbJyM3ZmM5N2YnLCAnI2JlYWVkNCcsICcjZmRjMDg2JywgJyNmZmZmOTknLCAnIzM4NmNiMCcsICcjZjAwMjdmJywgJyNiZjViMTcnLCAnIzY2NjY2NiddLFxuICAgICAgICBTZXQxOiBbJyNlNDFhMWMnLCAnIzM3N2ViOCcsICcjNGRhZjRhJywgJyM5ODRlYTMnLCAnI2ZmN2YwMCcsICcjZmZmZjMzJywgJyNhNjU2MjgnLCAnI2Y3ODFiZicsICcjOTk5OTk5J10sXG4gICAgICAgIFNldDM6IFsnIzhkZDNjNycsICcjZmZmZmIzJywgJyNiZWJhZGEnLCAnI2ZiODA3MicsICcjODBiMWQzJywgJyNmZGI0NjInLCAnI2IzZGU2OScsICcjZmNjZGU1JywgJyNkOWQ5ZDknLCAnI2JjODBiZCcsICcjY2NlYmM1JywgJyNmZmVkNmYnXSxcbiAgICAgICAgRGFyazI6IFsnIzFiOWU3NycsICcjZDk1ZjAyJywgJyM3NTcwYjMnLCAnI2U3Mjk4YScsICcjNjZhNjFlJywgJyNlNmFiMDInLCAnI2E2NzYxZCcsICcjNjY2NjY2J10sXG4gICAgICAgIFBhaXJlZDogWycjYTZjZWUzJywgJyMxZjc4YjQnLCAnI2IyZGY4YScsICcjMzNhMDJjJywgJyNmYjlhOTknLCAnI2UzMWExYycsICcjZmRiZjZmJywgJyNmZjdmMDAnLCAnI2NhYjJkNicsICcjNmEzZDlhJywgJyNmZmZmOTknLCAnI2IxNTkyOCddLFxuICAgICAgICBQYXN0ZWwyOiBbJyNiM2UyY2QnLCAnI2ZkY2RhYycsICcjY2JkNWU4JywgJyNmNGNhZTQnLCAnI2U2ZjVjOScsICcjZmZmMmFlJywgJyNmMWUyY2MnLCAnI2NjY2NjYyddLFxuICAgICAgICBQYXN0ZWwxOiBbJyNmYmI0YWUnLCAnI2IzY2RlMycsICcjY2NlYmM1JywgJyNkZWNiZTQnLCAnI2ZlZDlhNicsICcjZmZmZmNjJywgJyNlNWQ4YmQnLCAnI2ZkZGFlYycsICcjZjJmMmYyJ10sXG4gICAgfTtcblxuICAgIC8vIGFkZCBsb3dlcmNhc2UgYWxpYXNlcyBmb3IgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaGVzXG4gICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gT2JqZWN0LmtleXMoY29sb3JicmV3ZXIpOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICB2YXIga2V5ID0gbGlzdCQxW2kkMV07XG5cbiAgICAgICAgY29sb3JicmV3ZXJba2V5LnRvTG93ZXJDYXNlKCldID0gY29sb3JicmV3ZXJba2V5XTtcbiAgICB9XG5cbiAgICB2YXIgY29sb3JicmV3ZXJfMSA9IGNvbG9yYnJld2VyO1xuXG4gICAgLy8gZmVlbCBmcmVlIHRvIGNvbW1lbnQgb3V0IGFueXRoaW5nIHRvIHJvbGx1cFxuICAgIC8vIGEgc21hbGxlciBjaHJvbWEuanMgYnVpbHRcblxuICAgIC8vIGlvIC0tPiBjb252ZXJ0IGNvbG9yc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuICAgIC8vIG9wZXJhdG9ycyAtLT4gbW9kaWZ5IGV4aXN0aW5nIENvbG9yc1xuXG5cblxuXG5cblxuXG5cblxuXG4gICAgLy8gaW50ZXJwb2xhdG9yc1xuXG5cblxuXG5cblxuXG5cblxuXG4gICAgLy8gZ2VuZXJhdG9ycyAtLSA+IGNyZWF0ZSBuZXcgY29sb3JzXG4gICAgY2hyb21hXzEuYXZlcmFnZSA9IGF2ZXJhZ2U7XG4gICAgY2hyb21hXzEuYmV6aWVyID0gYmV6aWVyXzE7XG4gICAgY2hyb21hXzEuYmxlbmQgPSBibGVuZF8xO1xuICAgIGNocm9tYV8xLmN1YmVoZWxpeCA9IGN1YmVoZWxpeDtcbiAgICBjaHJvbWFfMS5taXggPSBjaHJvbWFfMS5pbnRlcnBvbGF0ZSA9IG1peDtcbiAgICBjaHJvbWFfMS5yYW5kb20gPSByYW5kb21fMTtcbiAgICBjaHJvbWFfMS5zY2FsZSA9IHNjYWxlO1xuXG4gICAgLy8gb3RoZXIgdXRpbGl0eSBtZXRob2RzXG4gICAgY2hyb21hXzEuYW5hbHl6ZSA9IGFuYWx5emVfMS5hbmFseXplO1xuICAgIGNocm9tYV8xLmNvbnRyYXN0ID0gY29udHJhc3Q7XG4gICAgY2hyb21hXzEuZGVsdGFFID0gZGVsdGFFO1xuICAgIGNocm9tYV8xLmRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgY2hyb21hXzEubGltaXRzID0gYW5hbHl6ZV8xLmxpbWl0cztcbiAgICBjaHJvbWFfMS52YWxpZCA9IHZhbGlkO1xuXG4gICAgLy8gc2NhbGVcbiAgICBjaHJvbWFfMS5zY2FsZXMgPSBzY2FsZXM7XG5cbiAgICAvLyBjb2xvcnNcbiAgICBjaHJvbWFfMS5jb2xvcnMgPSB3M2N4MTFfMTtcbiAgICBjaHJvbWFfMS5icmV3ZXIgPSBjb2xvcmJyZXdlcl8xO1xuXG4gICAgdmFyIGNocm9tYV9qcyA9IGNocm9tYV8xO1xuXG4gICAgcmV0dXJuIGNocm9tYV9qcztcblxufSkpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///792\\n\")}},__webpack_module_cache__={};function __nested_webpack_require_637997__(g){var I=__webpack_module_cache__[g];if(void 0!==I)return I.exports;var B=__webpack_module_cache__[g]={exports:{}};return __webpack_modules__[g].call(B.exports,B,B.exports,__nested_webpack_require_637997__),B.exports}__nested_webpack_require_637997__.n=g=>{var I=g&&g.__esModule?()=>g.default:()=>g;return __nested_webpack_require_637997__.d(I,{a:I}),I},__nested_webpack_require_637997__.d=(g,I)=>{for(var B in I)__nested_webpack_require_637997__.o(I,B)&&!__nested_webpack_require_637997__.o(g,B)&&Object.defineProperty(g,B,{enumerable:!0,get:I[B]})},__nested_webpack_require_637997__.o=(g,I)=>Object.prototype.hasOwnProperty.call(g,I),__nested_webpack_require_637997__.r=g=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(g,\"__esModule\",{value:!0})};var __webpack_exports__=__nested_webpack_require_637997__(773);return __webpack_exports__})()}));\n\n//# sourceURL=webpack://svg-excalidraw/./node_modules/svg-to-excalidraw/dist/bundle.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ })()
;